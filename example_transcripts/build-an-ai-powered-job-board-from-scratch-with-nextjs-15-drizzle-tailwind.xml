<?xml version='1.0' encoding='utf-8'?>
<transcript video_title="Build an AI-Powered Job Board From Scratch with Next.js 15, Drizzle, Tailwind" upload_date="2025-06-17" duration="10h 29m 46s" video_url="https://www.youtube.com/watch?v=xIfSwINNM40">
  <chapters>
    <chapter title="Introduction" start_time="0:00">
      0:00
      In this video, I'm not only going to
      0:01
      show you how to build this job board,
      0:03
      which is fully functional, handles
      0:04
      users, organizations, payment plans,
      0:06
      subscriptions, everything you could want
      0:08
      out of a job board, but I'm also going
      0:10
      to show you how to take it to the next
      0:11
      level by adding in AI features all
      0:13
      throughout the entire application to
      0:15
      take it to the next level. On top of
      0:17
      that, I'm going to be showing you how to
      0:18
      integrate best practices with Nex.js,
      0:20
      TypeScript, databases, and so on to be
      0:22
      able to make this application not only
      0:24
      look good, but also be really clean code
      0:26
      and easy to maintain for you to want to
      0:27
      upgrade and work on in the future. This
      0:29
      is a massive project that will look
      0:31
      incredible on any resume or portfolio
      0:33
      and will teach you so many things that
      0:35
      will be useful in all of your projects
      0:36
      going forward. Also, before we get
      0:38
      started, I want to give a huge shout out
      0:40
      to the sponsors of this video, Clerk and
      0:42
      Ingest, because they made certain things
      0:43
      in this application so easy to work
      0:45
      with. For example, Clerk, we're going to
      0:47
      be using the newest billing features in
      0:48
      Clerk to be able to do subscription
      0:50
      billing. We also have organizations,
      0:52
      permissions, roles, all these other
      0:53
      features that are really painful to
      0:55
      implement on your own. We're going to be
      0:56
      using Clerk to make that super easy and
      0:58
      simple to work with. And ingest is an
      1:00
      absolutely amazing background job tool
      1:02
      that we're going to be using to
      1:02
      integrate all of our cron jobs,
      1:04
      background jobs, and most importantly,
      1:06
      integrating all of our different AI
      1:07
      features because doing that in plain
      1:08
      Nex.js is really difficult and annoying.
      1:10
      Honestly, I was blown away with how
      1:12
      impressive Injust was, and I really,
      1:13
      really like the tools. And the clerk
      1:15
      billing was just brain dead simple to
      1:16
      work with, which is why I love. If you
      1:18
      want to check out either of these tools
      1:19
      and use them yourself, I'll be linking
      1:20
      in the description. Clerk and Ingest.
      1:22
      [Music]
      1:25
      Welcome back to WebDev Simplified. My
      1:27
      name is Kyle and my job is to simplify
      1:29
      the web for you so you can start
      1:30
      building your dream project sooner. And
    </chapter>
    <chapter title="Demo" start_time="1:31">
      1:31
      before we start diving into the code of
      1:33
      this project, I want to give you a full
      1:34
      walkthrough of every single thing in the
      1:36
      application, all the features,
      1:37
      everything we're going to be working on.
      1:38
      So, this main page is the first page
      1:40
      that people are going to come to, and
      1:41
      it's where all the different job
      1:42
      listings are. You can see we can click
      1:44
      through and view all the details for
      1:45
      every single one of these job listings.
      1:47
      Doesn't matter which one it is, we can
      1:48
      swap between them. We have the ability
      1:50
      to resize the sections here. And as you
      1:51
      can see, everything is perfectly mobile
      1:53
      responsive. Even if we go down to a
      1:55
      mobile size screen. You can see we get
      1:56
      this little drawer side in which is
      1:57
      super handy. We also have the ability to
      1:59
      expand and collapse this different
      2:01
      sidebar if we want. And again on mobile
      2:03
      screens, we have the ability to do all
      2:04
      this as well. If I make this even
      2:05
      smaller, you can see if I come over
      2:07
      here, I have the ability to pull out
      2:09
      that drawer as well. So everything is
      2:10
      fully responsive across all screen
      2:12
      sizes. I can filter my jobs. For
      2:14
      example, if I want to only get remote
      2:15
      jobs, I can click here, remote, click
      2:16
      filter, and now you can see only the
      2:18
      remote jobs are showing up. So,
      2:19
      everything is working super perfectly
      2:20
      there. When it comes to some of the AI
      2:22
      features, you can see here I have the
      2:23
      ability to search based on different AI
      2:25
      properties. For example, if I want to
      2:27
      search for jobs that are going to be
      2:28
      fitted towards me, I can type in all my
      2:30
      different skills, experience, and what
      2:31
      I'm looking for, and it'll give me a job
      2:33
      for that. For example, this query just
      2:34
      says that I'm a mobile developer looking
      2:36
      for a job that pays at least 100,000 a
      2:38
      year. I mention the skills that I have
      2:39
      in certain tech stacks. In this case, I
      2:41
      just say most modern tech stacks. I'm
      2:42
      able to learn new tech stacks quickly,
      2:44
      so that's not a huge deal for me what
      2:45
      the tech stack is. Also, I specifically
      2:47
      mentioned that I don't enjoy web
      2:48
      development, so it hopefully doesn't
      2:49
      show me web development related jobs.
      2:51
      Now, once you type in as much
      2:52
      information as you want, you can click
      2:53
      search and the AI is going to use that
      2:55
      along with all the job listings to find
      2:57
      you the ones that fit you the best. In
      2:58
      our case, there's only one mobile
      3:00
      focused job that's listed. All the rest
      3:01
      are front end or backend developer. So,
      3:03
      you can see we get that job being pulled
      3:05
      up here. And now, I can actually go
      3:06
      ahead and apply for that job. So, we'll
      3:07
      click apply. You can see I can apply for
      3:09
      the job. I can add a cover letter if I
      3:10
      want. In my case, I'll just apply
      3:12
      without a cover letter. And now you can
      3:13
      see we've applied for that job. Now,
      3:15
      another amazing thing that happens
      3:16
      behind the scenes is when I apply for a
      3:18
      job, the AI is going to take my resume,
      3:20
      my cover letter, as well as all my other
      3:22
      requirements and skills, and it's going
      3:23
      to run that compared to the job listing
      3:25
      here, and it's going to figure out how
      3:26
      good of a fit I am for that job listing.
      3:28
      And we'll see that in a little bit when
      3:29
      we look at the back end for the employer
      3:31
      side of things. I do want to dive into
      3:33
      the settings, though, because we
      3:34
      actually have a few settings we can
      3:35
      configure. For example, I can send
      3:36
      myself a daily email notification. And
      3:38
      this is going to be based on that AI
      3:40
      search. So essentially, I can type in
      3:41
      whatever filter prompt I want inside of
      3:43
      here that's as specific as I want for
      3:44
      the jobs I'm looking for. And then
      3:46
      whenever a new job gets posted that fits
      3:48
      my AI criteria, it's going to send me an
      3:50
      email to let me know of the job that
      3:52
      fits my exact criteria. So again, we
      3:53
      have more AI built into this project
      3:55
      that's going to really help elevate the
      3:56
      experience for the user. Also, I have
      3:58
      the ability to upload a resume. For
      4:00
      example, I just have a boilerplate
      4:01
      front-end developer resume. So, this is
      4:03
      a front-end developer resume. And I
      4:04
      applied for a job specifically in the
      4:06
      Android space. So, we should hopefully
      4:07
      see that my rating is not super high. As
      4:09
      you can see down here, I then have an AI
      4:11
      summary. This is an AI summary generated
      4:13
      by our AI directly from our resume. And
      4:15
      this is what's used for helping with
      4:16
      that ranking system because essentially
      4:18
      we took that resume and generated out
      4:20
      some text we can put into our AI. And
      4:22
      anytime that I change or update my
      4:23
      resume, this summary down here is going
      4:25
      to automatically update from that AI for
      4:26
      us. Now, if we take a look at the
      4:28
      employer side, we can come over here and
      4:29
      we can see all the different job
      4:30
      listings we have active, as well as ones
      4:32
      we don't have active. Or if we had some
      4:34
      draft job listings, we could see those
      4:35
      as well. Now, the job I applied for is
      4:37
      this UX engineer job. So, if we go ahead
      4:38
      and we look at that, we can see that my
      4:40
      application under Kyle Cook only got a
      4:42
      two star rating because it really didn't
      4:44
      meet very many of the requirements for
      4:45
      our listing, while Sally got five stars
      4:47
      automatically from the AI because they
      4:48
      were a much better candidate. And the
      4:50
      nice thing is, let's say the AI messes
      4:52
      up, I can easily as the employer come in
      4:54
      here and be like, you know what,
      4:55
      actually this Kyle kid, he was a
      4:56
      four-star rating. And I can update that
      4:58
      and that's going to be updated
      4:58
      throughout my entire application. I can
      5:00
      also go through and view their resume if
      5:02
      I want to. I can also view their cover
      5:03
      letter with all the information they
      5:05
      type in. As you can see, this is just
      5:06
      some random test data typed into this
      5:07
      one. And I can go ahead and I can say,
      5:09
      you know what, we're actually interested
      5:10
      in this person, so I'm going to mark
      5:11
      them as interested so they show up
      5:12
      inside of our list and so on. On top of
      5:14
      that, I have all the normal features
      5:15
      that you would think of, such as being
      5:16
      able to edit, dellist a job, unfeature a
      5:18
      job, and delete a job listing. Inside of
      5:20
      my edit form, you can see I just have
      5:21
      all my normal stuff. I have a Wizzywig
      5:23
      editor, which is really nice to work
      5:24
      with all the different customization I
      5:26
      could possibly want. I could change
      5:27
      around if the salary is yearly or
      5:29
      hourly, and then update all the
      5:30
      information for that job listing. Now,
      5:32
      if I wanted to feature multiple jobs,
      5:34
      you'll notice that I'm unable to. If I
      5:35
      click feature, you can see I must
      5:36
      upgrade my plan to feature more job
      5:37
      listings. Same thing if I was want to
      5:39
      post another job. If I click publish,
      5:41
      you can see I need to upgrade my plan
      5:42
      cuz my plan only allows for three job
      5:44
      listings and only one of those can be
      5:45
      featured. So, let's say that I actually
      5:47
      do want to go ahead and update. You can
      5:48
      see I have all my billing information
      5:49
      right here. I can switch to whatever
      5:50
      plan I want. Let's say that I want to
      5:52
      switch to this plan. I can go ahead and
      5:53
      say that I want to pay that amount. And
      5:55
      it's going to give it a second to load.
      5:56
      And now I've automatically switched to
      5:57
      that higher tier plan. And I can go
      5:59
      ahead and I can publish this job listing
      6:00
      if I want. You can see that I can
      6:02
      feature this job listing because I have
      6:03
      the ability to feature multiple
      6:04
      different job listings. So, all this
      6:06
      different information is going to be
      6:07
      shown up. And if I go back to my job
      6:08
      board, that job right here, which is
      6:10
      front-end developer that's featured,
      6:11
      that is showing up right at the very
      6:12
      top. Now, if we go back to the employer
      6:13
      dashboard to kind of round out the last
      6:15
      few little features that we have, if we
      6:16
      go over here, we can actually modify our
      6:18
      user settings. So, if we come into that,
      6:20
      this just allows me to again get a daily
      6:21
      update email for every single applicant
      6:23
      that applies. And I can even change it
      6:25
      to be like, oh, you know what? I only
      6:26
      want to be candidates that are three
      6:27
      stars or greater. So, every time I get a
      6:29
      three star or greater candidate, I'm
      6:30
      going to get an email that summarizes
      6:32
      all the candidates that were sent to me
      6:33
      every single day. So I can go through
      6:34
      and I know exactly what job listings and
      6:36
      everything these candidates are for.
      6:37
      Another important thing to note is that
      6:38
      this application supports dark and light
      6:40
      mode fully. So as you can see here we
      6:42
      have a light mode version of our
      6:43
      application. All the different colors
      6:44
      and styling and everything is all built
      6:46
      out exactly the same. So you can easily
      6:47
      swap between the two depending on what
      6:49
      your browser preferences are. So now
      6:50
      it's time to actually start building our
    </chapter>
    <chapter title="Setup" start_time="6:52">
      6:52
      application and we're going to be using
      6:53
      Nex.js. So to create a nextJS
      6:55
      application we can just type in npx
      6:57
      create next app and instead of using the
      7:00
      latest version we're actually going to
      7:01
      be using the Canary version of Nex.js.
      7:03
      XJS because I want to use the new
      7:05
      dynamic IO features that I think are
      7:06
      really useful for doing caching related
      7:08
      things. And one thing that I
      7:10
      specifically want to mention while this
      7:11
      is going through and downloading
      7:12
      everything, we're just going to use for
      7:13
      the most part all the different default
      7:14
      settings for everything. So we're just
      7:15
      going to come through here and
      7:16
      specialize all those. One thing I do
      7:18
      want to mention though is that this
      7:19
      video is going to be fully timestamped.
      7:20
      So for example, the section that we talk
      7:22
      about next is something that you don't
      7:23
      really care to watch. You can skip ahead
      7:25
      by the time stamp so you can get to the
      7:26
      sections you specifically care about.
      7:28
      That way you're not going through a
      7:29
      bunch of stuff that you already know.
      7:30
      you can really focus on the core things
      7:32
      that you don't know. Now, one thing I'll
      7:33
      mention that if you do jump around a
      7:35
      bunch is that you're probably going to
      7:36
      miss some of the nuance on different
      7:37
      best practices and so on, but it's a
      7:39
      great place to go if you want to jump
      7:40
      around to look at specific features
      7:42
      inside the code. So, now that we have
      7:43
      our nextJS application created, we can
      7:45
      go ahead and we can just run that by
      7:47
      saying npm rundev and we should
      7:48
      hopefully see our boilerplate code on
      7:50
      the side. And to get started, I kind of
      7:51
      just want to delete all the stuff we
      7:52
      don't need. So, for example, I'll come
      7:54
      inside of here, get rid of a lot of the
      7:55
      different code that we don't care about.
      7:57
      Come all the way down to here. This is
      7:58
      all looking good inside of there. And
      8:00
      inside of here, I'm just going to export
      8:01
      a default function called homepage. And
      8:05
      it's just going to return an H1 that
      8:07
      says hi. There we go. So now, if I
      8:09
      refresh my page, we should just have the
      8:11
      text hi on our screen. There we go. You
      8:13
      can see that text high showing up. Now,
      8:14
      one thing I want to do is I accidentally
      8:15
      deleted this global CSS. So I just
      8:17
      brought that back by undoing that
      8:18
      deletion. And now we can go ahead and we
      8:20
      come in here. We make sure we have all
      8:21
      the different stuff we want. I can go
      8:23
      into my layout and make sure that I
      8:25
      reimpport that file. So we can go ahead
      8:26
      and reimpport that. And now if I
      8:28
      refresh, we can see that we actually
      8:29
      have our Tailwind styles being applied.
      8:30
      Our text just got a little smaller,
      8:31
      changed the font, and so on. Now, in
      8:32
      order to make sure we're using these
      8:34
      fonts that are being imported by Nex.js,
      8:36
      we just want to come in here and say
      8:37
      font sands, that's going to make sure
      8:39
      that we're specifically using these
      8:41
      fonts because they're hooked up as the
      8:42
      SANS version of our font. That'll just
      8:44
      make sure those are all hooked up
    </chapter>
    <chapter title="Database setup" start_time="8:45">
      8:45
      properly. Now, in pretty much every
      8:46
      single project, the very first thing
      8:48
      that I like to work on is my database.
      8:50
      So, we're going to come over. We're
      8:51
      going to be using Drizzle. We can just
      8:52
      kind of go through this getting started
      8:53
      documentation real quick, but we're
      8:54
      going to be using Drizzle with
      8:55
      Postgress. So in order to get this set
      8:57
      up, we can just minimize our application
      8:59
      for now. I want to install all the
      9:01
      different dependencies we're going to
      9:02
      need. We're first of all going to need
      9:03
      Drizzle OM. So we're going to get that
      9:05
      installed. We're going to need PG which
      9:07
      is for our Postgrace database. We're not
      9:09
      going to be needing because we're going
      9:11
      to be handling environment variables
      9:12
      through Nex.js. But I am going to
      9:14
      install a library which is the T3 OSS
      9:16
      env.js library which makes handling the
      9:19
      types of our environment variables much
      9:21
      easier. So we're going to install those.
      9:22
      And then we'll also need to install dev
      9:24
      dependencies. We'll need drizzle kit to
      9:25
      make sure we can do migrations and so
      9:26
      on. We need the types for postgress and
      9:28
      we actually don't need tsx because all
      9:30
      of that again is going to be handled
      9:31
      automatically for us. So we don't need
      9:33
      to worry about that. So we can say
      9:34
      npmi-d
      9:36
      we need drizzle kit and we need the
      9:38
      types for postgress. So we can say types
      9:40
      pg just like that. So that's all the
      9:42
      different libraries we need to get
      9:43
      drizzle set up. And there's a lot of
      9:45
      different ways you can run your
      9:46
      postgrace database. For example, passing
      9:47
      in a URL to a hosted database or a local
      9:50
      database. But in my case, I'm actually
      9:51
      going to be using Docker for this. So
      9:53
      we're going to have a slightly different
      9:54
      configuration set up. So to get
      9:55
      everything set up, we first want to
      9:56
      create a docker compose file. So we
      9:58
      could say docker-compose.yiml
      10:01
      for a yaml file. I'm going to paste in
      10:03
      what this docker is going to look like.
      10:04
      And then we'll come through and I'll
      10:05
      explain exactly what's going on. But
      10:07
      essentially all we're doing is we're
      10:08
      using the Postgress 17 image. You can
      10:10
      use whatever Postgress version or image
      10:12
      that you want. And then we just have a
      10:13
      bunch of environment variables. For
      10:14
      example, our host, our port, our
      10:16
      password, our username, and our database
      10:18
      name. All of these are just set up as
      10:20
      environment variables. So we can
      10:21
      configure those ourselves. And then
      10:22
      finally, I'm making sure I'm mounting a
      10:24
      volume and then exporting that volume.
      10:25
      All that really does is make it so that
      10:27
      our data in our database is actually
      10:29
      accessible by our application. So really
      10:31
      all this is doing is just hooking up
      10:33
      Postgress version 17 with all of our
      10:34
      environment variables and making that
      10:36
      data publicly available. Again, you
      10:38
      could host your database however you
      10:39
      want. It's up to you. Now to get those
      10:41
      environment variables set up, let's
      10:42
      create av file. And inside of here,
      10:44
      especially on larger projects, I like to
      10:46
      label what my environment variables are
      10:47
      for. So here's my database specific
      10:49
      environment variables. And we just have
      10:50
      our password set to password. Our user
      10:52
      set to Postgress. Our host is local
      10:53
      host. Port is 5432. And our database
      10:56
      name is going to be jobboard. Again, you
      10:57
      can call these things whatever you want.
      10:59
      It really doesn't matter. But that hooks
      11:00
      up everything related to our database.
      11:02
      So now we have our database. We have our
      11:04
      actual compose file for Docker. So we
      11:06
      should be able to actually at least get
      11:07
      our database up and running by running
      11:08
      docker compose up. And that should start
      11:12
      up our Docker container with all of our
      11:13
      database related information. Now, the
      11:15
      next step after all that is going to be
      11:16
      to work on setting up our schema files
      11:18
      as well as our Drizzle configuration
      11:20
      file. So, to get this Drizzle config,
      11:22
      I'm just going to copy the code that
      11:23
      they have. I'm going to create a brand
      11:24
      new file. We're going to call this
      11:26
      Drizzle.config.ts.
      11:30
      I'm going to paste in that code right
      11:31
      there for Drizzle. And one thing that I
      11:33
      want to change is I want to put my
      11:34
      migrations inside the source folder. So,
      11:36
      I'm going to say /source right here. So,
      11:38
      that way everything is inside my source
      11:40
      folder inside of Drizzle. And same thing
      11:42
      here, instead of calling this DB, I'm
      11:43
      going to call this Drizzle. So I have a
      11:44
      drizzle folder that contains everything.
      11:46
      Now I do want to use my own way of using
      11:48
      environment variables. That's what that
      11:50
      T3 library I installed this for. So
      11:52
      we'll say envatabase
      11:54
      URL. There we go. And all we need to do
      11:56
      is create this environment variable. So
      11:59
      inside of our source I'm going to create
      12:00
      a new folder called data. This is for
      12:02
      constant things like our environment.
      12:03
      And inside of here I'm going to create
      12:04
      another folder called env. And then
      12:06
      inside of that folder I'm going to
      12:07
      create a file called server.ts. And this
      12:10
      is for all of our server focused
      12:11
      environment variables. and we can create
      12:12
      a brand new file for our client side
      12:14
      ones if we need any of those at all. So
      12:15
      all we want to do is we want to export a
      12:17
      constant variable called env. And we're
      12:19
      going to set that to create env.
      12:23
      And we can pass in all of our different
      12:25
      server related variables into here. Now
      12:27
      to work with this we are going to need
      12:28
      to install zod. So I'm going to come
      12:30
      over here with a brand new terminal npm
      12:32
      zod which is going to be using all of
      12:33
      our different validations. It's
      12:35
      validation library so we can get all of
      12:36
      our type safety for all of our different
      12:37
      things. It's going to be heavily used
      12:39
      throughout our entire application. And
      12:41
      for example, we know that we have our DB
      12:43
      host variable and we know that this is
      12:45
      going to be a string just like that from
      12:47
      zod. So let me make sure that I import a
      12:48
      zod. And we again want to make sure that
      12:50
      this has a minimum value of one so that
      12:52
      we know that we have a value being
      12:53
      passed in. And that's again just coming
      12:55
      directly from here. So we essentially
      12:56
      need to set up a environment variable
      12:58
      for every single one of these. So I'm
      12:59
      going to copy this down a bunch of
      13:00
      times. We have our password, we have our
      13:02
      user, we have our port, and we have our
      13:05
      name. And that should be all of our
      13:06
      different stuff. Let me get these in the
      13:07
      exact same order. There we go. Minimize
      13:09
      all that down. So now we have our five
      13:11
      environment variables set inside of here
      13:12
      to set up our environment. To hook up
      13:14
      these environment variables, I can use
      13:15
      the experimental runtime property and
      13:17
      pass in our process.v. And that takes
      13:20
      all of our environment variables from
      13:21
      here and runs them through this AZOD
      13:22
      validation that we created. Finally,
      13:24
      there's a few extra things I want to do.
      13:26
      I want to make sure empty strings come
      13:27
      across as undefined. So I'm going to set
      13:29
      that to true. And then I actually want
      13:30
      to do a bit of a transformation. And
      13:32
      that's because these environment
      13:34
      variables for DB password, user, host,
      13:36
      port, and name, they're only useful
      13:37
      specifically for our Docker file. But
      13:39
      when it comes to, for example, Drizzle,
      13:41
      you can see here that we're using a
      13:42
      database URL instead. So we want to
      13:45
      convert those into a database URL, which
      13:47
      is actually rather easy to do. What we
      13:48
      can do inside of here is we can use the
      13:50
      create final schema function, which is
      13:52
      going to take in all of our different
      13:53
      environment variables just like this.
      13:55
      And it's going to return to us something
      13:57
      new. So we can return a new ZOD object.
      13:59
      And this ZOD object is going to take our
      14:01
      environment variable, all of those
      14:02
      things. And all we want to do is we want
      14:04
      to transform that. So this ENV object is
      14:06
      literally just this object right here.
      14:08
      So we're passing that in to make it into
      14:09
      a ZOD object. And then by doing a
      14:10
      transform we can essentially convert
      14:12
      from one value to another value. So what
      14:14
      I want to do is I want to get all of my
      14:15
      different environment variables. So in
      14:17
      my case we have DB host. We have DB
      14:20
      name, DB password, DB port and the DB
      14:25
      user. And then I want to take whatever
      14:27
      the rest of my environment variables
      14:28
      are. I'm just going to call those rest.
      14:30
      And we'll set that equal to whatever our
      14:31
      value is. So now you can see this DB
      14:33
      host is a string name value and so on.
      14:35
      So essentially this right here is just
      14:37
      the version of our code. So whatever our
      14:38
      DB host is from our environment variable
      14:40
      will be set right here and any
      14:42
      additional environment variables we have
      14:43
      will be saved in this rest variable. Now
      14:45
      what I can do is I can return an object
      14:47
      that is essentially the final version of
      14:48
      our code. So I can take all the rest of
      14:50
      our environment variables, keep those
      14:51
      exactly the same, don't change them.
      14:53
      Then I can create a brand new
      14:54
      environment variable called database
      14:56
      URL. And then I can just use all of
      15:00
      these different parameters to hook up
      15:01
      that environment variable. So I can say
      15:03
      Postgress and I just want to get my DB
      15:05
      user and then I want to get my password
      15:08
      after that. DB password and this is just
      15:10
      the standard syntax for how you actually
      15:12
      hook up a URL using all these different
      15:15
      parameters inside of Postgress. So this
      15:17
      is all around how Postgress works.
      15:19
      Finally, we can use the at symbol and
      15:20
      this is going to specify our DB host.
      15:22
      And then finally we can specify our DB
      15:24
      port as well. There we go. And then
      15:27
      lastly, we need what the database name
      15:28
      is. So we can say DB name just like
      15:31
      that. So we've taken all these variables
      15:32
      and converted them into a URL. So now
      15:35
      when we use this environment variable
      15:36
      object, you can see right now the only
      15:38
      thing it returns is a database URL. If
      15:40
      we were to add additional things to here
      15:42
      such as test and we'll make that as the
      15:45
      string.
      15:47
      There we go. And now I come back into
      15:49
      this file, you can see my environment
      15:50
      variable now has that test object as
      15:52
      well because we didn't change anything
      15:53
      except for these values right here. We
      15:55
      essentially converted into one value
      15:56
      instead of individual values. So we have
      15:59
      all that set up. Our Drizzle config is
      16:00
      entirely done. All that's left to do is
      16:02
      to create our schemas and everything
      16:03
      around the schema. And this is actually
      16:05
      not too difficult. So, the first thing
      16:06
      we need to do is we need to go into our
      16:07
      source folder and we're going to create
      16:08
      a brand new folder called Drizzle.
      16:10
      Inside of here, we're going to create a
      16:11
      folder called schema where we're going
      16:13
      to put all of our different schema
      16:14
      files. We're going to have a file called
      16:16
      dbts. That's essentially just going to
      16:18
      be this file right here. So, I might as
      16:19
      well just copy this code, paste it in.
      16:21
      We're going to make some minor changes.
      16:22
      For example, we're going to export this
      16:24
      variable right here. And we're also
      16:25
      going to make sure we use our own
      16:27
      environment variable. So, we're going to
      16:28
      get that right there. Now, before we can
      16:30
      finish up inside of this file, because
      16:31
      we want to pass in our schema for all of
      16:32
      our type safety, we need to create a
      16:34
      file that's going to contain all of our
      16:36
      schema related code. So, we'll call this
      16:37
      schema.ts. And all this is going to do
      16:39
      is export all of our different schema
      16:41
      related variables. We don't have any
      16:43
      right now, but that's perfectly okay
      16:44
      because inside of here, we can import
      16:46
      that schema. So, we can say import a
      16:48
      star as schema from that file. So, that
      16:51
      file is specifically at /drizle/s
      16:54
      schema because that's where our file is.
      16:55
      And this at just essentially is inside
      16:57
      of our source folder. So now we have our
      16:59
      schema and we can pass that along just
      17:01
      like this. Now we're going to get some
      17:02
      type errors because right now this file
      17:03
      is completely empty. So it doesn't have
      17:05
      anything in it. But as soon as we start
      17:06
      implementing things, this is going to
      17:07
      work just fine. It's just going to give
      17:09
      us type safety for our schema. Now
      17:10
      another thing we don't need is we don't
      17:12
      need to run because we didn't need that
      17:14
      since our environment variables are all
      17:15
      handled by Nex.js. So we can remove
      17:17
      that. And now we can move on to the
      17:18
      actual creation of our schema. And
      17:20
      inside of our schema, we essentially
      17:21
      want to create an individual file for
      17:23
      each of our database tables to make it
      17:24
      easier to work with rather than putting
      17:25
      them all in one single file. So inside
      17:27
      of this schema here, let's go ahead and
      17:29
      we're create a user.ts file for our user
      17:31
      related schema. And then what I want to
      17:33
      do in this schema file is I want to
      17:35
      export star from and I want to go to
      17:37
      that schema file. So we'll say drizzle.
      17:42
      There we go. Slash schema or not schema.
      17:45
      Yeah, it's going to be slash schema/
      17:47
      user. Just like that. So we're
      17:48
      essentially exporting everything that's
      17:49
      inside this particular file. So anything
      17:51
      that we export from here is going to be
      17:53
      exported from here. And essentially it
      17:54
      takes all the files inside of here and
      17:56
      exports them from this one file so we
      17:58
      can use them properly inside of here. So
      18:00
      let's go ahead and actually create our
      18:01
      tables. We'll say const user table is
      18:04
      equal to pg table. Just like that. Make
      18:06
      sure we get it imported. We can name our
      18:08
      table users. And now we need to specify
      18:10
      all the different keys of our table. For
      18:11
      example, we're going to have an ID key
      18:13
      for our table. And we're going to be
      18:14
      using clerk for all of our different
      18:15
      authentication needs. So we're going to
      18:17
      get the ID directly from clerk which is
      18:19
      a string. So in our case we're going to
      18:20
      be using a var directly from Postgress.
      18:23
      And we're going to make sure that this
      18:24
      is denoted as the primary key of our
      18:26
      table. Then we're going to need to have
      18:27
      a name field which is going to be pretty
      18:29
      similar. It's going to be a varchchar.
      18:30
      And we want to make sure it's not null.
      18:32
      Just like that. We're also going to have
      18:33
      an image URL. There we go. This is again
      18:36
      a var. And we know that it's not going
      18:39
      to be null because clerk is always going
      18:41
      to return to us an image URL. So we can
      18:42
      specify that is not null. And then we
      18:44
      have our email, which again is pretty
      18:46
      much going to be exactly the same. It's
      18:48
      going to be not null. And we also want
      18:49
      to make sure that it's unique because a
      18:51
      user can't have two different accounts
      18:52
      with the same email. It must be unique
      18:54
      to that user. Then finally, we need to
      18:56
      specify a created at and an updated at
      18:58
      field. And I'm actually going to export
      19:00
      these out into separate variables. So
      19:02
      we're going to say created at updated
      19:03
      at. I'm going to create a brand new file
      19:04
      called schema helpers that's going to
      19:06
      contain things that are shared between
      19:08
      all of our different schemas such as
      19:09
      created at and updated at. So I'll just
      19:11
      go ahead and I'll paste in the code for
      19:12
      this actually because it's rather
      19:13
      straightforward and I'll explain exactly
      19:14
      what it does. Essentially our created
      19:16
      app at field here you can see as a time
      19:17
      stamp with a time zone just so we can
      19:19
      make sure we do time zone properly
      19:20
      conversions. We're making it not null
      19:22
      and we're defaulting it to the current
      19:23
      value. Updated at is exactly the same
      19:25
      except we're adding in this on update
      19:27
      field to essentially give it the new
      19:29
      date. So every time we update our table,
      19:31
      it's going to take this value and it's
      19:32
      going to give us a brand new date for
      19:33
      the updated at field. So with that done,
      19:35
      we can now just make sure we import
      19:37
      created at and updated at from that
      19:39
      file. And now we can use that through
      19:40
      all of our different code. So now we
      19:42
      already have a table set up for users
      19:43
      inside of our database. But we want to
      19:45
      go ahead and we're just going to create
      19:46
      all the tables for our application right
      19:48
      away just so we don't have to jump back
      19:49
      and forth between our database. And this
      19:51
      is a lot of times what I do with an
      19:52
      application is I create a large chunk of
      19:54
      my database tables right away because
      19:55
      it's kind of the thing that I think
      19:56
      about and plan when I'm creating these
      19:58
      larger scale applications. So let's come
      20:00
      in here with the very next thing. And
      20:01
      the next thing we want to do is going to
      20:02
      be organizations. So we'll say
      20:04
      organization.ts. And this is going to be
      20:05
      very similar to user. So I'm going to
      20:07
      kind of copy all the code from here. And
      20:09
      this is going to be our organization
      20:10
      table and it's going to be called
      20:12
      organizations. Now they're going to have
      20:13
      the same ID because this is again coming
      20:15
      from clerk. We're going to be using a
      20:16
      varchchar. The name is not going to be
      20:17
      null. The one thing that is different is
      20:19
      image urls can be null for organizations
      20:21
      just because of how clerk handles
      20:22
      things. So we'll make sure that that's
      20:24
      nullable. And then finally we'll get rid
      20:25
      of this email field cuz we don't have
      20:26
      emails for organizations. And that's all
      20:28
      we need to do for our organization. It's
      20:29
      very similar to users like I said. Now
      20:31
      the next big table which is where the
      20:32
      bulk of our application code is going to
      20:34
      go is going to be this job listing
      20:36
      table. So we'll say job listing just
      20:37
      like that. Export consting
      20:41
      table equals and that's PG table. And
      20:44
      we'll call this job listings.
      20:47
      And inside this table, we're going to be
      20:48
      passing in a bunch of different
      20:49
      parameters. For example, this table is
      20:50
      going to have an ID. And unlike our
      20:52
      other tables which use varchars as our
      20:54
      ids, we're actually going to be using an
      20:56
      UYU ID. And every single table that has
      20:58
      an ID is going to have this exact same
      21:00
      UU ID format. And this is just going to
      21:02
      be simply a UU ID as our primary key
      21:04
      that defaults to a random value. And
      21:06
      this is something that we're going to be
      21:07
      using throughout all of our different
      21:08
      tables that need an ID. So again,
      21:10
      something that I'm going to move into my
      21:11
      schema helpers. So we're going to export
      21:14
      a constant. It's going to be called ID
      21:16
      and it's going to be equal to that UYU
      21:18
      ID function just like this. So that way
      21:20
      again anywhere that we need to create a
      21:21
      unique identifier for our tables, we can
      21:23
      just import that ID function and it's
      21:25
      going to be used everywhere just like
      21:27
      that. Now we can remove this export
      21:29
      that's no longer needed and we can move
      21:30
      on to other things. For example, the
      21:32
      organization ID for whatever
      21:33
      organization is going to be used for
      21:35
      this job listing. So whichever one
      21:37
      posted it, we know that their ID is
      21:38
      going to be a varchchar. We know that we
      21:41
      want this to reference that table. So we
      21:43
      can say it's going to reference
      21:45
      the organization table ID. And of course
      21:48
      on delete whenever we delete an
      21:50
      organization, we want to delete all job
      21:52
      listings associated with it. So we're
      21:53
      going to specify cascade here. And we
      21:55
      can specify this as not null as well
      21:57
      just to make sure that we always pass in
      21:59
      an organization ID. I'm going to make
      22:01
      this a little bit bigger so it's easier
      22:02
      to work with. We can go ahead and get
      22:03
      the rest of these in place. For example,
      22:05
      we have a varchar for our title which is
      22:07
      not null. We're also going to have a
      22:09
      description and a wage. So the
      22:10
      description field here is going to be a
      22:12
      text input. And the difference between
      22:14
      text and varchchar is essentially a text
      22:15
      allows an infinite sized table of data
      22:18
      while varchar has a limit on the size
      22:19
      that it can be. So text is better for
      22:21
      this long form description field which
      22:23
      is most likely going to be very long.
      22:24
      For our wage, we're going to be using an
      22:26
      integer for like $100,000 a year and so
      22:28
      on. But we also need to specify a wage
      22:30
      interval because we could specify our
      22:32
      job salary as a yearly salary or an
      22:34
      hourly sal hourly. So we want to make
      22:36
      sure we come in here with a wage
      22:37
      interval enum that we're going to create
      22:39
      to hook up all that information. And
      22:41
      these are both nullable because we want
      22:43
      to make it so that users can post a job
      22:45
      without a wage associated with it. So
      22:48
      we're going to come up here and we're
      22:49
      going to export a constant called wage
      22:51
      intervals.
      22:52
      And this is going to be our array of our
      22:54
      different intervals. So we can have
      22:55
      hourly
      22:57
      and yearly. We're going to set that as a
      22:59
      constant variable. I'm also going to be
      23:01
      creating a type for this called wage
      23:03
      interval, which is just going to be
      23:04
      taking the type of wage intervals. Get
      23:08
      the number property from that. So as you
      23:09
      can see, it just gives us those two
      23:11
      values. And then finally, we need to
      23:12
      create that wage interval enum. So we
      23:14
      can export wage interval enum. And we
      23:18
      can set that to a pg enum. We can give
      23:20
      it whatever name that we want associated
      23:22
      with it. And then finally, we need to
      23:23
      give it all the different values that we
      23:25
      have associated with it. So now we have
      23:26
      this wage interval enum. And as you can
      23:28
      see, it's either hourly or yearly. The
      23:30
      next thing that we need to do below this
      23:32
      is to deal with the location. So we have
      23:34
      a state abbreviation
      23:36
      just like that. Make sure I spell that
      23:38
      properly. There we go. This is going to
      23:39
      be a varchchar. And again, this can be
      23:42
      null because they may not have a state
      23:43
      associated with it. Same thing here with
      23:45
      city. This is a var that can be null.
      23:47
      Then we need to specify here the is
      23:49
      featured. So we can say is featured.
      23:52
      This is going to be a boolean. Make sure
      23:54
      we import that from the correct
      23:55
      location. So if we want to import that
      23:57
      from up here. There we go. And then with
      23:59
      that boolean we can essentially say that
      24:01
      it cannot be null and that by default
      24:03
      it's going to be false because jobs are
      24:05
      not going to be featured by default
      24:06
      unless they manually specify they want
      24:08
      them to be featured. Also let's make
      24:10
      sure we export this type so we can use
      24:11
      in our application if we need to. So now
      24:14
      the last few things we need to add to
      24:15
      this table are all going to be more enum
      24:17
      related values. I'm going to copy over
      24:18
      the code and then we'll define
      24:19
      everything as we need. So we have a
      24:21
      location requirement, we have an
      24:23
      experience level, we have a status and
      24:24
      we have a type. So location requirement
      24:26
      is is it remote in office or hybrid. So
      24:29
      let's go ahead and we're going to set up
      24:30
      the enum for that. I'm just going to
      24:31
      copy this code because we're essentially
      24:33
      going to replace wage intervals with
      24:35
      location requirements. There we go. And
      24:38
      this should say location
      24:40
      requirement.
      24:43
      And same thing here,
      24:45
      location requirement. There we go. And
      24:47
      then let's make sure this is also
      24:49
      location requirement. Now we need to
      24:52
      specify what our location requirements
      24:53
      are. And as I mentioned, we have in
      24:55
      office, hybrid, or remote. So now those
      24:57
      are the only options we have available
      24:58
      for this. Just like that, as you can
      25:00
      see. Next up, we have our experience
      25:01
      level. And instead of making you watch
      25:03
      me type this out like I did before, we
      25:04
      have the exact same code. We're just
      25:06
      specifying junior, mid-level, and senior
      25:08
      as our experience levels. We also have
      25:09
      our job listing status. We come down
      25:11
      with that. It's either going to be
      25:12
      draft, published, or dlisted. So
      25:15
      essentially, if you took a job from
      25:16
      published and unpublish it, that's going
      25:18
      to be this D-listed status. And I
      25:20
      specifically want to differentiate that
      25:21
      from a draft job listing because of how
      25:23
      it integrates with when the job was
      25:25
      posted. Because if you dlist a job and
      25:27
      then relist it later, that's not going
      25:29
      to update the posted time on that job.
      25:31
      Now, finally, the last thing that we
      25:32
      have is going to be the job type. So, is
      25:34
      it a full-time job, part-time job,
      25:36
      internship, and so on? That's directly
      25:38
      inside of here, and that hooks up all
      25:39
      those different enums for us. They're
      25:41
      all defined exactly the same as the
      25:42
      enums that we've already defined. That's
      25:44
      why I just copy pasted the code around.
      25:45
      The one important thing to note is our
      25:47
      status is going to default to draft
      25:48
      because when we create a new job, we
      25:50
      want it to be in that draft status.
      25:52
      Lastly, as I kind of alluded at, we need
      25:54
      a posted that field to note when we
      25:55
      actually change this from draft to
      25:57
      published. And that's going to be again
      25:59
      very similar to our updated created at
      26:00
      fields. So for this one, we just want to
      26:02
      have a timestamp and that timestamp is
      26:04
      going to be with a specific time zone.
      26:06
      And then finally, we need to have
      26:07
      created at and updated at just like
      26:09
      that. And that's everything we need for
      26:11
      our job listing. As you can see, the
      26:12
      bulk of our complex database code is
      26:14
      directly inside of this one table. And
      26:16
      that makes sense because it's kind of
      26:17
      the whole bulk of our application. Now,
      26:19
      the final thing that I want to add is
      26:20
      going to be an index. And this is
      26:21
      optional. You don't technically need to
      26:22
      do this. Everything will work fine
      26:24
      without it. But I'm going to be creating
      26:25
      an index on our state abbreviation
      26:27
      table. There we go. Let me make sure we
      26:29
      get that in there. So,
      26:30
      table.stateabbreviation.
      26:31
      And the reason I'm doing this is because
      26:33
      an index is great when you need to
      26:34
      filter or search by a particular column.
      26:36
      and we have the ability to search by our
      26:38
      state abbreviation. So, I'm adding an
      26:40
      index on that column. It'll make it so
      26:42
      that when we write to our database, when
      26:44
      we add new job listings, it's slightly
      26:45
      slower, but every single time that we
      26:47
      search for state abbreviations for job
      26:49
      listings, those searches are going to be
      26:51
      quicker for us. So, since most of our
      26:53
      application is going to be spent on the
      26:55
      actual searching of job listings and
      26:56
      much less on the posting, it makes sense
      26:58
      to add an index for this particular
      26:59
      table. And the next table I want to
      27:01
      create is going to be another big table
      27:02
      for our application and that is the job
      27:04
      listing application table. So, we'll
      27:06
      come in here just like that. I'm
      27:07
      actually going to copy over what the
      27:09
      table looks like and then I'll explain
      27:10
      every single thing in depth for you. So,
      27:12
      we'll come in here. We'll make sure we
      27:13
      import everything properly. Get it all
      27:16
      from that PG library. Get the two tables
      27:19
      that we created imported. And then
      27:20
      finally, these last few columns. And
      27:22
      then again, like I said, I will explain
      27:23
      exactly what every single one of these
      27:25
      different sections looks like so you
      27:26
      know what's going on. Finally, get
      27:28
      primary key. And there we go. So, if we
      27:30
      take a quick look at this table, you can
      27:32
      see that we have a job listing ID and a
      27:34
      user ID. And that's because every
      27:35
      application is going to be associated
      27:37
      with one user and one job listing.
      27:39
      You'll notice we don't even have an ID
      27:40
      column at all. And that's because in
      27:42
      this particular table, our job listing
      27:44
      ID and our user ID act as our primary
      27:46
      key. And to denote that, we just come
      27:48
      down here and we specify our primary key
      27:50
      is going to be a joint primary key on
      27:52
      these two columns. So our job listing ID
      27:54
      and our user ID combined together make
      27:56
      up our primary key. Now, anytime we
      27:58
      delete a job listing or a user, we're
      28:00
      going to make sure we delete the job
      28:01
      listings assoc or the job listing
      28:03
      applications associated with that user
      28:05
      or job listing. We have the ability to
      28:07
      upload a cover letter, which in this
      28:08
      case should be a text column. So, I'm
      28:10
      going to change that to text just
      28:11
      because this could be a very large
      28:12
      amount of text being passed in. We also
      28:14
      have our rating right here, which is
      28:16
      going to be that number between 1 and
      28:18
      five or null in the case that an
      28:19
      applicant has not been rated yet, which
      28:21
      could happen if the AI is not running or
      28:23
      they want to change the rating manually
      28:25
      from a rating to not rated. Finally, we
      28:27
      have an application stage enum, which
      28:29
      I'm going to copy over because it's
      28:30
      exactly the same as every other enum
      28:32
      that we've defined. As you can see here,
      28:33
      we have denied, applied, interested,
      28:35
      interviewed, and hired. These are the
      28:37
      different stages that an applicant can
      28:38
      go through whenever they're looking at
      28:40
      the application. So, denied is if they
      28:42
      don't want to work with them. Applied is
      28:44
      like the default stage, as you can see
      28:45
      here. That's the default. And then
      28:46
      finally, different stages based on where
      28:48
      they are in the interview process. So,
      28:49
      that's all the code right there for our
      28:50
      job listing application. Overall, it's
      28:52
      really straightforward. It's really just
      28:53
      a join between the job listing and the
      28:55
      user table with a little bit of
      28:56
      additional information for like the
      28:58
      stage, rating, and cover letter. Now, we
      28:59
      have three more tables to specify, but
      29:01
      these ones are going to be much smaller
      29:02
      because they're mostly setting based
      29:04
      tables. So, for example, we can come in
      29:05
      here with our organization,
      29:07
      user settings.ts, and this allows us to
      29:10
      set settings for a user underneath of an
      29:13
      organization. I'm again going to copy
      29:14
      over the code and then explain exactly
      29:16
      what's going on so it's quicker for you
      29:18
      to go through. You can see we're
      29:19
      creating a table called organization
      29:20
      user settings table. Give it a specific
      29:22
      name. And the important thing here is
      29:24
      we're linking our user ID and our
      29:26
      organization ID because each user is
      29:27
      going to be underneath of one or more
      29:30
      organizations or none. They could be
      29:31
      under no organizations. They could be
      29:33
      under one or they could be under many
      29:34
      different organizations with the same
      29:36
      user account. So we want to make sure
      29:38
      that we handle that inside of our
      29:39
      application. So for each combination of
      29:41
      user and organization, we're going to
      29:42
      make sure we have specific settings set.
      29:44
      And as you can see here, we're doing
      29:45
      that same primary key trick where we're
      29:47
      doing a joint primary key on our user ID
      29:49
      and organization ID because those are
      29:50
      the two things that need to be unique.
      29:52
      Now, the only settings we really have is
      29:54
      do you want to be set an email daily on
      29:56
      new applicants and what is the minimum
      29:58
      rating that you specify for those
      29:59
      applicants. So, this is the only thing
      30:01
      that we have inside of our user
      30:02
      organization settings. Rather
      30:04
      straightforward stuff and it's going to
      30:05
      be similar with the rest of our settings
      30:06
      tables. Obviously, if you want to add
      30:08
      additional settings, this is the place
      30:10
      you would do them if you want to expand
      30:11
      upon this application. Now we can dive
      30:13
      into our user settings which I actually
      30:14
      kind of have split up a little bit. So
      30:16
      we can come in here. We have our user
      30:18
      notification settings. Just like that.
      30:20
      And I want to make sure that this is a
      30:22
      TS file, not TSX. There we go. We can
      30:24
      paste in the code for this. Again, very
      30:25
      similar. We have our user notification
      30:27
      settings table. We have the name of our
      30:28
      table. We have our user ID, which is our
      30:30
      primary key. We don't need to worry
      30:31
      about any joint primary keys cuz it's
      30:33
      associated with just with one particular
      30:34
      user. And again, we have do you want to
      30:36
      be sent emails? And if so, do you have
      30:38
      an AI prompt associated with that that
      30:40
      you want to use, or do you just want to
      30:41
      be sent emails on every single new job
      30:43
      that's posted? Again, this is a
      30:45
      relatively straightforward table. It's
      30:46
      almost identical to the organization
      30:48
      one. The last table we have is for
      30:50
      managing the resume for a user. So, we
      30:52
      can come in here. Again, I'll paste it
      30:53
      down and explain what's going on. We
      30:55
      have our user resumeé table. Again, the
      30:56
      primary key is just our user ID because
      30:59
      we're only having one resume per user.
      31:01
      We don't need a specific ID for this
      31:02
      table alone. And then we have a ré file
      31:05
      URL. This is the URL to where that
      31:07
      actual file is hosted. And then we have
      31:09
      a ré file key. This is like the unique
      31:11
      ID that is used for our file hosting
      31:13
      system. So this is able to make us
      31:15
      delete files and so on for when we
      31:17
      upload new rums. We can delete the old
      31:18
      one using this particular key. Lastly,
      31:21
      we have an AI summary. And this is again
      31:23
      something that could be null. And this
      31:24
      is just what happens when we upload our
      31:26
      resume. In the background, the AI is
      31:27
      going to take care of everything for us,
      31:28
      generate the summary, and then put it
      31:30
      into our database, which is great. So
      31:31
      that's all of our tables created for us.
      31:33
      we can make sure that we export
      31:34
      everything inside this schema file. So
      31:36
      really what I want to do is I want to
      31:37
      take each one of these different schemas
      31:39
      that we created and I want to make sure
      31:40
      I export every single one of them so
      31:41
      they're used inside of our application
      31:43
      and I should probably name this with a
      31:45
      lowercase U to be consistent with the
      31:46
      rest of our applications. And now if I
      31:48
      come in here and put that in there that
      31:50
      should work just fine. Now the final
      31:51
      step that we have left to do with our
      31:52
      database to make sure that everything is
      31:53
      working fine is to make sure that we
      31:55
      define all of our relationships. This
      31:57
      isn't needed to define our database but
      31:59
      it makes working with Drizzle much
      32:00
      easier. For in our job listing for
      32:02
      example, we can come down here. We can
      32:03
      export a constant variable called job
      32:05
      listing references. It doesn't matter
      32:07
      what you called the variable. It just
      32:08
      matters that you export it and that you
      32:10
      call the relations function from
      32:12
      Drizzle. We can pass in the name of our
      32:14
      table, which is job listing table. And
      32:16
      then we can specify a function that's
      32:17
      going to take in a one and a many
      32:19
      function on it that we can use to define
      32:21
      all of our different relations. So
      32:23
      inside here we're going to return an
      32:24
      object and we're going to for example
      32:26
      have a relationship to an organization
      32:28
      and we're going to have a relationship
      32:29
      to applications. Now you can call these
      32:31
      keys whatever you want. It's just useful
      32:33
      because these are the names of the keys
      32:35
      inside of your application. So in our
      32:37
      case we have many applications. So I can
      32:39
      call many just like this and I can pass
      32:41
      it in the table that this is associated
      32:42
      with it which in our case is the job
      32:44
      listing application table. So we're
      32:45
      saying we have many job listing
      32:47
      application tables and we're going to
      32:48
      call them applications. Now inside here
      32:50
      for our one table we have to do a few
      32:52
      additional things. First of all we pass
      32:54
      along the table that we're associating
      32:55
      with this and then we also need to pass
      32:57
      along the fields associated with this.
      32:59
      So the fields is like what is the ID
      33:01
      column for this? In our case the ID
      33:02
      column for this is our job listing table
      33:04
      organization ID. So where is the ID from
      33:06
      our table? It's this particular one. And
      33:08
      then where is the ID that it references
      33:10
      in the other table. So this is going to
      33:12
      be the organization table ID. So we're
      33:14
      saying, hey, this organization ID
      33:16
      references the table ID for the
      33:18
      organization table. So this is just
      33:20
      hooking up those two tables together. So
      33:22
      we can really easily do different
      33:23
      queries between these different rows and
      33:24
      columns. Now, we essentially need to do
      33:26
      this throughout the rest of all of our
      33:27
      different tables. So in our job listing
      33:29
      application, we have the exact same
      33:30
      thing. We have a job listing application
      33:32
      relations. We're going to make sure that
      33:33
      this is going to have one job listing
      33:35
      and one user because we have a job
      33:36
      listing ID and a user ID. So we have
      33:39
      both of those right here inside of this
      33:40
      table. We can do the same thing with our
      33:42
      organization, which is going to be
      33:43
      rather straightforward. We can come in
      33:45
      here with relations. Make sure that we
      33:47
      import both of these different tables.
      33:49
      And this only has many job listings and
      33:51
      many organization settings because we
      33:53
      know that there are job listings that
      33:55
      point towards our organization just like
      33:57
      this. And we know that these
      33:58
      organization user settings point to an
      34:00
      organization ID as well. And there's
      34:02
      also options for many of these. Now,
      34:04
      speaking of the organization user
      34:06
      settings, we can actually do all of
      34:07
      these settings as well for the
      34:08
      relations. So, let me make sure I get
      34:10
      those imported in. And this is again a
      34:12
      relation that is a one relation. We have
      34:13
      one user and one organization
      34:15
      specifically for each one of these. So,
      34:17
      it's a relatively straightforward one to
      34:18
      set up. And the reason again I'm copy
      34:19
      pasting this code is because it's
      34:21
      exactly the same. All I'm doing is
      34:22
      changing where the field points to,
      34:23
      where it references, and what table
      34:25
      we're on. So, again, it's very simple
      34:27
      code. I'm just changing a few values.
      34:28
      So, instead of making me type all this
      34:29
      out and having you watch it, I'll just
      34:31
      copy and paste it around. Now, this one
      34:32
      I'm going to spend a little bit more
      34:33
      time talking about though because it's
      34:34
      actually slightly different than
      34:35
      everything we've talked about so far.
      34:37
      Let me just do a quick import here for
      34:39
      all these different rows that we have
      34:43
      and this one right here. And the reason
      34:44
      this is different is you notice we're
      34:46
      calling the one function but we're not
      34:47
      passing along all those additional
      34:49
      properties for fields, references and so
      34:51
      on. And that's because in this
      34:52
      particular case we have a onetoone
      34:54
      relationship. So each user table has
      34:57
      exactly one notification setting and our
      34:59
      notification settings has exactly one
      35:02
      user. So when you're doing a onetoone
      35:04
      relationship, whichever table does not
      35:06
      have the key, so in this case, our user
      35:08
      table does not contain the key that
      35:10
      points to the other table. Our user
      35:12
      notifications contains the key that
      35:14
      points to the other table. So the one
      35:15
      that does not contain that pointing key,
      35:17
      you don't need to specify any additional
      35:19
      properties. You can just say one and
      35:20
      specify what the table name is and
      35:22
      Drizzle's smart enough to figure out all
      35:23
      the rest of that for you. This is only
      35:25
      in a onetoone relationship. Often times
      35:27
      though, you have a one to many
      35:29
      relationship which is where you need to
      35:30
      specify all those additional keys. Now
      35:32
      speaking of this type of onetoone
      35:33
      relationship on the table that specifies
      35:35
      the actual foreign key in this case our
      35:37
      user notifications table this one needs
      35:40
      to specify all the additional fields to
      35:41
      hook up everything properly. So anytime
      35:43
      that you have a key on a table pointing
      35:45
      to another table and you're doing that
      35:47
      one to one relationship or one to many
      35:49
      doesn't matter you need to specify all
      35:50
      the additional properties to make sure
      35:52
      everything's hooked up inside of
      35:53
      Drizzle. Now the final table that we
      35:54
      have left is going to be our user resume
      35:56
      which is almost identical to the user
      35:58
      notifications. It's just instead
      35:59
      pointing to the resume table instead of
      36:02
      pointing to the user notifications
      36:03
      table, but otherwise it just has one
      36:05
      single user property. And with that
      36:06
      done, we actually have everything done
      36:08
      we need to create our database. Now we
      36:10
      can go ahead and actually work on
      36:11
      implementing this database and making it
      36:13
      run. So inside of our package JSON, I'm
      36:15
      going to add a few scripts down here.
      36:17
      We're going to have DB push, DB
      36:19
      generate, DB migrate, and DB studio. And
      36:21
      all these are is essentially aliases for
      36:23
      calling drizzle kit and then push
      36:25
      generate migrate or studio. And what
      36:27
      these commands do, push just takes your
      36:28
      database inside your schema and directly
      36:30
      pushes it to your database. There's no
      36:32
      migrations or anything like that. It's
      36:33
      just a direct here's your data, push it
      36:35
      directly to the database. It's really
      36:37
      useful in development when you're just
      36:39
      trying to work on a schema and making
      36:40
      multiple changes. But as soon as you're
      36:42
      ready to move to production, that's
      36:43
      where the migrate file is really useful.
      36:45
      Migrate is going to migrate based on
      36:47
      migrations you've generated. And the
      36:48
      generate command is what creates those
      36:50
      migrations for you. So I'll show you
      36:52
      exactly how that works. We can come in
      36:53
      here. We can say npm run db generate and
      36:56
      that's going to create a migration file
      36:58
      based on all of our different code that
      36:59
      when it runs is going to generate our
      37:01
      database for us. Now you can see we
      37:03
      haveenv config accidentally imported. I
      37:05
      don't need this imported because again
      37:06
      we're handling that all with nex.js. So
      37:08
      now I'm going to run that generate
      37:10
      command again and you can see inside of
      37:12
      drizzle I have this migration right
      37:14
      here. Now I'm going to slightly change
      37:15
      this. I want it to be inside of source
      37:17
      drizzle/
      37:18
      migrations just like that. So we can
      37:20
      come in here and we can delete all that
      37:22
      migration stuff. stuff it created. And
      37:24
      we can try rerunning that again. Now,
      37:26
      it's going to be pointing to the correct
      37:27
      folder. And you can see inside of here,
      37:28
      it created essentially a giant SQL file
      37:30
      that has all the code for creating all
      37:32
      of our different tables, altering all of
      37:34
      our tables, creating all of our enums.
      37:35
      Everything we need is directly inside of
      37:37
      this file. So now what we can do is we
      37:39
      can run npm run db migrate and it's
      37:43
      going to run this SQL code directly on
      37:45
      our database. So you can see if we run
      37:47
      that migrate command, it's pushing
      37:48
      everything up, but we are getting an
      37:49
      error. Now, the reason for that error is
      37:51
      entirely because of me. I had my testing
      37:53
      version of the database still running
      37:54
      and it was causing some conflicts for
      37:56
      what the new database should be. So, we
      37:58
      don't have to worry about that anymore.
      37:59
      That was now fixed. I ran that command
      38:00
      again. As you can see, it generated all
      38:02
      of my code, migrated everything, and now
      38:04
      my database has these tables inside of
      38:06
      it. So, to view what that looks like, we
      38:08
      can just come into our package JSON. We
      38:10
      can run that DB Studio command, and
      38:12
      that's going to let us introspect our
      38:13
      database. So, we can say studio, just
      38:15
      like that. Now, if we wait for that to
      38:16
      run real quick, we'll be able to open up
      38:18
      our database inside of our browser. So,
      38:20
      I'll make this full screen so it's
      38:21
      easier to see. And as you can see, we
      38:22
      have all of our different tables with
      38:24
      all of our different columns. For
      38:25
      example, our job listing and so on.
      38:26
      Currently, everything is completely
      38:28
      empty, which is perfectly fine. But now
      38:30
      we have all of our information directly
      38:31
      inside of our database. We can start
      38:33
      working with and using this database in
      38:34
      all of our application. So, now that we
    </chapter>
    <chapter title="Sidebar component" start_time="38:36">
      38:36
      have our database fully integrated and
      38:38
      set up, the next thing that we can work
      38:39
      on is making sure that our code looks a
      38:41
      little bit better. Because right now,
      38:42
      this is our entire site. So, let's go
      38:44
      ahead and start working on implementing
      38:45
      a sidebar. And to do that, we're going
      38:47
      to be using Shad CN. So let's make this
      38:49
      a little bit bigger so it's easier to
      38:50
      see and we can go through the setup
      38:52
      steps for shad CN. So we first want to
      38:54
      make sure that we initialize sad shad CN
      38:56
      inside of our project. We're going to
      38:57
      pretty much use all the different
      38:59
      default values for shad CN. So for our
      39:01
      color we're just going to use neutral as
      39:03
      the default color and we're going to be
      39:04
      making sure we use force for installing
      39:06
      all of our different dependencies. And
      39:07
      that's just because we're using React 19
      39:09
      and not quite all of the components in
      39:11
      Shad Cen are updated to React 19, but
      39:13
      they still work with React 19. So we
      39:15
      just need to make sure we force install
      39:16
      them to make sure that they work. This
      39:18
      is going to import all of our different
      39:19
      files for us. If we go inside of here,
      39:21
      we have the lib folder which our CN
      39:22
      function is inside of which is going to
      39:23
      be making sure we can combine our
      39:25
      classes. And now we can add the
      39:26
      different components we want. For
      39:27
      example, I can come in here and I can
      39:28
      add a button or in our case, we want to
      39:30
      add the sidebar component. Let's make
      39:32
      sure that I get that imported properly.
      39:34
      There we go. So that's going to add in
      39:36
      our sidebar component and it's most
      39:37
      likely going to ask us to force install
      39:39
      this, which is going to be fine. We're
      39:40
      going to do that with no problem. And
      39:42
      that's going to install a bunch of
      39:43
      different components. If we go inside of
      39:44
      our components UI folder, you can see we
      39:46
      now have a bunch of components for all
      39:48
      the things that are used inside of the
      39:49
      sidebar. Now, the sidebar inside of Shad
      39:51
      CN is a massive component that contains
      39:52
      a lot of different stuff. If we go into
      39:54
      the docs, we can actually look at the
      39:55
      sidebar component. If I scroll all the
      39:57
      way down here, you can see sidebar. This
      39:59
      is pretty much what we're going to be
      40:00
      building, a sidebar that looks kind of
      40:01
      like this. And if we scroll down, you
      40:03
      can see there's a ton of information on
      40:04
      this page on how to use sidebars. I
      40:06
      found that the best way to learn how to
      40:08
      use these was to go to the block
      40:09
      section, click on sidebar, and this
      40:11
      allows you to actually look through all
      40:12
      the different sidebars that are out
      40:13
      there, all the different code for them.
      40:15
      And if you want, you just click on code,
      40:16
      and it gives you the exact code for how
      40:18
      this sidebar was constructed and works.
      40:20
      And this is essentially how I went
      40:21
      through and figured out how to create
      40:22
      the sidebar that we wanted. And I even
      40:24
      stole some things from this. For
      40:25
      example, this little user picker right
      40:27
      here, I pretty much pulled directly from
      40:28
      this Jad CN page cuz it looks and
      40:30
      functions really well. Obviously, I
      40:31
      modified mine pretty heavily, but it's
      40:33
      very similar to what they have here.
      40:34
      here. So, what we can do inside of our
      40:35
      application, I'll make this quite a bit
      40:36
      larger because now we're going to work
      40:37
      on our code, is we can work on that
      40:39
      implementation. I'm going to come in
      40:40
      here, npm rundev, just so we have our
      40:43
      dev server up and running. And now, what
      40:44
      I want to do inside my app, we're going
      40:46
      to just go into a brand new page. We can
      40:48
      just put it in this page for now. We'll
      40:49
      move things around a little bit. And
      40:51
      what I want to do is I want to implement
      40:52
      that sidebar. Now, the very first thing
      40:54
      you need when you're working with a
      40:55
      sidebar is a sidebar provider. This is
      40:56
      kind of what wraps your entire sidebar.
      40:58
      And in our particular case, we want to
      41:00
      add in a class name here of overflow
      41:03
      y hidden just to make sure if anything
      41:05
      overflows in the y direction, it's going
      41:07
      to be hidden, which allows us to do
      41:08
      scrolling properly. So if for example,
      41:10
      our right side of our screen that's not
      41:11
      the sidebar is too tall, it's going to
      41:13
      make sure it scrolls without moving the
      41:15
      sidebar around erroneously. The next
      41:17
      thing we need is our actual sidebar
      41:19
      itself. So let's get our sidebar
      41:20
      component. And inside of here, we can do
      41:22
      whatever we want. In our case, we're
      41:24
      going to change the collapsible feature
      41:25
      to be icon. This means that when we
      41:27
      collapse our sidebar, it's going to
      41:29
      collapse down to icon sized instead of
      41:31
      completely disappearing off our page,
      41:32
      which is what we want for our particular
      41:34
      application. Also, I'm going to make
      41:36
      sure I add in the exact same class name
      41:37
      here of overflow hidden just to make
      41:39
      sure when we collapse down to that icon
      41:41
      size, all the other things that's too
      41:43
      large to fit inside of our sidebar
      41:45
      doesn't overflow the side of our
      41:46
      sidebar. Next, in our sidebar, we have
      41:48
      the sidebar header. This is something
      41:50
      that's going to be stuck to the top of
      41:52
      our page. In our case, we're going to
      41:53
      change this to be a flex row. And what I
      41:56
      want to do inside of this header is I
      41:57
      want to put the trigger for opening and
      41:59
      closing our sidebar as well as the name
      42:01
      of our application. So we can come in
      42:03
      here with our sidebar trigger just like
      42:05
      that. That's going to allow us to open
      42:06
      and close this. And then we can create a
      42:08
      span. And this span is going to say WDS
      42:10
      jobs or this would be whatever the name
      42:12
      of your application is. Now we can add
      42:14
      some class names in here. For example,
      42:16
      I'll make it extra large. And I'll make
      42:17
      it so the text doesn't wrap in case it's
      42:19
      too large. And now if we go to our
      42:21
      application and we give this a little
      42:22
      bit of a refresh, we should hopefully
      42:24
      see our sidebar showing up on the side.
      42:25
      Now it looks like it's taking a little
      42:27
      bit to refresh. That's fine. It's just
      42:29
      rendering this page for the very first
      42:30
      time inside of our application, but we
      42:32
      should see a sidebar show up in just a
      42:33
      little bit. Now, we're not seeing a
      42:34
      sidebar. And the reason for that is cuz
      42:36
      we're on a mobileized screen. If I
      42:38
      increase my screen size a little bit,
      42:39
      there we go. We can now see the sidebar
      42:41
      shows up. We collapse it, goes down to
      42:42
      the icon size, and so on. Now, you'll
      42:44
      notice when we collapse down to this
      42:45
      size that this icon is not perfectly
      42:47
      centered. Our W is still kind of showing
      42:49
      up right here. It's not exactly ideal.
      42:50
      So, we're going to go ahead and we're
      42:51
      fixing that by modifying our Shad CN
      42:53
      component. We're going to go into this
      42:55
      trigger and we're going to change a few
      42:56
      things. First of all, we're going to
      42:57
      change the size here to be eight. So,
      42:59
      it's going to be a little bit larger.
      43:00
      Now, when we minimize down, you can see
      43:01
      it's perfectly centered inside of our
      43:02
      sidebar, which is exactly what we want.
      43:04
      I'm also going to change which icon is
      43:06
      showing based on if it is open or
      43:07
      closed. So, we can come in here and get
      43:09
      the open property from use sidebar. And
      43:11
      then instead of rendering out this panel
      43:13
      left icon, I can render out the sidebar
      43:15
      close icon or the sidebar open icon from
      43:18
      Lucid icons. And now if we come over
      43:20
      here, you can see we get a different
      43:21
      icon based on if it is open or closed,
      43:23
      which is exactly what we want for our
      43:25
      content. So now with that out of the
      43:26
      way, we can go back to our page where
      43:27
      we're implementing our sidebar. And
      43:28
      that's everything for our header. And
      43:30
      again, this is going to be stuck to the
      43:31
      top of our page. So we don't want to put
      43:32
      too much content inside of here because
      43:34
      on smaller screen sizes, it's going to
      43:35
      take up a significant amount of our
      43:37
      page. Next thing that I want to work on
      43:38
      is going to be our sidebar content. This
      43:41
      is where we put all of our content for
      43:42
      like our filtering form and so on. Let
      43:44
      me make sure I import that properly. For
      43:46
      now, we're just going to leave this
      43:47
      blank. I'll put in a little bit of text.
      43:48
      Doesn't really matter, but that's
      43:49
      essentially where that content is going
      43:50
      to go. It's going to be the rest of our
      43:52
      sidebar. And this is going to be the
      43:54
      thing that scrolls if our sidebar has a
      43:56
      lot of content in it and so on. But for
      43:57
      now, we don't need to mess with anything
      43:59
      inside here cuz we don't have a filter
      44:00
      form or anything. I'm just trying to get
      44:01
      the overall layout of our page set up.
      44:04
      The final thing that I want to focus on
      44:05
      is going to be the footer section where
      44:07
      it's going to show essentially our login
      44:09
      link and all that. If we went back to
      44:11
      that Shad Shan page, that's the thing I
      44:12
      essentially copied from that Shad CN
      44:14
      page and modified for my use cases. So,
      44:16
      this is going to be inside the sidebar
      44:18
      footer. And inside here, we want to
      44:20
      specify a sidebar menu. Just like that.
      44:22
      Make sure I import both of these
      44:24
      components. And inside this sidebar
      44:25
      menu, we want to have a menu item. And
      44:28
      this is kind of how you structure things
      44:29
      inside of the sidebar in Chad Cenne. You
      44:31
      have your wrapper, whether it's content,
      44:33
      footer, header. Then if you want to
      44:34
      create items you can interact with, you
      44:36
      put them inside of a menu. You put them
      44:37
      inside of a menu item. And then
      44:39
      specifically, you put a sidebar menu
      44:41
      button. And that's how you do your
      44:43
      interaction with these specific things.
      44:44
      So I could just put some text inside of
      44:46
      here. I'll make this full screen. Now
      44:47
      you can see when I hover over this, it
      44:49
      gives me a small background behind it.
      44:50
      It's a little bit hard to see on this
      44:52
      screen color, but you can see it gives
      44:53
      me that slight background hover. Now I
      44:54
      find in dark mode, it's a little bit
      44:56
      easier to see these things. So, for now,
      44:57
      I'm just going to manually hardcode our
      44:59
      entire application in dark mode by
      45:01
      putting the dark class on here. We'll
      45:02
      come back and change this in a bit. But
      45:04
      now, you can see when I hover over this,
      45:05
      it's a little bit easier to see that
      45:06
      this is an interactable button on our
      45:08
      page. Now, the next thing that we need
      45:09
      to work on is where the rest of the
      45:11
      content on our page is. Everything on
      45:12
      this right hand side, that's going to be
      45:13
      directly outside the sidebar inside of a
      45:15
      main element. We're going to give it a
      45:17
      class name of flex one, so it grows to
      45:19
      fill the full size. And then we'll give
      45:20
      all of our children inside of here. Now,
      45:23
      we don't have any children cuz this is
      45:24
      our homepage. So, we can just put some
      45:25
      content inside of here. And you can see
      45:27
      that that shows up directly right there,
      45:28
      right next to our sidebar, which is
      45:30
      exactly what we want. We could add some
      45:31
      like margin on this, for example, but I
      45:33
      want that to be page by page. They can
      45:34
      add their own margin if needed. Now, in
      45:36
      order to fix the problem where our
      45:37
      sidebar disappears on mobile screens,
      45:39
      and we have no way to open it, we need
      45:41
      to create a brand new component that's
      45:43
      going to be a client component that's
      45:44
      going to allow us to show a single open
      45:46
      button when we're on a mobile screen
      45:48
      versus when we're not on a mobile
      45:49
      screen. So, I'm going to create a brand
      45:50
      new component. We'll just create it in
      45:52
      here for now. We'll reorganize things in
      45:53
      a little bit. And this is going to be
      45:54
      our app sidebar client.ts. And generally
      45:58
      when you're in the app folder, I
      45:59
      specifically like to put an underscore
      46:00
      in front of things that are not actually
      46:02
      pages in my application. And when I'm
      46:04
      trying to create a component that has
      46:06
      like two pieces, for example, I have my
      46:07
      sidebar here and then I have the client
      46:09
      version. I often put an underscore in
      46:11
      front of the client version because I
      46:12
      know that's not something I use
      46:13
      externally. It's only used internally.
      46:15
      And since in Nex.js to use a client
      46:17
      component, you need to create a brand
      46:19
      new file. That's just kind of a naming
      46:20
      convention that I like to use. So, we'll
      46:22
      export a function. It's going to be
      46:24
      called app sidebar client. Just like
      46:28
      that. And this function is going to take
      46:30
      in children. Essentially, that's going
      46:32
      to be our entire sidebar. So, we're
      46:34
      going to have some children.
      46:36
      If I can spell properly. There we go.
      46:39
      This is a React node. And inside here,
      46:41
      what I want to do is I want to figure
      46:42
      out if we're on a mobile screen or not.
      46:44
      Now normally I would use CSS for this
      46:46
      but the way that shad CN actually
      46:48
      implements their sidebar. If we go into
      46:49
      the code for sidebar is they use this is
      46:52
      mobile hook and this is how they
      46:54
      determine is it a mobile page or not a
      46:56
      mobile page. So that's what we want to
      46:58
      hook into. We can say is mobile is
      47:00
      coming from that use is mobile hook and
      47:02
      this will allow us to figure out exactly
      47:04
      what breakpoint shaden hides and shows
      47:06
      the sidebar based on if it's a mobile
      47:08
      page or not. So, if we are in the mobile
      47:11
      view, we want to show that extra
      47:12
      navigation on the top of our page. But
      47:14
      if we're not in a mobile view, just
      47:15
      return our sidebar like normal cuz we
      47:17
      don't need to make any additional
      47:18
      changes to it. So, for now, we can
      47:20
      actually see what this is going to look
      47:21
      like. I'm going to return null here for
      47:22
      now. And we'll come in to our page and
      47:24
      we'll use this app sidebar client. So,
      47:26
      on our page, we essentially want to wrap
      47:27
      our entire sidebar inside of this. So,
      47:30
      we could say app sidebar client just
      47:32
      like that. There we go. and wrap our
      47:34
      entire sidebar, including our content
      47:36
      down here, because we want to make sure
      47:37
      the navigation goes above everything in
      47:39
      our application. And now you can see it
      47:41
      renders nothing if we're on a mobile
      47:42
      screen because we're returning null. But
      47:44
      on a full-size screen, if we make this a
      47:46
      little bit bigger, you should see it's
      47:47
      rendering properly. But it's actually
      47:48
      not rendering properly. There we go. I
      47:50
      gave our page a quick refresh. I'm
      47:51
      guessing it just wasn't properly caching
      47:53
      what was going on. But now you can see
      47:54
      as I change the size of my page, it's
      47:56
      rendering or not rendering that based on
      47:57
      if we're in the mobile view or the
      47:59
      non-mobile view. So the next thing I can
      48:01
      do is instead of returning nothing, I
      48:02
      can return essentially a navbar at the
      48:04
      top of our page. So here I want to
      48:05
      return a div. We're going to put a class
      48:07
      on this. And I think I need to make sure
      48:08
      that this is a tsx file. There we go.
      48:10
      We're going to put a class name on here.
      48:12
      Flex flex column and a full width. So
      48:15
      essentially this is just going to be a
      48:16
      full width container that is going to be
      48:18
      stacked vertically. Then I want to come
      48:21
      in here with a div. This is going to be
      48:22
      a class name of P2 border on the bottom.
      48:25
      This is essentially our nav at the top.
      48:27
      Flex. We're going to put the items in
      48:29
      the center and we're going to have a gap
      48:31
      of one. And essentially, I just want to
      48:32
      add in the same thing that I had inside
      48:34
      my sidebar. So, we go back to our
      48:36
      sidebar and we open up. I essentially
      48:37
      want to add whatever was in my header.
      48:39
      So, I just want to take this content and
      48:40
      I essentially want to put that directly
      48:42
      right here. So, we're going to get our
      48:43
      sidebar trigger and we're going to get
      48:45
      our text for our jobs. And in this case,
      48:46
      we don't need to worry about no wrap
      48:48
      because there's no way it's ever going
      48:49
      to wrap. So, that's going to be our nav
      48:51
      at the top, which you can see is showing
      48:52
      up and we have that button to trigger
      48:53
      our sidebar, but we're not rendering any
      48:55
      of our children, so the sidebar is not
      48:56
      showing up. So to do that, let's create
      48:58
      another div. This is going to be again a
      49:00
      flex of one because we want this to fill
      49:01
      the rest of the space on our screen. We
      49:03
      want it to flex. And then we want to put
      49:05
      our children inside of here. So now if
      49:07
      we give that a quick save, I can now
      49:08
      open and close my sidebar properly on
      49:11
      mobile screens. While if I'm on a larger
      49:12
      screen now, I just had to do a quick
      49:14
      refresh on my page to make sure
      49:15
      everything was working properly. Again,
      49:16
      it just was doing some caching stuff.
      49:18
      But you can see as I'm changing my
      49:19
      screen size, it's properly giving me
      49:20
      that top navigation or the side
      49:22
      navigation, which is exactly what I
      49:23
      want. And I can still open and close my
      49:25
      sidebar exactly as I could before. Now,
    </chapter>
    <chapter title="Clerk setup" start_time="49:27">
      49:27
      in order to really get started with our
      49:29
      application, I want to work on this
      49:30
      button down here, which is going to be
      49:31
      our sign-in button, as well as all of
      49:32
      our user information. And to work with
      49:34
      sign in and sign out, we're going to be
      49:36
      using Clerk for our application. It just
      49:37
      makes authentication really easy. And
      49:39
      it's also going to help us with billing
      49:40
      and organizations and pretty much a
      49:41
      large portion of our application. So,
      49:43
      let's go through the setup steps. It's
      49:44
      relatively straightforward. We need to
      49:46
      make sure we create a next app. Already
      49:47
      got that done. We need to install clerk
      49:49
      into our application. So, let's make
      49:50
      sure we install that. and we're going to
      49:51
      need to add that force flag again
      49:53
      because we're on the Canary version of
      49:54
      Nex.js. Then the next thing that we need
      49:56
      to work on is being able to wrap our
      49:58
      application in this middleware for
      49:59
      clerk. So I'm going to come all the way
      50:01
      over to our application. We're going to
      50:02
      create a brand new file called
      50:03
      middleware.ts. I'm just going to paste
      50:05
      down the code from here. Essentially, it
      50:07
      just runs the clerk middleware to make
      50:08
      sure everything's hooked up properly,
      50:10
      but it doesn't block any of our site
      50:11
      from being accessed. Everything is still
      50:12
      public by default. Next, we need to wrap
      50:15
      our app inside of a clerk provider. And
      50:17
      I'm actually going to create our own
      50:18
      custom clerk provider to hook up a few
      50:20
      additional things such as theming inside
      50:22
      of clerk. And then that's really all we
      50:24
      need to do. So we just wrap our app in
      50:25
      our clerk provider and we're done. So
      50:27
      I'm going to create our own clerk
      50:28
      provider. So inside of a brand new
      50:30
      folder called services, I'm going to
      50:31
      create another folder called clerk
      50:33
      inside of there. And this is where all
      50:34
      of our clerk related code is going to
      50:35
      go. So I'm going to create a components
      50:37
      folder. And inside of here, I'm going to
      50:39
      create a clerk provider. We'll call
      50:41
      this.tsx. And this is where all my clerk
      50:43
      provider related code is going to go. So
      50:45
      we're going to say export function clerk
      50:47
      provider just like that. And we need to
      50:49
      import the original clerk provider. So
      50:51
      clerk provider as clerk provider and
      50:56
      we'll call it original clerk converider.
      50:57
      So original
      50:59
      and we want to get that from
      51:02
      add clerk next.js. There we go. And we
      51:05
      can use that in our app by just saying
      51:06
      return original clerk provider. And we
      51:09
      can wrap it in whatever content we want.
      51:10
      In our case, we specifically have some
      51:12
      children that we're going to pass into
      51:13
      this because, as you can see, the clerk
      51:15
      provider expects some children inside of
      51:16
      it. So, we're going to use those
      51:18
      children. And we'll make this a lot
      51:19
      larger so it's easier to work with.
      51:21
      There we go. And this is going to be a
      51:23
      React node. So, now we can pass along
      51:25
      our children inside of here. And that
      51:27
      gets rid of all of our errors. Now, the
      51:29
      reason I wrapped my own clerk provider
      51:30
      is cuz I want to add some things such as
      51:32
      theming. So, we can come in here with a
      51:33
      simple appearance. And we're going to
      51:34
      have our is dark mode function that
      51:36
      we're going to use to determine if we're
      51:38
      in dark mode or not. If we are in dark
      51:40
      mode, well then I want to pass along a
      51:42
      base theme. And this base theme is going
      51:44
      to be a dark theme which we again need
      51:46
      to import because this is something from
      51:47
      clerk themes. So what we can do inside
      51:49
      of here is npm i and we want to get
      51:52
      clerk themes just like that. Again we
      51:55
      want to make sure this is a force
      51:56
      install. And now what we can do is we
      51:58
      can say that we want to import this from
      52:00
      clerk themes. So import
      52:04
      dark from at clerk next.js. There we go.
      52:07
      And now in the case that we don't have
      52:09
      dark theme, well I just want to pass in
      52:10
      undefined because we want to use the
      52:12
      default light theme that comes with
      52:14
      clerk. So now all we need to do is use
      52:15
      this is dark mode. Also I should fix
      52:17
      this to import from the themes folder.
      52:20
      Just like that. So this is dark mode is
      52:22
      going to be coming from a custom hook
      52:23
      that we're going to create. So is dark
      52:25
      mode equals use is dark mode. There we
      52:28
      go. And let's make sure that this is a
      52:30
      client component.
      52:33
      There we go. And now we can hook up to
      52:34
      this use is dark mode function which
      52:36
      we're going to create inside of this
      52:38
      hooks folder. So we can say use is dark
      52:41
      mode. So let's export a function use is
      52:44
      dark mode. And all this is going to do
      52:47
      is use a simple state variable is dark
      52:50
      mode. Set is dark mode. Set that equal
      52:54
      to use state. Make sure I get that
      52:56
      properly. There we go. Use state. And by
      52:58
      default, I want to set this for if our
      53:00
      type of window
      53:05
      is equal to undefined. Well, then we're
      53:07
      going to set this to false. So,
      53:09
      essentially, in the case that we're
      53:10
      pre-rendering our page, we don't want to
      53:11
      mess with this at all. We're just going
      53:12
      to return false. Otherwise, we're going
      53:14
      to return window.match media, and we're
      53:16
      going to be specifically checking for
      53:18
      the prefers color scheme
      53:22
      dark. There we go. So, if this matches,
      53:25
      then we want to return true or false. So
      53:26
      this is essentially a boolean. If the
      53:28
      user prefers a color scheme of dark,
      53:30
      it'll return true. Otherwise, it'll
      53:31
      return false. Then we can set up a
      53:34
      simple use effect.
      53:36
      We can call window.match
      53:38
      media. We can pass in the exact same
      53:40
      media query right here. And this allows
      53:42
      us to add an event listener for whenever
      53:44
      this changes. So anytime that the user
      53:46
      preference changes between dark and
      53:48
      light, this is going to call a function
      53:50
      for us. So we can pass in a function
      53:52
      that's going to take in that event. And
      53:54
      all we're going to do is say set is dark
      53:56
      mode equal to e.m matches.
      54:00
      There we go. And let me just make sure I
      54:02
      get my parenthesis fixed on this. There
      54:03
      we go. And that is going to hook all
      54:05
      that up for us. So anytime they change
      54:07
      our dark mode between true and false,
      54:08
      this is going to set that variable for
      54:10
      us. We need to make sure we unhook this
      54:11
      event though in the case of rerendering
      54:13
      our page. We're going to use a
      54:14
      controller for that. So we'll say new
      54:16
      abort controller just like that. And
      54:18
      we'll pass along the signal. So
      54:21
      controller signal. There we go. Then
      54:24
      inside of our use effect down here when
      54:26
      we do our return,
      54:29
      we can just call controller.abort. And
      54:32
      what that does is it unhooks our event
      54:33
      listener for us. So this sets up our
      54:35
      event listener and this unhooks our
      54:36
      event listener. And if you're interested
      54:38
      in how this abort controller and
      54:39
      everything works. I actually have a full
      54:41
      video talking about the abort controller
      54:42
      inside of events like this. I'll link it
      54:44
      in the cards and description for you.
      54:45
      But now we have our is dark mode. We can
      54:48
      return that is dark mode. There we go.
      54:50
      Make sure I unimport that thing. And
      54:52
      there we go. Now we have that. We can
      54:53
      import it into this file. And now we can
      54:55
      use it directly inside of here. So
      54:56
      depending if we're in dark mode or light
      54:58
      mode, we're going to be changing the
      54:59
      clerk theme directly related to that.
      55:02
      Now, one additional thing that I need to
      55:03
      do, I'm not sure if it's a bug related
      55:05
      to Nex.js or if it's something related
      55:07
      to the code that I'm writing or if it's
      55:08
      just something related to Clerk and how
      55:10
      the new Canary version of Nex.js is
      55:12
      working, but we're going to need to wrap
      55:13
      this inside of the suspense component
      55:15
      inside of React because otherwise when
      55:17
      we build for production, it's going to
      55:18
      throw an error for us. So, we're just
      55:20
      wrapping essentially our entire
      55:21
      application in a suspense to make sure
      55:23
      everything is going to be working
      55:24
      properly. And again, it's most likely
      55:25
      either something that I have slightly
      55:26
      wrong in my application or it's just a
      55:28
      feature of how the Canary implementation
      55:30
      of Nex.js is currently. Now, the next
      55:32
      thing that I need to do is actually use
      55:34
      this clerk provider. So, inside of our
      55:36
      application, we're going to wrap
      55:37
      everything inside of a clerk provider,
      55:39
      making sure that we get our custom clerk
      55:41
      provider, not the one that comes from
      55:42
      the library. And now you can see our
      55:44
      entire application is wrapped in this.
      55:45
      And we're able to access all the
      55:47
      information for the currently logged in
      55:48
      user and so on. Now, to test that
      55:50
      everything is working properly, let's go
      55:51
      ahead and actually add the ability for
      55:53
      us to sign in, sign up, and so on. To do
      55:55
      that really easily, we can scroll down a
      55:57
      little bit further on Clerk. We have
      55:58
      this create a custom sign in or sign up
      56:00
      page. In our case, we're really focused
      56:02
      on the sign-in page because the nice
      56:03
      thing about Clerk is we have like a
      56:05
      one-step function where you can use
      56:06
      signin or sign up on the same page if
      56:08
      you want. You can disable that if you
      56:09
      want, but we're going to leave it
      56:10
      enabled for ease of use. So, all we need
      56:12
      to do is create a file and put this
      56:13
      particular code inside of it. Rather
      56:15
      straightforward. So, inside of our
      56:16
      application, we need to put this code.
      56:18
      Now I'm going to create a new folder
      56:20
      called clerk just like this for all of
      56:21
      our clerk related code inside of here
      56:23
      because these are kind of independent
      56:24
      routes that are separate from everything
      56:25
      else. They're going to have their own
      56:27
      layout file and so on. So we're going to
      56:28
      create a page.tsx. I'm just going to
      56:30
      paste in that code. This is our signin
      56:33
      page.
      56:35
      There we go. Signin page and it's going
      56:36
      to use that signin component. Now if we
      56:38
      look, we know that this page needs to be
      56:39
      in a sign-in folder inside of this code.
      56:42
      So let's make sure we create a folder
      56:43
      with all of that particular content and
      56:45
      we're going to put our page directly
      56:46
      inside of there. so it's in the correct
      56:47
      location inside of our application. Then
      56:50
      we need to make sure that we make our
      56:51
      sign-in route public if we want to worry
      56:53
      about public routes and so on which I
      56:54
      think is something that we want to do.
      56:56
      So inside of our middleware we can
      56:57
      create a variable called is public
      57:02
      route just like that. And we're going to
      57:04
      create a route matcher. There we go. And
      57:06
      we're going to pass it in essentially an
      57:08
      array of all the different routes that
      57:09
      we want. So in our case we have sign in
      57:11
      which needs to come with a star after it
      57:14
      just like this. make this a little
      57:15
      bigger so it's easier to see. So
      57:17
      essentially we're just matching this
      57:18
      particular code right here. So now our
      57:19
      signin route is publicly available. We
      57:22
      also need to make some other routes
      57:23
      publicly available such as our root home
      57:25
      route is also publicly available. There
      57:28
      we go. Then to be able to test for that
      57:29
      we'll just copy this code directly over
      57:31
      paste it in. Essentially if it's not a
      57:32
      public route we're going to call off
      57:34
      protect. All that does is ensure that
      57:35
      our user is logged in before we do
      57:36
      anything. Otherwise we continue on with
      57:38
      our code. Next we need to specify some
      57:40
      variables inside of our config.
      57:41
      Essentially where is our signin page at?
      57:43
      where's our fallback route and where's
      57:45
      our fallback route for signup. So
      57:46
      essentially this is going to happen if
      57:48
      they finish their or if they try to
      57:50
      directly access the sign in or sign up
      57:52
      route. As soon as they do sign in or
      57:53
      sign up, it's going to redirect them to
      57:54
      these pages. So we're going to copy that
      57:56
      over. We're going to come into our
      57:58
      environment variables and we're going to
      57:59
      make sure we put this inside the clerk
      58:01
      section. Now technically in our
      58:02
      application, we're not going to be
      58:04
      directly referencing these variables,
      58:05
      but we still want to make sure that
      58:06
      they're there. And this is a really nice
      58:07
      thing about using that T3 library for
      58:09
      our environment variables is we can come
      58:11
      into here. We can create a brand new
      58:12
      file for our client.ts and we can make
      58:15
      sure we essentially kind of do the same
      58:17
      thing. But what this is going to do is
      58:18
      it's going to ensure that these
      58:20
      variables that we import are actually
      58:21
      going to be required in our page. So
      58:23
      even though we're not using them in our
      58:25
      application, it's going to require that
      58:26
      they're inside of our env file right
      58:28
      here. So this is going to be for our
      58:30
      client-based environment variables. We
      58:32
      don't need to worry about creating a
      58:33
      final schema and we don't need to worry
      58:34
      about this experimental runtime stuff as
      58:36
      much but we do need to make sure we pass
      58:37
      along what our variables are going to
      58:39
      be. So we have this variable,
      58:41
      this variable and then finally this
      58:44
      variable and all of these are going to
      58:45
      be strings and they are required
      58:47
      strings. Now again you can see that
      58:48
      passing along this runtime envir.
      58:52
      We need to actually hardcode exactly
      58:53
      what the runtime variable looks like. So
      58:55
      essentially we take whatever the key is
      58:57
      and we're going to pass it in what the
      58:58
      value is which is from process.env env
      59:01
      whatever that variable name is. And we
      59:03
      need to do this for each of our
      59:04
      variables. So I'm going to copy this
      59:05
      down two more times and copy over each
      59:08
      of our variables just like this. So
      59:10
      essentially all I'm doing is I'm mapping
      59:12
      whatever the environment variable is. If
      59:14
      I make this a little bigger, it's a
      59:15
      little easier to see. You can see we're
      59:16
      taking our environment variable and
      59:17
      mapping it to this particular name. It's
      59:19
      just something we have to do on the
      59:20
      client side. It's not automatic, which
      59:21
      is a little bit annoying. But now we
      59:22
      have that inside there, which is great.
      59:24
      And now we can actually run our
      59:25
      application and access that login page
      59:27
      if we want. So, inside of our
      59:28
      application, we can go to sign in and we
      59:31
      should see a sign-in page pop up. Now,
      59:33
      of course, we need to run our
      59:34
      application first. So, let's go ahead
      59:35
      and run our application. And now we
      59:37
      should see,
      59:39
      give that a quick refresh. It'll pop up
      59:41
      our sign-in page. It's going to be
      59:42
      really ugly right now because we don't
      59:43
      have anything set up for application.
      59:44
      So, we're going to go ahead and make
      59:45
      sure everything's working properly. So,
      59:47
      the first step is you'll notice it says
      59:48
      clerk is in keyless mode. Essentially,
      59:49
      we don't have any API keys configured
      59:51
      for our application. So, let's do that
      59:52
      first before we work on the styling
      59:54
      portion. We can come into here. We can
      59:55
      go to our dashboard, create an account,
      59:57
      whatever you need to do. And now you can
      59:58
      come in and you can create a brand new
      59:59
      project. You can see I have my job board
      1:00:01
      that I was using for testing. We'll just
      1:00:02
      come in here and we'll call this one job
      1:00:04
      board final. And we can specify exactly
      1:00:07
      how we want the sign-in process to be.
      1:00:09
      For example, we'll enable Google,
      1:00:11
      GitHub, and email. Those are going to be
      1:00:12
      the three ways that we can sign into our
      1:00:14
      application. We'll create this
      1:00:15
      application real quick. And now we can
      1:00:17
      specify, you know what, we're doing
      1:00:18
      Nex.js. Doesn't really matter. This is
      1:00:19
      just the install steps we've already
      1:00:20
      gone through. What we really want to do
      1:00:22
      is we want to configure our application.
      1:00:24
      And we can make this a little bit
      1:00:25
      bigger, a little bit easier to see. You
      1:00:26
      can see we want people to be able to use
      1:00:28
      an email. We require that they have an
      1:00:29
      email. We can make sure that they verify
      1:00:31
      at signup if we want. I'm going to
      1:00:33
      disable this even though it's not
      1:00:34
      recommended. I wouldn't recommend doing
      1:00:35
      this, but for testing purposes, this is
      1:00:37
      going to make it easier so I don't have
      1:00:38
      to log into my email every time I create
      1:00:40
      a brand new account. Now, I'm also going
      1:00:41
      to make sure first name and last name
      1:00:43
      are required because we want to be able
      1:00:45
      to show that with every users whenever
      1:00:46
      they apply for a job. We want to be able
      1:00:48
      to show their first name and last name.
      1:00:49
      So, we're going to give that a quick
      1:00:50
      save. And that right there is going to
      1:00:52
      be pretty much all the stuff that we
      1:00:53
      need to do for our signin. Now, the next
      1:00:54
      thing we can do is we can focus on
      1:00:55
      styling things and getting our
      1:00:57
      environment variable keys. So, let's
      1:00:58
      come and make sure we get our
      1:00:59
      environment variables. If you see, we
      1:01:01
      can click right here where it says API
      1:01:02
      keys, and we can just copy over these
      1:01:04
      API keys, and we can put them directly
      1:01:06
      inside of our environment variable. So,
      1:01:08
      now we have our publishable key and our
      1:01:09
      private key. So, let's make sure we put
      1:01:11
      those inside of our schema. So we have
      1:01:12
      our publishable key Z string. Whoops.
      1:01:17
      String.min of one. And again use that
      1:01:20
      down here.
      1:01:22
      There we go. Now we have that hooked up.
      1:01:24
      And we can do the exact same thing for
      1:01:25
      our server as well. This is our clerk
      1:01:27
      secret key. We can come in here. Clerk
      1:01:29
      secret key. And we essentially just want
      1:01:31
      to make sure that this is a string like
      1:01:32
      that. So now we have all those
      1:01:33
      environment variables set up. Even if we
      1:01:35
      don't use them in our application, we at
      1:01:36
      least have them set up so that it's
      1:01:37
      forcing us to make sure we have those
      1:01:39
      applications. And now if we go back to
      1:01:41
      this page and we give this a little bit
      1:01:42
      of a refresh, we hopefully should see
      1:01:43
      we're no longer in keyless mode, but the
      1:01:45
      rest of our styles still aren't great.
      1:01:47
      So let's get this centered inside of our
      1:01:48
      page. That's going to be really easy for
      1:01:50
      us to do. Inside of our app in this
      1:01:51
      clerk folder, we want to create a brand
      1:01:52
      new file called layout.tsx. This is
      1:01:55
      where all of our clerk related stuff is
      1:01:56
      going to go. Um, we can see here we have
      1:01:58
      this clerk layout. I'm just going to
      1:01:59
      copy it over cuz it's super
      1:02:00
      straightforward what we're doing. We
      1:02:01
      just have a flex container. We're making
      1:02:03
      sure that this is the full height of the
      1:02:04
      screen and the full width of the screen.
      1:02:06
      And we're going to center our items in
      1:02:07
      both directions. and we just wrap our
      1:02:09
      children in a div. So now if I save, you
      1:02:11
      can see that perfectly centered our
      1:02:12
      object for us. Now you notice that
      1:02:13
      there's a problem with our theming of
      1:02:15
      our dark mode. And that's because we're
      1:02:17
      using prefers color scheme dark for if
      1:02:19
      we're in dark mode or not. And by
      1:02:20
      default, the way that shad CN works is
      1:02:22
      it's based on a class for our custom
      1:02:24
      variant. We want to change this custom
      1:02:26
      variant to use the exact same thing,
      1:02:28
      which is a media query. So we'll use
      1:02:29
      media. This is prefers color scheme
      1:02:34
      dark. And this is actually just all
      1:02:35
      Tailwind V4 stuff. So this is the new
      1:02:37
      way of configuring this kind of stuff.
      1:02:39
      We want to put an amperand inside of
      1:02:40
      here and then we say add slot.
      1:02:42
      Essentially all this is saying is put
      1:02:43
      all of our tailwind code directly inside
      1:02:45
      of here if we prefer the color scheme of
      1:02:47
      dark. It's going to use the dark version
      1:02:48
      for all of our different styles. Now you
      1:02:50
      will notice that it still shows us in
      1:02:51
      dark mode and that's because we also
      1:02:53
      need to modify down here. This class of
      1:02:54
      dark needs to be changed to a media
      1:02:56
      query as well. So this is going to be
      1:02:58
      media
      1:03:00
      prefers color scheme dark. And now
      1:03:04
      you'll see that we will immediately go
      1:03:05
      back to a light mode once I get all this
      1:03:07
      set up properly. And that's because this
      1:03:09
      needs to be inside of our root object.
      1:03:11
      There we go. And let me put the extra
      1:03:14
      bracket down here. There we go. And now
      1:03:15
      you can see we've swapped back to light
      1:03:17
      mode because that's what my browser is
      1:03:18
      currently set inside of. Now I just went
      1:03:20
      through and swapped my browser into dark
      1:03:21
      mode. So we can see everything properly
      1:03:23
      swapped over to dark mode. When I
      1:03:24
      refresh it, all still stays in dark
      1:03:25
      mode. And you can see I can now sign in
      1:03:27
      with whatever account that I want. Let's
      1:03:29
      go ahead and say that I want to sign in
      1:03:30
      with GitHub. I can go through here. It's
      1:03:32
      going to load up. It actually signed me
      1:03:34
      in with GitHub automatically because
      1:03:35
      I've already hooked up my account
      1:03:36
      before. And now we can just type in, for
      1:03:37
      example, Kyle Cook. That's going to be
      1:03:39
      what information I want for my name.
      1:03:40
      Continue. And now I'm signed in as that
      1:03:42
      user. You can't actually see it because
      1:03:44
      we don't have anything visually showing
      1:03:45
      it on the page, but I am now signed in
      1:03:47
      as that user. Now, I want to go ahead
    </chapter>
    <chapter title="Auth buttons" start_time="1:03:48">
      1:03:48
      and add the ability to put a link down
      1:03:50
      here that's going to be for signing in a
      1:03:52
      user. And we can also add something like
      1:03:53
      that user drop down that I talked about
      1:03:55
      earlier. So, let's go ahead and work on
      1:03:56
      that. Next, inside of our page where we
      1:03:58
      have our footer, we essentially want to
      1:03:59
      have a lot of the same stuff. We want
      1:04:00
      our sidebar menu. We want our sidebar
      1:04:02
      menu item. We want our sidebar menu
      1:04:04
      button, but we want to make sure that
      1:04:06
      this button actually does what we want
      1:04:07
      it to do. And we want to only show this
      1:04:09
      if we are currently not signed in or
      1:04:11
      signed in. So, what we want to do is we
      1:04:12
      want to make this a link that's going to
      1:04:14
      bring them to the sign-in page if
      1:04:15
      they're not currently signed in, just as
      1:04:17
      a temporary placeholder. And I'm
      1:04:18
      actually going to put that inside of our
      1:04:20
      sidebar content instead. And we're
      1:04:22
      specifically going to put it inside of a
      1:04:23
      sidebar group just to make sure we get
      1:04:25
      all the spacing we want for everything
      1:04:27
      properly. So, now I have a sidebar group
      1:04:28
      with our menu, with a menu item, and it
      1:04:30
      has a menu button. And this button is
      1:04:32
      going to be a link. So we want to make
      1:04:33
      sure we render this as child just so it
      1:04:35
      renders the link component itself. Now
      1:04:37
      this href is going to be pointing to our
      1:04:39
      signin page which is just sign in just
      1:04:41
      like that. And now we want to render the
      1:04:43
      icon that we're going to be using as
      1:04:45
      well as the label that we're going to be
      1:04:46
      using. So for our icon we can just use a
      1:04:49
      simple login icon just like that. And
      1:04:52
      then we can also just have our text
      1:04:54
      which we're going to put inside of a
      1:04:55
      span. That way it doesn't overflow or
      1:04:56
      anything properly. It makes sure when we
      1:04:58
      close our sidebar it works properly.
      1:04:59
      That's just going to say log in. Just
      1:05:01
      like that. Now, if we give that a quick
      1:05:03
      save, we should hopefully see that in
      1:05:04
      our sidebar. If we look, you can see we
      1:05:06
      have this login button that redirects us
      1:05:08
      to the sign on page. Now, we're
      1:05:09
      currently signed in. So, when it
      1:05:10
      redirected us, it automatically
      1:05:11
      redirected us back to the homepage,
      1:05:13
      which makes sense because we can't sign
      1:05:14
      in if we're already signed in. So, I
      1:05:16
      only want to show this button if we are
      1:05:18
      currently signed into the page. So, I'm
      1:05:20
      essentially going to wrap this entire
      1:05:21
      item inside of the signedin component.
      1:05:25
      There we go. This is a component that
      1:05:27
      comes directly from Clerk and it
      1:05:28
      essentially says only render the content
      1:05:30
      inside of here if you are signed in.
      1:05:32
      Now, if we do that real quick and we
      1:05:33
      give this a refresh, you can now see
      1:05:35
      that this is showing up because we're
      1:05:36
      signed in. I want to use the signed out
      1:05:38
      component, though I used the wrong one
      1:05:39
      here. So, now you can see that this has
      1:05:41
      disappeared because we're currently
      1:05:42
      signed out. Now, one interesting thing,
      1:05:44
      since we're using the Canary version of
      1:05:45
      Nex.js, anytime we access dynamic data
      1:05:48
      such as headers, we need to make sure we
      1:05:50
      wrap that inside of a suspense. You can
      1:05:52
      actually see we're going to get an
      1:05:54
      error. If I come into my clerk provider
      1:05:55
      and we just comment out this suspense
      1:05:57
      right here. And now I give that a save
      1:05:59
      and we just refresh our page. You'll
      1:06:01
      notice that trying to render out this
      1:06:02
      content will sometimes throw an error
      1:06:04
      inside of Nex.js. Now it's not show
      1:06:06
      throwing one right now, but sometimes it
      1:06:08
      will throw an error because of the fact
      1:06:09
      that we're accessing dynamic data. So
      1:06:11
      what we need to do is we need to make
      1:06:13
      sure we wrap anytime that we use this
      1:06:15
      inside of a suspense. So we're going to
      1:06:16
      wrap that suspense and we're going to
      1:06:18
      put it entirely around our signed out
      1:06:20
      component. Now, in our particular use
      1:06:22
      case, this is going to be something
      1:06:23
      we're going to do a lot. So, I want to
      1:06:24
      extract this out into its own component.
      1:06:27
      Also, a nice thing about doing this is
      1:06:28
      that now we don't actually have to rely
      1:06:30
      on importing clerk components directly
      1:06:31
      into our application. We can import them
      1:06:33
      into that services folder. So, inside of
      1:06:35
      here, I want to essentially create
      1:06:37
      components for signed in and signed out.
      1:06:38
      So, I'll just call this signin
      1:06:40
      status.tsx.
      1:06:42
      And we essentially want to export those
      1:06:44
      components exactly like we had before.
      1:06:46
      So if we come over to our application, I
      1:06:48
      just want to take essentially all of
      1:06:49
      this and I want to put that inside of a
      1:06:51
      component. So we'll call this a
      1:06:52
      function. We'll call it signed out. We
      1:06:55
      want to take all this sidebar stuff,
      1:06:57
      replace it with children because that's
      1:06:58
      what we're going to be using. And then I
      1:07:00
      just need to make sure I import
      1:07:01
      everything properly. So we're going to
      1:07:02
      import suspense and we're going to
      1:07:04
      import signed out from clerk. And we
      1:07:08
      want to rename that as clerk signed out.
      1:07:10
      There we go. So now we can just wrap our
      1:07:12
      code like this. And this takes children.
      1:07:16
      And right here, children, which is a
      1:07:19
      React node. Make sure I spell that
      1:07:21
      properly. There we go. So now you can
      1:07:22
      see we essentially just took our own
      1:07:25
      version of this signed out, wrapped it
      1:07:26
      in a suspense, and we can do whatever
      1:07:28
      else we want inside of here. We can do
      1:07:29
      the same thing for signed in. So I'm
      1:07:31
      going to come in here, signed in, just
      1:07:33
      like that. We want to make sure we
      1:07:35
      import the exact same thing up here. So
      1:07:38
      this is going to be signed in. There we
      1:07:40
      go. And then down here I want to use the
      1:07:42
      signedin version. Now the reason again
      1:07:44
      that I'm exporting these is not only so
      1:07:46
      I don't have to copy this suspense
      1:07:47
      around everywhere but now let's say I
      1:07:48
      changed from clerk to another off
      1:07:50
      provider or I wrote my own custom author
      1:07:52
      provider. All I need to do is change the
      1:07:53
      signedin component in one place and it's
      1:07:55
      going to work everywhere in my
      1:07:56
      application. So I don't have to rely on
      1:07:58
      this clerk implementation in my
      1:07:59
      application. I can use it inside of my
      1:08:01
      own component and then if I need to swap
      1:08:02
      things out or change things later it's
      1:08:04
      really easy to do that. So now inside of
      1:08:06
      our page, instead of importing directly
      1:08:07
      from clerk, let's import our own custom
      1:08:09
      signed out component that we created and
      1:08:11
      it's going to work exactly the same and
      1:08:12
      we don't need to wrap it in this
      1:08:13
      suspense anymore. So now the next thing
      1:08:15
      that we can focus on is the button down
      1:08:17
      here for our actual dropdown. This is
      1:08:19
      this section down here that currently
      1:08:20
      has no text inside of it. So inside of
      1:08:22
      this, I'm actually going to extract this
      1:08:24
      out into its own component. And I'm
      1:08:26
      going to put this component in a brand
      1:08:27
      new folder. So let's kind of minimize
      1:08:28
      all of our folders down. We're going to
      1:08:30
      create a brand new folder called
      1:08:31
      features. And inside here is where we
      1:08:33
      put all the features for all of our
      1:08:34
      applications for like job listings,
      1:08:36
      users, organizations. In our case, we
      1:08:38
      care about the users. And I specifically
      1:08:40
      want to create a component. So, we're
      1:08:41
      going to put that inside of a components
      1:08:42
      folder. And this feature-based folder
      1:08:44
      structure is something I like to use in
      1:08:46
      lots of different applications. If you
      1:08:47
      want to learn more about it, I'll link
      1:08:48
      it in the cards and description. I have
      1:08:49
      a full video covering it. So, inside of
      1:08:51
      here, I want to create a sidebar user
      1:08:54
      button.tsx. And this is going to be for
      1:08:56
      all the code related to our sidebar. So,
      1:08:58
      let's export that function. sidebar user
      1:09:02
      button. And we're actually going to need
      1:09:03
      to create two functions because we're
      1:09:05
      going to need to have an asynchronous
      1:09:06
      function as well. And anytime in the
      1:09:08
      dynamic IO canary version of XJS that
      1:09:10
      you access dynamic data, you need to
      1:09:11
      wrap it inside of a suspense. So we need
      1:09:13
      to make sure we wrap this inside of a
      1:09:15
      suspense. Just like that. So we have a
      1:09:17
      suspense, which is going to be our
      1:09:19
      sidebar user suspense.
      1:09:22
      There we go. Essentially, I'm just
      1:09:23
      creating that wrapper to put suspense
      1:09:25
      around my component. And then the bulk
      1:09:26
      of my component is going to go inside
      1:09:28
      this new function I just created. So the
      1:09:30
      very first thing we need to do is we
      1:09:31
      need to get our user related
      1:09:33
      information. So we can say user ID is
      1:09:36
      equal to calling the off function
      1:09:37
      directly from clerk. Now we're going to
      1:09:39
      move this off into its own provider so
      1:09:40
      we can get information from our database
      1:09:42
      and so on. But for now we're just going
      1:09:44
      to put in the clerk version of this code
      1:09:46
      right here. And that's working just
      1:09:47
      fine. Now the next thing that we need to
      1:09:49
      work on is actually rendering out our
      1:09:50
      component. And this is something that
      1:09:52
      actually needs to be rendered on the
      1:09:53
      client. So here I'm going to return a
      1:09:55
      sidebar user button client version of
      1:09:59
      that component. I'm going to be passing
      1:10:01
      in our user information. Now currently
      1:10:03
      we only have the user ID again because
      1:10:04
      we haven't hooked this up to our
      1:10:05
      database yet. So we can kind of hardcode
      1:10:07
      some data such as like an email that
      1:10:09
      says kyle@test.com
      1:10:11
      and a name which just says Kyle Cook.
      1:10:15
      For now that's just going to be what our
      1:10:16
      information is going to look like. There
      1:10:18
      we go. We'll close that off. And now we
      1:10:19
      need to create this brand new component.
      1:10:21
      So this component I'm going to put with
      1:10:22
      an underscore in front of the name
      1:10:24
      because again that's what I like to do
      1:10:25
      when I deal with these clientonly
      1:10:26
      components that are only imported in
      1:10:28
      other components. And the only reason
      1:10:29
      they're in a new file is cuz I had to
      1:10:31
      put use client at the top. So the
      1:10:33
      definition for our function is
      1:10:34
      relatively straightforward. We're
      1:10:35
      passing in a user that has a name image
      1:10:37
      and an email. Now we didn't have an
      1:10:38
      image being passed into here for now.
      1:10:41
      For now I'll just put an image URL
      1:10:42
      that's blank. It's just for testing
      1:10:44
      purposes for now but it'll work out well
      1:10:46
      enough. Now we can come into our client.
      1:10:48
      We can import that. And there we go. We
      1:10:49
      give that a save. It should work
      1:10:50
      properly. All we need to do now is
      1:10:52
      implement what this code is going to
      1:10:53
      look like. And we need to figure out if
      1:10:55
      we're on a mobile screen or not. And
      1:10:56
      that's the whole reason we need to make
      1:10:58
      this a client. So we can come in here
      1:10:59
      with use sidebar. That's going to get
      1:11:01
      that. Or we can just say use is mobile.
      1:11:03
      That's probably a better hook for us to
      1:11:04
      use cuz it takes in less overhead. Now
      1:11:06
      to render this out, we're going to come
      1:11:07
      in here and return a sidebar menu. So we
      1:11:09
      can come in here, sidebar menu, just
      1:11:13
      like that. Inside this sidebar menu,
      1:11:15
      we're going to be using a drop-own menu.
      1:11:18
      And we need to make sure that we import
      1:11:19
      that. So, we're going to come in here
      1:11:20
      with shad CN and we're going to add the
      1:11:24
      drop-down menu. And we just need to put
      1:11:26
      a hyphen in here. That'll add that for
      1:11:27
      us. And of course, we'll need to make
      1:11:29
      sure we force install that. And that's
      1:11:30
      going to give us those brand new
      1:11:31
      components. And while we wait for that,
      1:11:33
      we might as well finish out the rest of
      1:11:34
      this. So, we're going to have our
      1:11:35
      drop-down menu trigger. Make sure we
      1:11:38
      import that from the correct location.
      1:11:40
      Same thing here. We have our drop-own
      1:11:41
      menu. This trigger is going to be an as
      1:11:43
      child trigger. Pretty much what we
      1:11:45
      always use. And this is where we're
      1:11:46
      going to create that sidebar button. So,
      1:11:48
      we're going to create our sidebar menu
      1:11:51
      button. And this button is going to be a
      1:11:54
      large button. So, we'll come in here
      1:11:55
      with a size of large. And we'll add a
      1:11:57
      bunch of different class names into
      1:11:58
      this. Essentially, this is going to be
      1:11:59
      what we want it to look like versus open
      1:12:01
      or closed. So, we can come in here with
      1:12:02
      a data state equals open. This is going
      1:12:06
      to be what we want the button to look
      1:12:08
      like in the open state. In our case, we
      1:12:09
      want to add a background that uses the
      1:12:11
      sidebar accent color. Then, we can come
      1:12:13
      in here and do more styling for that
      1:12:15
      open state. So we'll say state open. And
      1:12:18
      in our case here, we want the text to be
      1:12:20
      the sidebar. Whoops. Text sidebar accent
      1:12:24
      foreground. So essentially when we are
      1:12:26
      clicked on this dropdown and it's open,
      1:12:28
      we want to accent what the button looks
      1:12:29
      like. Then we want to specify what all
      1:12:32
      of our user information is going to look
      1:12:33
      like. I'm going to put that in its own
      1:12:34
      component because we're going to use
      1:12:35
      that in a few locations. We'll pass in a
      1:12:38
      user. And we'll create that function
      1:12:40
      down here.
      1:12:42
      User info. Just like that. And that's
      1:12:45
      essentially going to take in this user
      1:12:46
      type. So I might as well extract this
      1:12:48
      out. Just like that. And we can use that
      1:12:52
      here. And then we can use that here.
      1:12:55
      Might as well call it user.
      1:12:58
      There we go. And now for now, we'll just
      1:13:00
      return null just so we get rid of those
      1:13:03
      errors. Lastly, we're going to add in an
      1:13:04
      icon for our chevrons. So we're just
      1:13:06
      going to add this chevron up down icon.
      1:13:08
      The styling is we're just adding margin
      1:13:10
      on the left to make it as far to the
      1:13:11
      right side as possible. And we're also
      1:13:12
      going to be making sure we hide this
      1:13:14
      when our sidebar is collapsed just so it
      1:13:16
      doesn't actually show up. We only want
      1:13:18
      the essentially icon of the user to show
      1:13:19
      up in the collapsed state. Now the next
      1:13:21
      step is going to be our drop-own
      1:13:22
      content. And we can come in here. This
      1:13:24
      is going to be drop-own menu content.
      1:13:27
      Just like that. And for now, I'm just
      1:13:28
      going to leave this blank. We'll come
      1:13:30
      back to this in a second. I'll just put
      1:13:31
      the text hi in there for now cuz I want
      1:13:32
      to work on this user information section
      1:13:34
      next. So inside this user information,
      1:13:36
      we want to create a div. And this div is
      1:13:38
      going to have our avatar. So, we're
      1:13:40
      going to be making sure we get the
      1:13:41
      avatar component from Shad CN. That just
      1:13:44
      makes rendering out user icons much
      1:13:46
      easier. Again, we'll need to make sure
      1:13:47
      we force that and that'll install that
      1:13:49
      for us behind the scenes. So, inside of
      1:13:51
      here, we can render out our avatar
      1:13:52
      component.
      1:13:54
      There we go. We're going to give this a
      1:13:56
      class name of rounded large to make it
      1:13:58
      so it's rounded and a size of eight so
      1:14:00
      we can see exactly what that looks like.
      1:14:02
      Then, the next thing that we want to do
      1:14:03
      is we want to have our avatar image just
      1:14:05
      like that. This one is going to have a
      1:14:07
      source which points to our user image
      1:14:09
      URL. In our case, we might as well just
      1:14:11
      extract this out into the params that we
      1:14:13
      need. There we go. So that way we don't
      1:14:15
      have to prefix everything with user. So
      1:14:17
      we also want to set an alt equal to the
      1:14:19
      name of the user. So that is going to be
      1:14:21
      what our image looks like. We're also
      1:14:23
      going to have a fallback in the case
      1:14:24
      that our image is not loaded yet. So
      1:14:26
      we'll come in here with a fallback.
      1:14:27
      Class name on this is going to be
      1:14:28
      uppercase. It's going to be a background
      1:14:30
      of primary. It's going to be a text of
      1:14:32
      primary foreground. And in order to
      1:14:34
      actually figure out what text we want to
      1:14:36
      put inside of here, we're going to
      1:14:37
      create something called name initials.
      1:14:40
      There we go. And this is just going to
      1:14:41
      be taking the user's name and getting
      1:14:43
      the first couple initials of their name.
      1:14:45
      So we can say const name initials is
      1:14:47
      equal to their name. We want to split it
      1:14:49
      on a string. Then what we're going to do
      1:14:51
      is we're going to slice this and we want
      1:14:53
      to get just the first two elements in
      1:14:55
      the array. That's what this does right
      1:14:56
      here. And then we're going to be mapping
      1:14:58
      those by taking the string and we want
      1:15:00
      to get the first parameter or the first
      1:15:01
      index from the string and then join it
      1:15:03
      back on an empty string. So essentially
      1:15:05
      all this code does is it takes the first
      1:15:07
      letter of each of their names. So first
      1:15:09
      name, last name, and so on, cuts them
      1:15:10
      all off and puts them together. So if
      1:15:12
      the name was Kyle Cook, it would return
      1:15:13
      KC for us. And that's going to be what
      1:15:15
      shows up in this name initials section.
      1:15:17
      And then finally, below our avatar, we
      1:15:19
      want to have all the content for the
      1:15:21
      user. This is going to be a flex in the
      1:15:22
      column direction. We want this to take
      1:15:24
      up as much space as possible. The min
      1:15:26
      width on this is zero. So it will be
      1:15:28
      able to shrink down. I want to put the
      1:15:29
      leading on this to be tight. That way it
      1:15:32
      shrink shrinks down our content a little
      1:15:33
      bit vertically. And then finally if we
      1:15:35
      are in that collapsed state. So if our
      1:15:36
      group data is a state of collapsed
      1:15:43
      I want to make sure that this is hidden
      1:15:44
      because I don't want to show this
      1:15:45
      content. There we go. And then inside of
      1:15:48
      here we essentially just have a couple
      1:15:49
      spans. One's going to be for our name
      1:15:51
      and then below that we're going to have
      1:15:52
      one for our email. There we go. And then
      1:15:55
      we can specify our class names on this.
      1:15:57
      We want to truncate our text in case it
      1:15:59
      overflows. We want to use small text and
      1:16:01
      we'll use a text of semibold.
      1:16:04
      There we go. And then for this one down
      1:16:06
      here, it's going to be very similar. So
      1:16:07
      I'm just going to copy this. For our
      1:16:09
      email, we're going to be using extra
      1:16:10
      small text. And we're not going to have
      1:16:11
      any font semi-bolding on that. So now
      1:16:14
      we'll just make sure our style up here
      1:16:15
      is fine. We're going to flex this items
      1:16:17
      in the center a gap of two. And we're
      1:16:20
      going to hide any overflow that we have,
      1:16:21
      which will make our truncation down here
      1:16:23
      work properly. So that's everything to
      1:16:25
      create that sidebar button. We need to
      1:16:27
      make sure we use this is mobile which
      1:16:29
      will be used in our drop-own content.
      1:16:30
      We'll implement that in just a little
      1:16:31
      bit. I want to make sure what we've
      1:16:32
      created so far is working properly
      1:16:34
      though. So let's go back into our page
      1:16:35
      and inside here we actually already have
      1:16:37
      our sidebar menu. We have our sidebar
      1:16:39
      menu option. So where we have our
      1:16:40
      sidebar menu button, that's where we
      1:16:42
      want to add in our user sidebar and
      1:16:44
      actually I called it sidebar user
      1:16:47
      button. Just like that. So this is where
      1:16:48
      I want to add that sidebar user button.
      1:16:50
      And that'll show up down here at this
      1:16:52
      section right here. And of course, we
      1:16:54
      want to go into that because I actually
      1:16:55
      don't need to have this wrapped in a
      1:16:57
      sidebar menu because I already have it
      1:16:58
      wrapped in a sidebar menu. Now, of
      1:17:00
      course, we need to get our application
      1:17:01
      back up and running. So, let's come in
      1:17:03
      here with an npm rundev. So, we can see
      1:17:05
      our application. Make sure I get rid of
      1:17:07
      that. There we go. Give that a quick
      1:17:08
      save. And now, if we open up our
      1:17:10
      sidebar, you can see down here we have
      1:17:11
      the icon of our user. And if we have no
      1:17:13
      icon, you can see it shows their
      1:17:14
      initials. And in our case, we have no
      1:17:16
      icon cuz we passed in an empty string.
      1:17:17
      We have the name, we have the email, and
      1:17:19
      then we can open this up to see our
      1:17:20
      dropown menu, which right now has no
      1:17:22
      content in it. So, let's go ahead and
      1:17:23
      make our drop-own menu item next. So,
      1:17:25
      we're going to go ahead and we're going
      1:17:26
      to open up that component inside of our
      1:17:27
      drop-own menu content. What I want to do
      1:17:29
      inside of here is I want to add a
      1:17:31
      drop-down menu label. This label is
      1:17:34
      going to have a class name of font
      1:17:36
      normal
      1:17:38
      and P1 just to essentially normalize all
      1:17:40
      of our information inside of here. And
      1:17:42
      inside this label, I just want to render
      1:17:43
      out our user info with all of our user
      1:17:46
      information. That's why I extract this
      1:17:48
      out into its own component. So now if I
      1:17:50
      import this label and we give that a
      1:17:52
      quick save, when I open up my sidebar,
      1:17:54
      you can see it renders out essentially
      1:17:56
      the content for my user inside of here.
      1:17:58
      Now to make sure that this looks a
      1:17:59
      little bit better and fills the full
      1:18:00
      screen and everything else, what I want
      1:18:02
      to do is I want to go inside of my
      1:18:03
      drop-own menu content. I want to change
      1:18:06
      my side offset. This is going to be set
      1:18:08
      to four. I also want to change my
      1:18:10
      alignment. We're going to align it on
      1:18:12
      the end. I want to change the side here.
      1:18:14
      And this is where that is mobile
      1:18:15
      property comes in. So if I'm on the
      1:18:16
      mobile property, I want this to be on
      1:18:18
      the bottom just like it currently is.
      1:18:20
      Otherwise, I want it to be on the right
      1:18:21
      hand side, just like that. And then
      1:18:23
      finally, our class name, min width of
      1:18:25
      64. And we'll specify a max width of 80
      1:18:28
      just to make sure that this looks a
      1:18:29
      little bit better. Now, when I open this
      1:18:30
      up, you see it's on the right hand side.
      1:18:32
      And that's because is mobile is not
      1:18:33
      actually wrapped in brackets. That
      1:18:34
      should hopefully fix that problem. And
      1:18:36
      now you can see it opens on the top if
      1:18:37
      I'm on a mobile view, which is exactly
      1:18:39
      what I want. And now we can add in all
      1:18:40
      of our different buttons inside of our
      1:18:42
      dropdown, which is going to be
      1:18:43
      relatively straightforward. First, I
      1:18:45
      want to add a drop-own menu separator.
      1:18:47
      That's just going to separate the top
      1:18:48
      section from the next section. Then, we
      1:18:51
      can create a drop-own menu item. And
      1:18:53
      this drop-own menu item is going to have
      1:18:55
      an onclick property to open up our user
      1:18:57
      profile. So, we'll come in here with an
      1:18:59
      open user profile.
      1:19:01
      Just like that. We'll create this
      1:19:02
      function in just a little bit. But what
      1:19:04
      I want to do inside of here is I want to
      1:19:05
      render out the user icon. I want to give
      1:19:08
      it a class name, some margin on the
      1:19:09
      right of two, and then we can just say
      1:19:12
      the text profile. Just like that. So now
      1:19:14
      you can see we got that profile icon
      1:19:16
      showing up, which looks really great. We
      1:19:17
      may not even need that spacing. Let's
      1:19:19
      maybe make it a margin on the right of
      1:19:21
      one. And we'll keep it at two. That's
      1:19:23
      fine. No, we'll move it back to one. I
      1:19:24
      think that looks a little bit better.
      1:19:25
      Next, we're going to pretty much copy
      1:19:26
      this down because we're going to create
      1:19:27
      a brand new one for accessing our
      1:19:29
      settings. So this one is going to be as
      1:19:30
      child because it's going to wrap a link
      1:19:32
      component. And this link component is
      1:19:34
      going to go to user slash settings/n
      1:19:36
      notifications.
      1:19:39
      And this should be a dash right here.
      1:19:40
      User settings notifications. And inside
      1:19:43
      of this link, we want to render out a
      1:19:45
      icon which is our settings icon.
      1:19:50
      There we go. And this one is going to
      1:19:51
      say settings.
      1:19:55
      So now you can see we have our settings
      1:19:56
      icon. I'm then going to add another
      1:19:58
      separator to separate us from the logout
      1:20:00
      button, which is going to be the final
      1:20:01
      thing that we have. And I'm going to
      1:20:03
      copy over this code because it's going
      1:20:04
      to be very similar. So we can come in
      1:20:06
      here. We have our dropown menu item.
      1:20:08
      This one is going to be nested inside of
      1:20:10
      a sign out button.
      1:20:14
      There we go. This comes directly from
      1:20:15
      Nex.js. So we're going to nest that
      1:20:17
      directly inside of there. Our dropown
      1:20:19
      menu item. We don't need to worry about
      1:20:20
      this. We don't need a link anymore. I'm
      1:20:22
      just going to use our log out icon. And
      1:20:24
      again, we're going to say the text log
      1:20:26
      out. There we go. Give that a quick
      1:20:27
      save. And you can see that that works
      1:20:29
      just fine. And when I click on this,
      1:20:30
      it's actually going to log me out. Now,
      1:20:32
      right now, we're hard coding what our
      1:20:33
      user information inside of here is,
      1:20:35
      which is why this is still showing up.
      1:20:36
      We'll fix that in a little bit. Let's
      1:20:37
      log back in as our user. We'll use the
      1:20:39
      GitHub user real quick. And there we go.
      1:20:40
      Now, you can see we have our content
      1:20:42
      showing up on the screen. Now, I do want
      1:20:44
      to change this slightly by making this
      1:20:45
      signed out button my own custom signed
      1:20:47
      out button component. So, what we can do
      1:20:49
      inside of our services, inside of our
      1:20:51
      clerk components, we can just say that
      1:20:52
      we want to have some off buttons.tsx.
      1:20:55
      And this is where we're going to create
      1:20:56
      all of our different buttons. I'm going
      1:20:57
      to copy over the code for this because
      1:20:59
      it's relatively straightforward and the
      1:21:00
      same for each individual button. We'll
      1:21:02
      look at the sign out one cuz that's what
      1:21:03
      we're using. Essentially, all we're
      1:21:04
      doing is we're taking the clerk version
      1:21:06
      of the sign out button. As you can see,
      1:21:07
      that button that we've already used.
      1:21:09
      We're just wrapping that inside of our
      1:21:10
      children. And by default, we're setting
      1:21:12
      the children to a button that says sign
      1:21:13
      out. Now, in our case, this doesn't
      1:21:15
      really help us because we're not using a
      1:21:16
      button. But in most of our application,
      1:21:18
      whenever we use the sign-in button, the
      1:21:20
      sign up button, or the actual sign out
      1:21:22
      button, we're going to be just rendering
      1:21:23
      a single button. So, this just makes our
      1:21:25
      code a little bit easier to work with
      1:21:26
      since we don't need to wrap our own
      1:21:27
      custom button. This handles the wrapping
      1:21:29
      of the button for us. Now, in our
      1:21:30
      particular case, it doesn't help us a
      1:21:32
      ton. Let's make sure that we actually
      1:21:34
      use this properly. So, our sign out
      1:21:36
      button, we need to make sure instead of
      1:21:37
      importing it from clerk, we can come in
      1:21:40
      here and we can import it from our
      1:21:41
      custom component. And like I said, it
      1:21:42
      doesn't really help us in this case, but
      1:21:44
      in other cases where we're using our
      1:21:45
      sign out button, it'll help us a ton.
      1:21:46
      Now, the last thing is to get this open
      1:21:48
      user profile function. And this again
      1:21:50
      can come from a clerk. So we can say
      1:21:53
      open user profile equals use clerk. And
      1:21:56
      this is the use clerk hook. And now when
      1:21:58
      I click on this profile button, you can
      1:22:00
      see it opens up my user profile for all
      1:22:01
      my editing that I want to do directly
      1:22:03
      inside of clerk. Now there was one minor
      1:22:04
      bug that you may have noticed,
      1:22:06
      especially on the mobile screen. If we
      1:22:07
      open up our profile again and we try to
      1:22:09
      close it, it closes our sidebar before
      1:22:11
      it actually closes our modal. So what we
      1:22:13
      want to do is we want to make sure that
      1:22:14
      we set up a section here for is mobile
      1:22:18
      and set open. And we're going to get
      1:22:20
      that from use sidebar. So whenever we
      1:22:22
      open up our profile, we also want to set
      1:22:24
      the open to false. So I'm going to come
      1:22:26
      in here. I'm going to open our profile
      1:22:28
      and I'm going to set the open on this to
      1:22:30
      false. So that way we close our modal
      1:22:32
      every single time we open up this new
      1:22:34
      modal. So now you can see if I click on
      1:22:35
      profile, it actually should have closed
      1:22:37
      our sidebar, but it looks like it didn't
      1:22:39
      close our sidebar. I may just need to
      1:22:40
      refresh my page to make sure this takes
      1:22:42
      into account these new changes. So let's
      1:22:43
      go ahead and see if that was the issue.
      1:22:44
      I can open up my profile. And you can
      1:22:46
      see it still didn't look like it closed
      1:22:48
      it. I'm going to try just restarting my
      1:22:49
      server real quick to see if that fixes
      1:22:51
      the potential error because sometimes,
      1:22:52
      especially in the Canary version of
      1:22:53
      Nex.js, you just need to restart things
      1:22:55
      to make things work properly. So, we'll
      1:22:57
      give that a quick refresh. Open this up.
      1:22:59
      We're going to open this up and we're
      1:23:00
      going to say profile here. And we can
      1:23:02
      see that when we click, it's still not
      1:23:04
      closing as we expect it to. Now, the
      1:23:06
      reason for this was entirely my bad. I
      1:23:07
      forgot that inside of Shad CN, they
      1:23:09
      track the open state for mobile and
      1:23:10
      non-mobile separately, which actually is
      1:23:12
      way easier for us cuz we only want to
      1:23:14
      close this on the mobile. So, we can set
      1:23:16
      open on the mobile state to false. Now,
      1:23:18
      this should work. If we click on
      1:23:19
      profile, you can see it closed that for
      1:23:21
      us. And now we can interact with this
      1:23:22
      properly, which is exactly what we want.
      1:23:24
      Now, if we want to stick with the trend
      1:23:25
      of extracting out everything that we're
      1:23:27
      using for clerk, so we don't import
      1:23:28
      clerk anywhere except for in that
      1:23:29
      service folder, we could extract this
      1:23:31
      hook out. But in our particular case, I
      1:23:33
      don't really see a benefit in doing
      1:23:34
      that. So, we'll just leave that in as
      1:23:35
      is. Now, let's get rid of some of these
      1:23:36
      imports that we don't need. And that's
      1:23:38
      going to be essentially our sidebar
      1:23:40
      button done. Other than the fact that
      1:23:41
      when we're logged out, we need to make
      1:23:42
      sure we don't show this. And we also
      1:23:44
      need to make sure we get our user
      1:23:45
      information from our database because
      1:23:47
      right now it's all hard-coded. So the
      1:23:48
      first problem is actually a really easy
      1:23:49
      one to solve. We can go back into our
      1:23:51
      page here and we essentially just want
      1:23:52
      to wrap our entire footer in the
      1:23:55
      signedin component. So we can say signed
      1:23:57
      in just like that. Make sure we wrap the
      1:24:00
      entire footer inside of that. And now
      1:24:01
      this will only show up if we are
      1:24:03
      currently signed in. So let's test that
      1:24:04
      out. We'll click login and we'll log in
      1:24:06
      with GitHub again. And you'll notice
      1:24:08
      immediately if I open this up, you can
      1:24:10
      see that that section is showing up.
      1:24:11
      While when I was logged out, it was not
      1:24:12
      showing up. Now, the next step is going
    </chapter>
    <chapter title="Inngest setup" start_time="1:24:13">
      1:24:14
      to be hooking everything up to our
      1:24:15
      database so that all of our clerk users
      1:24:17
      are inside of our user database in our
      1:24:19
      actual table so we can use it for
      1:24:20
      everything. And that's going to be quite
      1:24:22
      a bit more involved. And the main way
      1:24:24
      we're going to be doing this is going to
      1:24:25
      be using web hooks inside of Clerk. So,
      1:24:27
      if we go into Clerk and we scroll down
      1:24:29
      quite a ways, we'll see this section
      1:24:30
      called web hooks. We can click on this
      1:24:31
      and this is where we can configure all
      1:24:32
      of our web hooks for our application.
      1:24:34
      So, we're going to be adding an endpoint
      1:24:36
      for our application and we have the
      1:24:37
      option to do it with a web hook or in
      1:24:39
      our case, we're actually going to be
      1:24:40
      using ingest for hooking up all of our
      1:24:42
      web hooks. And the nice thing is it's
      1:24:43
      really easy to integrate with Cook
      1:24:44
      because they essentially have a oneb
      1:24:45
      button install process for doing this
      1:24:47
      which is really handy. And inest is
      1:24:49
      really great for running these long
      1:24:50
      running background jobs handling web
      1:24:52
      hooks cuz it's essentially a job queue
      1:24:53
      that does all of our retry logic for
      1:24:55
      you. And in nextJS running background
      1:24:57
      jobs is really difficult. So inest makes
      1:24:59
      that super easy especially when we start
      1:25:00
      dealing with things like AI and email
      1:25:02
      sending that happen on like a chron
      1:25:03
      schedule or in the background you'll see
      1:25:05
      the real power of ingest. So, we could
      1:25:07
      connect to ingest like this by, you
      1:25:09
      know, doing the login and everything,
      1:25:10
      but I'm just going to add my Inest web
      1:25:12
      hook URL manually just so we can make
      1:25:14
      sure we hook up to the correct process.
      1:25:15
      Now, to get started with Inest, we first
      1:25:17
      want to sign up and create an account.
      1:25:19
      So, what we can do on their page, we can
      1:25:20
      just click this assign up button. It'll
      1:25:22
      bring us over to a page to be able to
      1:25:23
      sign in. I already have an organization,
      1:25:25
      but I'm going to create a new one so
      1:25:26
      that we can start from scratch together.
      1:25:27
      So, I'm going to create this, and it's
      1:25:28
      just going to be called WDS test.
      1:25:30
      Doesn't really matter what this
      1:25:31
      organization is. And we can invite some
      1:25:33
      people if we want. I don't want to worry
      1:25:34
      about that. This will just give us a
      1:25:36
      blank place to start with. So you can
      1:25:37
      see all the steps of creating our very
      1:25:39
      own application inside of ingest. Now in
      1:25:41
      our case, we want to be handling web
      1:25:43
      hooks, but this is in our production
      1:25:44
      environment as you can see. So we're
      1:25:46
      actually going to create a custom
      1:25:47
      environment specifically for
      1:25:48
      development. So we're going to create an
      1:25:49
      environment. We're just going to call
      1:25:50
      this dev. We'll create that environment.
      1:25:52
      And now we can swap over to our dev
      1:25:54
      environment. And we can configure the
      1:25:55
      web hook specifically for development.
      1:25:57
      That way we can keep our development and
      1:25:59
      our production environment completely
      1:26:00
      separate from one another. So let's go
      1:26:02
      ahead. We're going to create a web hook.
      1:26:03
      We can just call this clerk. And we
      1:26:04
      don't need to give it any other
      1:26:05
      information. We'll just leave it at
      1:26:06
      clerk. And this is all the information
      1:26:08
      for our web hook. Now, the way that this
      1:26:10
      works inside of ingest is we have this
      1:26:12
      URL at the top. This is the URL that
      1:26:13
      we're going to be using inside of here.
      1:26:15
      So, we can add our ingest URL just like
      1:26:17
      that. We can paste that in, and that's
      1:26:18
      going to work just fine. Also, like I
      1:26:20
      said, we can click this button to
      1:26:21
      connect directly with Clerk if we want
      1:26:23
      to do that as well, and it'll give us a
      1:26:24
      web hook just like that. But again, I
      1:26:26
      want to just make sure that we do this
      1:26:27
      manually so you can see the full process
      1:26:29
      of doing it. The next step is to make
      1:26:30
      sure we subscribe to specific events.
      1:26:32
      For some reason, the events aren't
      1:26:33
      showing up in here, but we'll fix that
      1:26:34
      in a little bit. And then we have some
      1:26:36
      transformation code. Again, not
      1:26:37
      something that we need to worry about.
      1:26:38
      Really, what we want to do is we just
      1:26:40
      want to click create once we paste in
      1:26:41
      that URL that we just created. So, we
      1:26:43
      can give that a quick second to click
      1:26:44
      create. And now we can see that we have
      1:26:46
      that web hook right here. And to be able
      1:26:47
      to set it up for all the subscribed
      1:26:49
      events that we care about, we care about
      1:26:50
      anytime we create, update, or delete an
      1:26:52
      organization. We also care about anytime
      1:26:54
      that organization memberships are
      1:26:56
      created or updated. So, you can see
      1:26:57
      created and deleted. Actually, we don't
      1:26:59
      care about update. And then finally for
      1:27:01
      the user, we want to get all the events
      1:27:02
      from when a user was created, deleted or
      1:27:04
      updated. So those are all the events
      1:27:05
      that we care about listening for. We'll
      1:27:07
      give that a quick save. And now you can
      1:27:08
      see we have all those events as our
      1:27:09
      subscribed events. Now what this
      1:27:11
      essentially is going to do by hooking
      1:27:12
      this up with ingest is anytime we get a
      1:27:14
      web hook for creating a user, updating a
      1:27:16
      user, and so on. It's going to take that
      1:27:18
      data and it's going to send it to ingest
      1:27:19
      and it's going to run this transform
      1:27:21
      function right here to transform the
      1:27:23
      data from the clerk way of doing things
      1:27:25
      to the ingest way of doing things. Let's
      1:27:27
      maximize the amount of space that we
      1:27:28
      have. And you can see down here we
      1:27:30
      essentially have I'll make this full
      1:27:31
      screen. It's a little easier to see. We
      1:27:32
      have our web hook payload right here,
      1:27:34
      which is what's being sent in. And we
      1:27:36
      have our event payload right here. Now,
      1:27:37
      in order to more easily test this, what
      1:27:39
      we can do is we can actually take a
      1:27:40
      sample web hook. This is essentially the
      1:27:42
      user created web hook. That's just a
      1:27:43
      sample from clerk. And we can paste that
      1:27:46
      directly inside of here to see what the
      1:27:47
      output is going to look like on our end.
      1:27:49
      So we can really easily see how we're
      1:27:50
      transforming this data. And generally
      1:27:52
      the recommendation inside of ingest is
      1:27:54
      when you're naming your web hook, you
      1:27:55
      want to prefix the name with whatever
      1:27:57
      the provider is. in our case clerk
      1:27:59
      followed by the slash followed by
      1:28:00
      whatever the actual name of the raw web
      1:28:03
      hook is going to be. So in our case what
      1:28:04
      we can do is we can get clerk as our
      1:28:06
      starting name and then instead of saying
      1:28:08
      web hook received or request received I
      1:28:10
      want to actually make this my event
      1:28:12
      name. So we either want to get the event
      1:28:13
      type the event name or the event.event
      1:28:19
      type or if none of those are actually
      1:28:22
      val valid we'll just change this to web
      1:28:24
      hook received. So essentially what this
      1:28:26
      is doing is it's parsing the clerk web
      1:28:28
      hook in any way possible to make sure it
      1:28:30
      gives us the name property based on what
      1:28:32
      the hook is. And if you can see over
      1:28:33
      here our name is now clerk/
      1:28:35
      user.created. So it's essentially
      1:28:37
      extracting out that event type data from
      1:28:39
      our data payload in here. Somewhere in
      1:28:41
      here that event type is going to be in
      1:28:43
      here. And that's essentially what it's
      1:28:44
      taking and using. You can see right here
      1:28:45
      there's that type property. It's using
      1:28:47
      that for our particular data. Next we
      1:28:49
      have our actual event data that's going
      1:28:51
      to be put inside this data section. So
      1:28:52
      you can see inside data we have all of
      1:28:54
      our different data directly raw from the
      1:28:56
      actual event itself. And in my case I
      1:28:58
      want to actually modify this slightly.
      1:29:00
      So first of all I want to get my data
      1:29:02
      which is going to be in my event.data.
      1:29:04
      That's not going to change anything.
      1:29:05
      That's essentially exactly the same as
      1:29:07
      what we had before. But I also want to
      1:29:08
      pass along some additional information.
      1:29:10
      So first of all if I don't have any
      1:29:11
      event data I'm just going to pass along
      1:29:12
      the event itself because that means that
      1:29:14
      essentially the event is the data
      1:29:15
      itself. It means there's no data
      1:29:17
      property. Again just some extras
      1:29:18
      fallback safety measures. Then I want to
      1:29:21
      take my headers and my raw property
      1:29:22
      which are automatically passed in by the
      1:29:25
      ingest server. And what this will allow
      1:29:27
      me to do is actually validate that I
      1:29:28
      have the correct web hook and it's
      1:29:30
      coming from clerk properly because the
      1:29:31
      way clerk works is they use the headers
      1:29:33
      and this raw field to be able to do some
      1:29:35
      verification on signing just to make
      1:29:36
      sure you have a valid web hook. So
      1:29:38
      that's just for clerk purposes. But
      1:29:40
      essentially all I've done inside of here
      1:29:41
      is I've taken my web hook data and I've
      1:29:43
      passed it along and prefix the name with
      1:29:44
      clerk. That way I can use this inside of
      1:29:46
      my actual server to run these ingest
      1:29:49
      events when they come in. So this is
      1:29:50
      fully creating our web hook. We'll click
      1:29:52
      the create button right here. Actually,
      1:29:53
      we already have an event created, but I
      1:29:55
      want to save this. So we'll save this
      1:29:56
      change right here. And now all these
      1:29:58
      changes are saved for my actual web
      1:29:59
      hook. And if we go ahead and we look at
      1:30:01
      the actual payload, you can see in the
      1:30:02
      payload, we have our data, we have our
      1:30:03
      headers, and we have our raw property.
      1:30:05
      So those are the three things that I
      1:30:06
      care about inside of my actual code.
      1:30:08
      Now, we will be coming back and making
      1:30:09
      changes to this ingest cloud. So
      1:30:11
      instead, I'm just going to keep it off
      1:30:12
      to the side. And I want to look at the
      1:30:13
      actual documentation for getting started
      1:30:15
      with Nex.js. So we can work on getting
      1:30:17
      ingest integrated into our application
      1:30:19
      which will allow us to actually consume
      1:30:20
      those web hooks with proper retry logic
      1:30:22
      and everything else that comes with
      1:30:23
      ingest. Honestly, it's a tool that I was
      1:30:25
      blown away when I was trying it out.
      1:30:26
      It's really really powerful for a lot of
      1:30:27
      different things. So to install ingest,
      1:30:29
      we can just run the npm install command.
      1:30:31
      We'll make this a little bit larger so
      1:30:32
      it's easier to work with. We don't need
      1:30:34
      this open anymore. There we go. So we're
      1:30:36
      going to run that command to install
      1:30:37
      ingest. And then to run the dev server,
      1:30:39
      you can just run inest cl at latest and
      1:30:41
      we're going to call the dev command on
      1:30:42
      that. And that'll start up a dev server
      1:30:44
      for us at localhost8288.
      1:30:46
      Now in our particular case, I'm going to
      1:30:48
      modify this slightly by using this
      1:30:50
      inside of our package json. So let's
      1:30:52
      make sure we add in the force property
      1:30:54
      here.
      1:30:56
      There we go. That'll make sure that that
      1:30:57
      should work properly. And now what we
      1:30:59
      can do is we can come into our package
      1:31:01
      json.
      1:31:02
      And I essentially want to set up a
      1:31:04
      section for ingest just like that. And
      1:31:07
      it's going to call that ingest cli dev.
      1:31:11
      There we go. I just need to make sure I
      1:31:13
      install that as a dependency. So npmi as
      1:31:15
      a dev dependency. Ingest cli at latest.
      1:31:19
      There we go. That's going to install the
      1:31:20
      latest version of this library. Again,
      1:31:23
      make sure we force that. And that should
      1:31:25
      work fine. Now when we run that ingest
      1:31:27
      command, it should open up a terminal
      1:31:29
      for us on localhost 8288. So let's say
      1:31:32
      npm.
      1:31:33
      Let me make sure I actually need to
      1:31:34
      close this. And then I need to reopen
      1:31:37
      that just because I forgot to save it.
      1:31:40
      Paste that in there. There we go. So now
      1:31:42
      let's say npm run ingest.
      1:31:46
      And you can see inest cli is not
      1:31:48
      recognized. That's because I spelled it
      1:31:50
      wrong. It should have two ends instead
      1:31:51
      of one. Now if we run that command, you
      1:31:52
      can see that it's working. And right
      1:31:53
      here I could open that up. And you can
      1:31:55
      now see that I have the dev server of
      1:31:57
      ingest running. And this is how I
      1:31:58
      actually integrate with everything. I
      1:32:00
      can see all the different functions that
      1:32:01
      are being run and so on. Right now it
      1:32:02
      has no detected functions and there's no
      1:32:04
      application being synced right now. So
      1:32:06
      that's something that we need to work on
      1:32:08
      in a little bit, but we'll get there.
      1:32:09
      It's throughout these steps that it's
      1:32:10
      going to be going through for us to work
      1:32:11
      on our code. Now the first thing we can
      1:32:13
      do to help with our application is to
      1:32:14
      specify where our development
      1:32:16
      environment is running. You don't have
      1:32:17
      to do this, but this makes it a little
      1:32:18
      bit easier. So in our case, we're going
      1:32:19
      to be running on localhost
      1:32:22
      3000/api/ingest.
      1:32:24
      That's where we're going to be running
      1:32:25
      our ingest server for all of our code
      1:32:27
      that's coming into our application. So
      1:32:28
      we need to make sure we create
      1:32:30
      subsection for that. So, we'll create a
      1:32:31
      folder called API. And inside of here,
      1:32:33
      we'll create one called ingest. And then
      1:32:35
      we need to create a new file called
      1:32:36
      route.ts. And I'm just kind of jumping
      1:32:39
      ahead a little bit. This is inside the
      1:32:40
      documentation. But before we get to that
      1:32:42
      point, let's create our ingest client.
      1:32:43
      And I'm going to do that in the services
      1:32:44
      folder again. So, we have ingest. And
      1:32:47
      inside here, I want to create my client.
      1:32:49
      And let's make sure that's a TS file.
      1:32:51
      There we go. And I'm pretty much just
      1:32:52
      going to copy this code, paste it in,
      1:32:54
      and we can leave out that section. And
      1:32:56
      what I want to do specifically inside
      1:32:57
      here is call this whatever we want.
      1:32:58
      We'll call it job board. There we go.
      1:33:00
      And let's just put WDS at the end. Now
      1:33:02
      that we have our client created, we can
      1:33:03
      move down to this section, which is
      1:33:04
      where we create our route. And that's
      1:33:06
      the file that I already created up here.
      1:33:07
      So, we can paste in this code. And
      1:33:09
      essentially, all this code is doing if
      1:33:10
      we make sure that we import our actual
      1:33:12
      injust client. There we go. You can see
      1:33:14
      we're importing our client injust to be
      1:33:15
      able to server it on this particular
      1:33:17
      route. And then this is where we put our
      1:33:18
      functions, which we'll get to in just a
      1:33:19
      little bit. That's kind of the meat of
      1:33:21
      how all of works. But now, if we go back
      1:33:23
      to our ingest dev server, and we just
      1:33:25
      let me restart our server. So, we're
      1:33:27
      going to restart this because we changed
      1:33:28
      the configurations for our actual
      1:33:29
      server. You can now see it says the
      1:33:31
      ingest server can't find your
      1:33:32
      application. And that's purely because
      1:33:34
      we don't actually have anything running
      1:33:36
      right now. So, let's run our
      1:33:37
      application. We'll say npm rundev. There
      1:33:40
      we go. And once that's running, we
      1:33:42
      should hopefully see that this is able
      1:33:43
      to sync up properly with our
      1:33:44
      application. It'll just take a second
      1:33:46
      for our dev server to start running
      1:33:47
      inside of Nex.js. But once it does,
      1:33:49
      we'll see here that it'll say we have no
      1:33:50
      functions and that we're properly
      1:33:51
      connected. And then we can go ahead and
      1:33:53
      actually start creating functions. And
      1:33:54
      inside of ingest, functions are
      1:33:56
      essentially just little pieces of code
      1:33:57
      that run as jobs. If they fail, they
      1:33:59
      retry. We can delay them for later. It
      1:34:01
      allows us to create essentially long
      1:34:02
      running jobs in the background, which is
      1:34:04
      really, really great. Now, you are
      1:34:05
      noticing we're getting an error. We're
      1:34:06
      getting a 404 when we're trying to
      1:34:08
      access that page. The reason for that is
      1:34:09
      because inside of our middleware for
      1:34:11
      clerk, we don't have our API set to be
      1:34:13
      public. So, let's make our API public.
      1:34:15
      We'll say / API. And then we want to say
      1:34:18
      that anything that comes after that is
      1:34:19
      going to be a publicly available file.
      1:34:21
      So now hopefully that should properly
      1:34:23
      hook up for our site because it's now
      1:34:25
      publicly available. And as you can see
      1:34:26
      immediately it says error no functions
      1:34:28
      registered within your app. So it's able
      1:34:29
      to find our app. We just don't have any
      1:34:30
      functions yet which is fine because we
      1:34:32
      haven't created any functions in our
      1:34:33
      application. If we look at the
      1:34:34
      documentation essentially that's the
      1:34:36
      next step about writing your functions
      1:34:37
      and defining your functions. And kind of
      1:34:38
      the whole idea behind these functions to
      1:34:40
      break it down for you is the ID is like
      1:34:42
      a unique identifier for your function.
      1:34:43
      Doesn't really matter too much but the
      1:34:44
      important part here is the event. The
      1:34:46
      way that injest works is entirely event
      1:34:48
      based. You can kind of think about like
      1:34:49
      JavaScript on the DOM. you have like a
      1:34:51
      click event listener on a button. It's
      1:34:52
      the same thing with ingest. You create
      1:34:54
      different events that you want to listen
      1:34:55
      for. For example, this hello world
      1:34:57
      listens for the event test/hello world.
      1:34:59
      Anytime that event gets triggered
      1:35:01
      anywhere in your entire application,
      1:35:02
      it's going to run the code inside of
      1:35:04
      here. It's going to have retry logic and
      1:35:05
      everything built in. It's great for
      1:35:06
      longunning tasks, AI, anything like
      1:35:08
      that. Super super useful for those types
      1:35:10
      of tasks. And it's going to make sure
      1:35:11
      it's fault tolerant and everything. So
      1:35:13
      that's all the event based stuff. And
      1:35:14
      the nice thing is if you have multiple
      1:35:16
      different functions that all run on the
      1:35:17
      same event, they'll all work just fine.
      1:35:19
      very similar to JavaScript events. It's
      1:35:21
      more of a pub sub type of system. So,
    </chapter>
    <chapter title="Clerk user webhooks" start_time="1:35:23">
      1:35:23
      let's go ahead and set up our very first
      1:35:24
      event, which is going to be for dealing
      1:35:25
      with these clerk web hooks because we
      1:35:27
      want to handle all the different clerk
      1:35:28
      web hooks. Specifically, in our case, we
      1:35:30
      care most about the user related event
      1:35:32
      web hooks at this time. So, inside of
      1:35:34
      ingest, we can create a new folder for
      1:35:36
      all of our different functions. And then
      1:35:37
      inside of this folder, I want to create
      1:35:39
      a file for clerk. And this is going to
      1:35:40
      be for handling all of our clerk related
      1:35:42
      functions. Now, you can name these
      1:35:43
      functions or put them wherever you want.
      1:35:44
      I just found that this type of
      1:35:46
      organization system worked relatively
      1:35:47
      well for me. Now to create a function,
      1:35:49
      we just set it to a variable. So we can
      1:35:50
      say clerk create user. We'll call that
      1:35:54
      ingest.create
      1:35:55
      function. Let me make sure we import
      1:35:57
      ingest. There we go. We want to create a
      1:35:59
      function. And this create function again
      1:36:01
      is going to take two main parameters.
      1:36:02
      The first parameter is going to be all
      1:36:04
      the configuration for our function. So
      1:36:05
      we need to give it a unique name. We'll
      1:36:07
      call this clerk/create
      1:36:09
      db user. Kind of describes what the
      1:36:11
      thing is doing. We can also give it a
      1:36:13
      more human readable name, which I like
      1:36:14
      to do so it's easy to see in my
      1:36:15
      dashboard. We can call this clerk create
      1:36:18
      db user. So this is the function that is
      1:36:20
      going to create a database user for us.
      1:36:22
      Now the second parameter is for defining
      1:36:24
      what event we want to trigger on. So in
      1:36:26
      our case we want to trigger on the event
      1:36:28
      of clerk/
      1:36:30
      user.created because that's how we set
      1:36:33
      up our web hook. If you remember when we
      1:36:34
      were back inside of here, if I expand
      1:36:36
      this, you can see clerk/ user.created.
      1:36:39
      That's the name of the event that's
      1:36:40
      going to be triggered from our web hook.
      1:36:42
      So that's the name of the event that we
      1:36:43
      want to listen to. So now anytime that
      1:36:45
      that event gets triggered, it's going to
      1:36:47
      run the code directly inside of here.
      1:36:48
      And all we need to do is just take this
      1:36:50
      and pass it along the function we want
      1:36:51
      to run. So we can come in here with an
      1:36:53
      asynchronous function. And there we go.
      1:36:56
      Make sure I turn that into an arrow. And
      1:36:58
      this is going to be all the code that
      1:36:59
      we're going to be running. And this
      1:37:00
      specifically is going to take in all of
      1:37:02
      our event parameters. That again, if we
      1:37:04
      look over here, is all the content over
      1:37:06
      here. That's what our event is going to
      1:37:07
      contain inside of it. And it's also
      1:37:08
      going to take along this step parameter.
      1:37:10
      And the step parameter is kind of
      1:37:12
      interesting. and it's how all the magic
      1:37:13
      of injust works. I'll explain it as we
      1:37:15
      get to the different sections that need
      1:37:16
      it. But one thing you'll notice
      1:37:18
      immediately is that currently I don't
      1:37:19
      have any type safety on my code. And I
      1:37:21
      really love TypeScript. You know that.
      1:37:23
      So I want to add type safety into my
      1:37:25
      code with with ingest is actually really
      1:37:26
      easy. We just need to go back to our
      1:37:28
      client and specify our schema. So to do
      1:37:30
      this, all we need to do is create a
      1:37:31
      type. We'll call this events. Doesn't
      1:37:32
      matter what it is. And it's going to be
      1:37:33
      a type that has keys. For example,
      1:37:35
      clerk/
      1:37:37
      user.created.
      1:37:38
      And then it's going to have an object
      1:37:40
      that is going to return all the
      1:37:41
      different data that I care about. For
      1:37:42
      now, we'll just leave it as an empty
      1:37:43
      object. We'll come back for it in a
      1:37:44
      little bit. Now, to hook that up with
      1:37:46
      ingest here where we have our ID, we can
      1:37:48
      paste in our schemas. And our schemas is
      1:37:50
      going to use a new event schema just
      1:37:53
      like this. We want to call from record
      1:37:55
      and pass it in the type right here.
      1:37:58
      There we go. So now that's actually
      1:37:59
      going to hook up properly with. So now
      1:38:02
      we will have type safety based on
      1:38:03
      whatever we type into this particular
      1:38:05
      section. Now, since all my clerk web
      1:38:07
      hooks are going to be very similar, I'm
      1:38:08
      going to create a type called clerk web
      1:38:10
      hook data, it's going to take in a
      1:38:12
      generic type of t. And this is going to
      1:38:14
      return to me a data object. And this
      1:38:15
      data object has data, which is of type
      1:38:17
      t. It's going to have raw, which is a
      1:38:19
      string. And it's going to have headers,
      1:38:21
      which is a record, which is a string
      1:38:24
      string. And if we look at our code,
      1:38:26
      that's essentially what we're passing
      1:38:27
      into here. Our raw is a string. Headers
      1:38:29
      is again an object that contains
      1:38:31
      headers. And then our data is just
      1:38:33
      whatever this data property is right
      1:38:34
      here. So that's kind of what our clerk
      1:38:36
      web hook looks like and I want to use
      1:38:37
      that everywhere inside of my
      1:38:38
      application. So we'll say clerk web hook
      1:38:40
      data and for this one we're going to use
      1:38:42
      the user JSON type and that comes from
      1:38:44
      clerk because we know that when we
      1:38:45
      create a user they pass along the user
      1:38:47
      JSON type. So that's going to give us
      1:38:49
      all of our type safety information. We
      1:38:51
      can even do the same thing for updated
      1:38:53
      for example.
      1:38:54
      And in our case of deleted we can do the
      1:38:56
      exact same thing but deleted is a little
      1:38:58
      bit different. It's going to use the
      1:38:59
      deleted object JSON again coming
      1:39:01
      directly from clerk. So now let's go
      1:39:03
      ahead and actually implement this web
      1:39:05
      hook. If we go back into here, the nice
      1:39:06
      thing is we have full type safety. If I
      1:39:08
      come in here and try to autocomplete my
      1:39:10
      event, you can see it's giving me all
      1:39:11
      the events that we have defined. Also my
      1:39:13
      event inside my data, you can see that
      1:39:15
      all of my properties are being defined
      1:39:17
      properly inside of here. So the very
      1:39:19
      first thing that we want to do is we
      1:39:20
      want to verify that our web hook is the
      1:39:22
      correct web hook. This is something that
      1:39:23
      directly comes from the clerk library
      1:39:26
      and they have some documentation on what
      1:39:27
      we need to do. But we're going to create
      1:39:29
      a separate function called verify web
      1:39:31
      hook. And this is going to take in our
      1:39:34
      raw data and our headers which we know
      1:39:37
      the types for those. Our raw is a string
      1:39:40
      and headers is a record of strings. Just
      1:39:44
      like that. There we go. And what we want
      1:39:46
      to do is we want to verify that this is
      1:39:47
      the correct information. To do this is
      1:39:49
      actually really easy inside of clerk.
      1:39:51
      They have a simple function you can
      1:39:52
      return new web hook. Just like that. And
      1:39:55
      this actually is going to be need to
      1:39:57
      install a separate library. So, let me
      1:39:58
      get to that. So, this library we need to
      1:39:59
      install, we'll just create a new
      1:40:01
      terminal for this. npm svix
      1:40:04
      and make sure we force that. And this
      1:40:06
      svix library is just the library behind
      1:40:09
      the scenes that Clerk uses for verifying
      1:40:10
      all of its web hook related information.
      1:40:13
      So, we're going to be getting all that
      1:40:14
      information here. We need to pass along
      1:40:16
      an environment variable. We'll get to
      1:40:17
      that in a little bit. And then we can
      1:40:18
      call verify. And verify just takes in
      1:40:21
      our raw data as well as our headers and
      1:40:22
      verifies it's what we expect. So, let's
      1:40:25
      make sure we import web hook. I'll need
      1:40:26
      to do it manually it looks like
      1:40:29
      and that's coming from svix. There we
      1:40:32
      go. And inside of here we just need to
      1:40:33
      pass along our secret key that we get
      1:40:35
      from clerk. So we can say env.clerk
      1:40:38
      web hook secret. There we go. And let's
      1:40:41
      make sure that we import this variable
      1:40:44
      that's going to be from our server. And
      1:40:46
      then we can go ahead and define that. So
      1:40:48
      we can say clerk web hook secret is
      1:40:50
      going to be a string with a minimum
      1:40:52
      value of one. There we go. Now, let's go
      1:40:54
      into our environment variables and
      1:40:55
      define that as well. So, in here, clerk
      1:40:58
      web hook secret. To be able to get that
      1:41:00
      web hook secret, all we do is we go to
      1:41:01
      our clerk dashboard, scroll down, sign
      1:41:03
      in secret right here. We can just expose
      1:41:05
      that, copy that over, and now inside of
      1:41:08
      here, we can paste that down. And we are
      1:41:09
      now able to verify that all of our
      1:41:11
      different web hooks work properly. So,
      1:41:12
      let's go back into ingest and into that
      1:41:15
      specific function. So, the very first
      1:41:16
      thing that I want to do is I want to
      1:41:18
      verify my web hook just like this. Now,
      1:41:20
      to be able to verify this, we just need
      1:41:21
      to pass in our event.data. data that
      1:41:23
      contains our headers and our raw data.
      1:41:25
      And this will throw an error if our web
      1:41:27
      hook doesn't work. Otherwise, if our web
      1:41:28
      hook is valid, it'll just continue on.
      1:41:30
      So essentially, it's a nice little
      1:41:31
      sanity check. But inside of ingest, the
      1:41:34
      best way to handle different steps of
      1:41:36
      your application are by using steps. And
      1:41:38
      the nice thing about steps is that they
      1:41:39
      run in sequence and they're able to be
      1:41:41
      run. So like for example, if this step
      1:41:44
      succeeds and then the next step in my
      1:41:46
      thing fails, the next time that I retry
      1:41:48
      my event, it'll start with the step that
      1:41:50
      failed instead of starting at the very
      1:41:51
      top of my function. So steps allow you
      1:41:53
      to create pieces of your application
      1:41:54
      that if one of them fails, when it
      1:41:56
      retries, it starts from the point where
      1:41:58
      it failed instead of starting at the
      1:41:59
      very beginning. So this is going to be
      1:42:00
      my very first step. And to do a step,
      1:42:02
      all you do is just call step.run. And
      1:42:04
      then you pass it in the name of the
      1:42:06
      step. It doesn't really matter what this
      1:42:07
      is. This is mostly just for your own
      1:42:09
      visual use when you're looking at the
      1:42:10
      dashboard. So, we'll call this verify
      1:42:13
      web hook. We'll make this an
      1:42:14
      asynchronous function. There we go. And
      1:42:17
      we're going to call verify web hook
      1:42:19
      directly inside of here. And we're just
      1:42:20
      going to await this to make sure it
      1:42:22
      finishes running properly. Now, if this
      1:42:23
      throws an error, it'll retry this step
      1:42:25
      over and over again until it reaches the
      1:42:28
      maximum amount of retries, which is
      1:42:29
      really great when you want to retry
      1:42:30
      something if it failed. Now in our
      1:42:32
      particular case, if this verify web hook
      1:42:34
      fails, it means that our application
      1:42:36
      will never succeed because for some
      1:42:38
      reason we have an invalid web hook. So
      1:42:39
      in our case, I'm going to wrap this in a
      1:42:41
      try catch
      1:42:45
      just like this. I'm going to put my
      1:42:47
      verify web hook directly inside of here.
      1:42:49
      And inside my catch, I actually want to
      1:42:50
      throw a special error. And this is going
      1:42:52
      to be a new non retryable error just
      1:42:55
      like this. And we'll say invalid web
      1:42:58
      hook. Now, this non-retable error
      1:43:00
      essentially is a fancy little function
      1:43:02
      inside of ingest that tells you, hey,
      1:43:04
      this failed. It's impossible for it to
      1:43:06
      ever succeed. So, don't bother wasting
      1:43:07
      time retrying this event because it's
      1:43:09
      never going to succeed. So, now we
      1:43:11
      essentially hooked up an event that
      1:43:12
      verifies our web hook is correct. If
      1:43:14
      this step succeeds, we can move on to
      1:43:15
      the next step, which is going to be
      1:43:16
      creating our user in the database. So,
      1:43:18
      let's create a brand new step. We'll
      1:43:20
      call this step.r run. We'll call this
      1:43:22
      create user. And this is going to be an
      1:43:24
      asynchronous function just like this.
      1:43:26
      And inside here is where we're going to
      1:43:27
      do all of our code for creating our
      1:43:28
      user. So first I want to get my user
      1:43:31
      data
      1:43:32
      which is just going to be eventdata
      1:43:34
      data. Then the next thing that I want to
      1:43:36
      do is I want to get my email from that.
      1:43:38
      So we can take our user data email
      1:43:40
      addresses.
      1:43:41
      And what I want to do is I want to find
      1:43:43
      whatever their primary email is. So I
      1:43:45
      can say email ID is equal to the user
      1:43:48
      data.primary email address ID. So if
      1:43:51
      this is correct, we should hopefully
      1:43:53
      find their primary email.
      1:43:55
      Now, if email is null, this is again
      1:43:58
      another error that we cannot come back
      1:44:00
      from because inside of our web hook,
      1:44:01
      they just didn't give us valid
      1:44:03
      information. There's no primary email
      1:44:05
      address that we can use. So, I'm going
      1:44:06
      to do the exact same thing. I'm going to
      1:44:07
      throw a non-retable error that says no
      1:44:09
      primary email address found. Often
      1:44:11
      times, we don't have to worry about
      1:44:13
      throwing these non-retable errors, but
      1:44:14
      in this particular case, it makes sense
      1:44:16
      to do them. Now, the next thing to do is
      1:44:18
      actually insert our user into the
      1:44:19
      database. So, we'll just create a
      1:44:21
      function for that called insert user.
      1:44:23
      And this function will take in all of
      1:44:25
      our different information for our user.
      1:44:26
      We'll come back and create that function
      1:44:28
      in just a little bit, but for now we'll
      1:44:29
      just kind of leave it blank with an
      1:44:30
      empty object. And finally, what we want
      1:44:32
      to do is we want to return our user data
      1:44:35
      ID so that we can use this wherever else
      1:44:37
      in other sections of our application.
      1:44:38
      And up here, we can get that data
      1:44:40
      directly from it. So we can say user ID.
      1:44:43
      There we go. This is really useful for
      1:44:45
      creating different things in our
      1:44:46
      application if we want to use that user
      1:44:47
      ID, which we will. Now, before we get
      1:44:49
      further along though, we should probably
      1:44:50
      create a function for inserting our user
      1:44:52
      into the database. So, inside of our
      1:44:54
      features folder, we have our user
      1:44:55
      section. I'm going to create a new
      1:44:56
      folder called DB for handling all of our
      1:44:58
      database stuff. I'm going to create a
      1:45:00
      file called users.ts for handling all of
      1:45:02
      our user database stuff. Now, inside of
      1:45:04
      here, I want to export an async function
      1:45:08
      insert user. And this is going to be a
      1:45:10
      user. And this is specifically going to
      1:45:12
      come from our user table data. And we
      1:45:14
      want to get the infer select. So
      1:45:16
      essentially what I'm doing or actually I
      1:45:17
      don't want infer select I want infer
      1:45:19
      insert. There we go. So I'm just saying
      1:45:20
      hey whatever my user table accepts as an
      1:45:23
      insert is what this user type is going
      1:45:24
      to be. As you can see it gives me all
      1:45:26
      the information for my user. Then what I
      1:45:28
      can do is I can call await db.insert
      1:45:31
      I can insert into that user table and I
      1:45:33
      can pass along the values that we want
      1:45:34
      to insert which is just these values we
      1:45:36
      passed along up here. Then what I want
      1:45:38
      to do is since a web hook could be sent
      1:45:40
      to our application multiple times. It's
      1:45:42
      very unlikely, but it could be possible
      1:45:44
      that our web hook gets sent multiple
      1:45:45
      times to create a user. If that happens,
      1:45:47
      I just want to make sure that we update
      1:45:49
      the user instead of inserting and
      1:45:50
      throwing an error. So, if we have a
      1:45:52
      conflict when we try to do something,
      1:45:54
      I'm going to do an update instead. So, I
      1:45:56
      say, you know what, if we have a
      1:45:57
      conflict on the user table ID, so
      1:45:59
      essentially if we try to insert a user
      1:46:01
      and we already have a user with that ID,
      1:46:03
      instead I just want to set all my user
      1:46:05
      data to whatever data I pass in. So,
      1:46:07
      really what this allows me to do is to
      1:46:09
      do something called an upsert. it'll do
      1:46:10
      an insert if there's no user or if there
      1:46:12
      is a user, it'll do an update instead.
      1:46:14
      And again, this is just to handle the
      1:46:15
      case where multiple web hooks could be
      1:46:17
      sent to our application for the exact
      1:46:18
      same user. It's unlikely, but it could
      1:46:20
      happen. So, this right here will insert
      1:46:22
      a brand new user into our database for
      1:46:24
      us. So, now let's go back to where we're
      1:46:25
      implementing that and pass in the
      1:46:27
      information we need. As you can see,
      1:46:28
      it's going to load up a bunch of
      1:46:29
      information that we need. First, we need
      1:46:30
      to import the function though, so we can
      1:46:32
      get that autocomplete. So, let's do our
      1:46:33
      ID, which is our user data ID. Next,
      1:46:36
      we're going to have our name. And this
      1:46:37
      is going to be essentially a combination
      1:46:39
      of our first and last name. So, we'll
      1:46:40
      say user data.irstame.
      1:46:42
      And we want to get our user data.last.
      1:46:46
      Whoops. Last name. There we go. Next up,
      1:46:49
      we need to get our image URL, which is
      1:46:50
      just user data image URL. Then, we need
      1:46:54
      to get our email, which we already know
      1:46:55
      is going to be our email, but this is
      1:46:57
      actually a property that has some things
      1:46:58
      on it. So, we want to get the email
      1:46:59
      address specifically from that. Our
      1:47:01
      created at field is going to be a new
      1:47:03
      date using the user data created at. And
      1:47:07
      we want to do the exact same thing with
      1:47:09
      updated at and updated at. There we go.
      1:47:12
      So that's going to get all the
      1:47:14
      information for our user, insert it into
      1:47:15
      our database, and then we're going to
      1:47:16
      return the ID of the user we just
      1:47:17
      created. And if for some reason this
      1:47:19
      particular section fails, ingest will
      1:47:21
      wait a while and then retry to hopefully
      1:47:23
      fix it. For example, if our database is
      1:47:25
      down or offline or something, this will
      1:47:27
      make sure we have that resiliency to
      1:47:29
      still add our user to the database even
      1:47:30
      if for some reason our database is down.
      1:47:32
      Now, before we test this, I do want to
      1:47:33
      do one last step, and that's for
      1:47:35
      creating some user notification settings
      1:47:37
      because by default, when we create a
      1:47:38
      user, we should probably create some
      1:47:39
      default settings for them as well. So,
      1:47:41
      let's come down and create a brand new
      1:47:43
      step. So, we'll say step.run.
      1:47:46
      This is going to be called create
      1:47:48
      user
      1:47:50
      notification settings. Make sure I spell
      1:47:52
      that properly. There we go. And this is
      1:47:54
      going to be pretty similar to what we
      1:47:55
      did up here. I'll kind of copy quite a
      1:47:56
      bit of this code. There we go. And
      1:47:59
      inside of here, I just want to call
      1:48:01
      insert user notification
      1:48:04
      settings. I'm going to pass it along the
      1:48:06
      user ID that I want to create this for.
      1:48:07
      There we go. Notification settings. And
      1:48:09
      let's create a brand new file for that.
      1:48:11
      So, what we're going to do is we're
      1:48:12
      going to go back into our features. We
      1:48:13
      have database. I'm going to copy this
      1:48:14
      over for user notification
      1:48:18
      settings. Make sure I spell that
      1:48:19
      properly. There we go. And now I want to
      1:48:21
      insert my user notification settings.
      1:48:24
      Just like that. This is going to come
      1:48:26
      from my user notification setting table.
      1:48:31
      There we go. Just like that. And this is
      1:48:32
      of course is going to be my settings. So
      1:48:35
      we'll pass that in just like that. And
      1:48:37
      get the correct table for all of this.
      1:48:39
      Now in our case, we're not going to do
      1:48:40
      an update. We're just going to do an on
      1:48:42
      conflict do not update. So we're going
      1:48:44
      to say do nothing. So essentially, if
      1:48:46
      for some reason this web hook gets sent
      1:48:48
      multiple times, instead of overwriting
      1:48:49
      their existing settings, we're just
      1:48:51
      going to completely ignore the settings
      1:48:52
      that are there or we're going to
      1:48:54
      completely ignore the new settings and
      1:48:55
      do absolutely nothing. Now, with that
      1:48:57
      done, that's everything to actually
      1:48:58
      create our user notification settings as
      1:49:00
      well as our user itself. And inside of
      1:49:02
      here, instead of doing the on conflict
      1:49:04
      do update, we can do the exact same
      1:49:05
      thing where we do on conflict do
      1:49:07
      nothing, which is honestly probably the
      1:49:08
      better option cuz we don't want to
      1:49:09
      overwrite their user information with a
      1:49:11
      possible old or expired web hook. So
      1:49:13
      there we go. Let's come into here and
      1:49:15
      import that setting. Just like that. And
      1:49:17
      that's going to give us a default
      1:49:18
      notification setting where everything is
      1:49:20
      set to false essentially by default
      1:49:21
      because those are the default values.
      1:49:22
      And these are the three steps that we've
      1:49:24
      created. So the nice thing is they're
      1:49:25
      going to run one by one after each
      1:49:27
      other. And if one of them fails, instead
      1:49:28
      of retrying everything, it just starts
      1:49:30
      with the one that failed and continues
      1:49:31
      onward, which is a really nice feature.
      1:49:33
      So now before we actually go ahead and
      1:49:34
      implement the rest of our functions,
      1:49:36
      let's make sure that this one is working
      1:49:37
      before we do everything else. So I'm
      1:49:38
      going to take that function name. I'm
      1:49:39
      going to copy it, go into our API, and
      1:49:41
      what I want to do is I just want to add
      1:49:43
      that in as one of our functions. So now
      1:49:44
      you can see here we have that as one of
      1:49:46
      our functions. We can kind of get rid of
      1:49:47
      these comments. We don't really need
      1:49:49
      them. And if we go back into our
      1:49:50
      application and we look at our
      1:49:51
      development environment, we should see
      1:49:53
      here give it a couple sections. And now
      1:49:55
      we have one function being found. Clerk
      1:49:56
      create db user. And if we go into our
      1:49:58
      functions, we have that function. And
      1:49:59
      the nice thing is we can even invoke
      1:50:01
      this by passing along our own custom
      1:50:02
      data. In our case, we don't want to do
      1:50:04
      that though. We want to run this when we
      1:50:05
      create a brand new user inside of our
      1:50:07
      application. Now, I've already created
      1:50:09
      my user to start with. So, I'm going to
      1:50:10
      take my user that's already been
      1:50:11
      created. I'm going to delete them and
      1:50:12
      recreate them. So, we make sure that
      1:50:14
      this web hook runs properly. So, I'm
      1:50:15
      going to completely delete my existing
      1:50:17
      user. They've been deleted. And now I
      1:50:19
      want to come over to my application. I
      1:50:20
      want to log in as a new user. I'm going
      1:50:22
      to create an account using GitHub just
      1:50:24
      like I did before. So, we're going to
      1:50:25
      create that account with GitHub. Going
      1:50:27
      to give it a second to load everything.
      1:50:28
      Pass in my name.
      1:50:31
      Make sure I spell everything properly.
      1:50:33
      Give it a continue. And now that should
      1:50:34
      hopefully fire off a web hook. and we
      1:50:36
      should be able to see that web hook
      1:50:37
      working. Now, before we do that, I do
      1:50:38
      notice that there's two quotes down
      1:50:40
      here. So, let me just search my
      1:50:41
      application for that. I accidentally put
      1:50:43
      two of them side by side somewhere in my
      1:50:45
      code. Looks like right here. Let's just
      1:50:46
      delete that. There we go. That removed
      1:50:48
      that. So, now let's go ahead and
      1:50:49
      actually look to see if a web hook was
      1:50:50
      sent. So, inside of our configure tab,
      1:50:52
      we can scroll all the way down to web
      1:50:53
      hooks again. And we should see if we
      1:50:55
      click on this web hook that we did have
      1:50:57
      our user created and userdeleted events
      1:50:59
      were sent. And they were sent over to
      1:51:01
      ingest. So now if we go to our ingest
      1:51:03
      dev environment and actually instead of
      1:51:04
      going to the dev server, we first need
      1:51:05
      to go to the cloud server here under our
      1:51:07
      dev environment. We'll make this a
      1:51:08
      little bit bigger so it's easier to see.
      1:51:10
      And what we want to do is we want to
      1:51:11
      specifically go to the section for our
      1:51:13
      event types. This is going to show us
      1:51:14
      all the events that have run. As you can
      1:51:16
      see, user created and user deleted. So
      1:51:18
      we have a user created event that ran.
      1:51:20
      You can see that this ran 1 minute ago.
      1:51:21
      And if we click on this event, it'll
      1:51:23
      give us all the different details for
      1:51:25
      that particular event. As you can see
      1:51:26
      here, here's all the details for this
      1:51:28
      particular user. Now, to be able to send
      1:51:30
      this down to our dev environment, all we
      1:51:31
      need to do is click send to dev server,
      1:51:33
      and it'll send it down to that dev
      1:51:34
      server for us, and it'll run in our
      1:51:36
      development environment. This is really
      1:51:37
      great for testing. So, I click send to
      1:51:39
      dev server. And now you can see if we
      1:51:41
      come over here, we have a stream right
      1:51:42
      here. It streamed down that one
      1:51:43
      particular event. And if we go to runs,
      1:51:45
      you can see all the functions that ran
      1:51:47
      associated to that event. So, this event
      1:51:48
      was triggered and it ran this one
      1:51:50
      particular function. And you can see
      1:51:51
      each of the steps as well as all the
      1:51:53
      different data that was returned for
      1:51:54
      each of these different steps. So, it
      1:51:56
      looks like everything was successful.
      1:51:57
      So, we should see that we now have a
      1:51:59
      user inside of our database. And if we
      1:52:01
      go over to Drizzle inside of our studio,
      1:52:03
      which we probably need to hook up. So,
      1:52:04
      let's just come in here. We'll say npm
      1:52:06
      run db studio.
      1:52:10
      There we go. Give that a second to run
      1:52:12
      and we can pull that up. We don't even
      1:52:13
      need this drizzle tab open anymore cuz
      1:52:15
      we're not really using it. Same thing
      1:52:16
      here with this clerk one. Let's open up
      1:52:18
      this and we should hopefully see we have
      1:52:19
      a user and a notification setting. And
      1:52:21
      we do. You can see we have user Kyle
      1:52:22
      Cook and we have notification settings
      1:52:24
      for them where everything is defaulted
      1:52:25
      to false. Now, the next step we can work
      1:52:26
      on is to implement the update and delete
      1:52:28
      versions of these functions so we can
      1:52:30
      get those to work just as well. So, we
      1:52:32
      can come back into our application.
      1:52:33
      We'll minimize everything down. We'll go
      1:52:34
      back into our services for ingest and we
      1:52:37
      want to add essentially a clerk create
      1:52:38
      or clerk update and a clerk delete. I'm
      1:52:40
      going to copy in the code here and
      1:52:42
      explain exactly what's going line by
      1:52:43
      line so we can understand it. You can
      1:52:45
      see here we have clerk update user.
      1:52:46
      That's just the name. We gave it a
      1:52:47
      specific ID and name purely for our
      1:52:49
      internal use. And then we have an event
      1:52:51
      that's going to trigger. You can see
      1:52:52
      clerk user updated is what triggers
      1:52:54
      this. We verify our web hook just like
      1:52:56
      we did before and then we're calling
      1:52:57
      update user. And inside of our verify
      1:52:59
      web hook, we should probably do the same
      1:53:00
      thing here where we wrapped it inside of
      1:53:02
      a try catch. So let's come down here and
      1:53:04
      make sure we wrap all that inside of a
      1:53:05
      try catch to throw that non-retable
      1:53:07
      error. Same thing down here. Do the
      1:53:09
      exact same thing. Now inside of this
      1:53:10
      update user, it's essentially the same
      1:53:12
      thing. We get our user data, get their
      1:53:13
      email. If the email is null, then hey,
      1:53:15
      we have some type of error occurring
      1:53:17
      with our user. So we throw that error
      1:53:18
      and then we just update our user. We
      1:53:20
      update their name, we update their
      1:53:21
      image, we update their email, and we
      1:53:22
      update that updated ad field. We'll
      1:53:24
      create this function in just a second
      1:53:25
      here. Now, when we go to delete it, it's
      1:53:27
      a little bit different because the data
      1:53:28
      that's actually returned to us is this
      1:53:30
      deleted object JSON data, which has an
      1:53:32
      ID that's returned to us, either an ID
      1:53:34
      or null. If for some reason it returns
      1:53:36
      to us null, then we essentially want to
      1:53:37
      say no ID found, and we'll throw a
      1:53:39
      non-retriable error because it gave us
      1:53:41
      bad data. Otherwise, we'll delete the
      1:53:42
      user associated with that ID. So, again,
      1:53:44
      very similar step-by-step process.
      1:53:46
      Verify the web hook, do something in
      1:53:48
      particular. Same thing here. Verify the
      1:53:49
      web hook, then do something in
      1:53:50
      particular. Now let's go ahead and write
      1:53:51
      the code for updating and deleting our
      1:53:53
      user. So we can go into that user DB
      1:53:55
      function. I'm just going to copy this
      1:53:56
      over. We're going to say that this is
      1:53:58
      going to be called update user. This is
      1:54:00
      going to take an partial version of
      1:54:01
      this. So we'll say type of partial
      1:54:05
      because we can always update less than
      1:54:06
      the full insertion. So we're going to
      1:54:08
      get a partial user that we want to
      1:54:09
      update. We want to call update and we
      1:54:11
      want to set these particular values. We
      1:54:13
      don't have to worry about on conflict or
      1:54:14
      anything like that. And we just want to
      1:54:15
      make sure that we only update the user
      1:54:17
      for a particular ID. So we're going to
      1:54:18
      take in an ID which is a string and then
      1:54:21
      we're going to get all of our user
      1:54:22
      information which is a partial user. And
      1:54:24
      what we want to do is we want to say
      1:54:26
      where equal user table
      1:54:30
      ID is equal to that ID. Let's make sure
      1:54:33
      we import that equal function just like
      1:54:34
      that. And there we go. Now we're
      1:54:36
      updating the user with that particular
      1:54:37
      ID based on the ID that we passed in.
      1:54:39
      Finally, we can do a delete. I'll just
      1:54:41
      copy this down. delete is going to take
      1:54:42
      in just an ID and it's going to delete
      1:54:45
      from the user table where this is an ID
      1:54:48
      that is equal to that ID. So very
      1:54:50
      similar to update but instead of
      1:54:51
      updating we're doing a simple delete. So
      1:54:52
      now let's go ahead and import those
      1:54:54
      functions here. So we have delete user,
      1:54:55
      import that and update user will import
      1:54:58
      that. So now we have all of these
      1:55:00
      different functions working. Let's just
      1:55:01
      make sure we hook them up by coming into
      1:55:03
      our app API with our routes and we'll
      1:55:05
      add in our update and our clerk deleted
      1:55:08
      user. Just like that. And let's make
      1:55:10
      sure that we import this.
      1:55:12
      There we go. So now if we look at our
      1:55:14
      dev server, we should hopefully see that
      1:55:17
      we have functions that are defined for
      1:55:18
      all those. It might take a little bit of
      1:55:19
      a second for it to refresh, but as you
      1:55:21
      can see, we have our create, our delete,
      1:55:22
      and our update database user. We can
      1:55:24
      invoke them all if we want, and we can
      1:55:25
      also hook them up with our actual dev
      1:55:27
      environment that was running right here
      1:55:29
      to make sure everything is running just
    </chapter>
    <chapter title="Finish auth buttons" start_time="1:55:30">
      1:55:30
      like we want it to. Now, the reason we
      1:55:31
      did all of that code to get our user in
      1:55:33
      our database is so that we can more
      1:55:35
      easily implement the code inside of our
      1:55:37
      feature button here. So if we go to our
      1:55:38
      users sidebar user now instead of hard
      1:55:41
      coding this data we can actually get
      1:55:43
      this data from our user and we're going
      1:55:44
      to create a custom function for that
      1:55:46
      called get current user and that's going
      1:55:49
      to return to us our user information.
      1:55:51
      Now for this function we're going to
      1:55:52
      specifically put this inside of our
      1:55:54
      clerk provider here and we're going to
      1:55:55
      create a new folder which is going to be
      1:55:56
      called lib and inside this lib folder
      1:55:59
      we're going to create a get current
      1:56:01
      off.ts and this is where we're going to
      1:56:02
      have our function for getting the
      1:56:03
      current user as well as the current
      1:56:05
      organization. So let's export an async
      1:56:07
      function called get current user. And
      1:56:10
      this is also going to take a property
      1:56:12
      called all data which by default will be
      1:56:14
      set to false. And this is for example
      1:56:16
      sometimes all we care about is getting
      1:56:17
      the user ID while other times you want
      1:56:19
      to get information like the name and the
      1:56:21
      email. So this allows us to only access
      1:56:22
      the database in the case that we need
      1:56:24
      this extra data. So we're first going to
      1:56:26
      get our user ID from clerk. That's by
      1:56:29
      calling await off just like that. That's
      1:56:32
      going to give us the user ID of the
      1:56:33
      currently logged in user. then we can
      1:56:35
      return an object that has the user ID as
      1:56:37
      well as our user information. So with
      1:56:39
      all data, we want to make sure we have
      1:56:41
      all data and a user ID is not equal to
      1:56:43
      null. So if we have all of our data or
      1:56:46
      we want to get all of our data and the
      1:56:48
      user ID is not equal to null, then I'm
      1:56:49
      going to call a function called get user
      1:56:52
      and pass in our user ID. Otherwise,
      1:56:54
      we'll just return undefined. So we'll
      1:56:56
      create a function called get user just
      1:56:58
      like that.
      1:57:00
      And this will return all of our user
      1:57:02
      information. We can get that from our
      1:57:03
      database. So we can say return db and we
      1:57:06
      want to do a simple query on our user
      1:57:09
      table. Actually I could just say query
      1:57:12
      do user table just like that and we want
      1:57:14
      to find the first user where and we want
      1:57:17
      to get specifically for a user ID. There
      1:57:20
      we go. So we could say user table ID is
      1:57:24
      equal to the ID we pass in. This is
      1:57:26
      going to give us that particular user
      1:57:27
      information. So if we want to get all
      1:57:29
      the data we return true here. We can
      1:57:30
      pass it true. If not, this will just
      1:57:32
      return undefined and we don't access the
      1:57:34
      database if we don't need it. Now, in
      1:57:35
      our particular case right here, we do
      1:57:37
      want to get all the data. So, we'll say
      1:57:38
      all data true. And this is going to give
      1:57:40
      us a user property which contains all of
      1:57:42
      the information we want about our user,
      1:57:44
      which is really useful because we can
      1:57:45
      pass that along right here. There we go.
      1:57:47
      We can pass it in our user. You'll
      1:57:49
      notice that we have a slight difference.
      1:57:50
      The type undefined is not a definable
      1:57:52
      here. That's essentially accounting for
      1:57:53
      the fact that user could be undefined
      1:57:55
      because let's say that we sign up for an
      1:57:57
      account, but our web hook hasn't
      1:57:58
      registered the user in our database yet.
      1:58:00
      Well, user for our database will be null
      1:58:02
      while the user ID will be valid. So, we
      1:58:04
      want to make sure we take that into
      1:58:05
      account. It's a very small window of
      1:58:07
      time, most likely less than a couple
      1:58:08
      hundred milliseconds that they'll have
      1:58:10
      to wait, but it is something that could
      1:58:12
      happen. So, we're going to come in here
      1:58:13
      with an if user equals null to make sure
      1:58:16
      we take into account what should happen
      1:58:17
      here by returning something else. So,
      1:58:19
      for our particular case, I'm just going
      1:58:21
      to copy the code over because it's
      1:58:22
      relatively straightforward. I'll import
      1:58:24
      the different things that we're using
      1:58:25
      and I'll explain exactly what's going on
      1:58:27
      inside of here. But essentially in the
      1:58:29
      case that we have these things happening
      1:58:31
      where we have a user that's not in our
      1:58:32
      database but they are in clerk well we
      1:58:34
      can't show the full information for the
      1:58:36
      user because we don't know that yet. So
      1:58:37
      instead what I'm going to do is I'm just
      1:58:38
      going to be returning a simple log out
      1:58:40
      button for now. And then once the user
      1:58:42
      gets populated in the database then
      1:58:44
      it'll show them the full user
      1:58:45
      information. So now if we go over to our
      1:58:47
      application and we just give this a
      1:58:49
      quick refresh, you can see all the
      1:58:51
      information has been updated based on my
      1:58:53
      image URL from GitHub, my email address,
      1:58:55
      my name, all that stuff has been
      1:58:56
      properly updated to the real actual
      1:58:58
      data. And if I come into here and I
      1:59:00
      actually update my profile, for example,
      1:59:01
      let's say that I change my last name to
      1:59:03
      add some extra data to the end of it. I
      1:59:05
      click save. That is going to update my
      1:59:06
      information. And once the web hook runs
      1:59:08
      and I refresh my page, you'll notice it
      1:59:10
      doesn't actually quite show my data yet.
      1:59:11
      And the reason for that is is because
      1:59:12
      the web hook ran, but we never sent it
      1:59:14
      from the cloud down to our dev
      1:59:16
      environment. So if we go back over to
      1:59:17
      our event types, you can see here,
      1:59:19
      here's the user created event or updated
      1:59:21
      event, I'm sorry. If I click on this and
      1:59:23
      I actually send it down to my dev
      1:59:24
      server, that will then trigger the
      1:59:26
      update. So that's something you need to
      1:59:27
      keep in mind when you're working with
      1:59:28
      ingest is just to make sure you send
      1:59:29
      your web hooks down to your dev server.
      1:59:31
      So now we give this a refresh, you can
      1:59:32
      see it properly updated my name. Now to
      1:59:34
      show you what this fallback state looks
      1:59:35
      like, I'm going to go through I'm going
      1:59:36
      to log out and I'm going to create a
      1:59:37
      brand new user. So, I'm just going to
      1:59:39
      sign in with some bogus email address.
      1:59:41
      Actually, I probably should make it
      1:59:42
      something I can actually remember. We'll
      1:59:43
      do test.com and we'll enter in some
      1:59:45
      bogus information here. We'll enter in a
      1:59:48
      bogus password. And then we'll go ahead,
      1:59:50
      we'll create that. And since we of
      1:59:52
      course, I can't just use password as my
      1:59:54
      password. We have to make it something a
      1:59:56
      little bit more secure. There we go. And
      1:59:57
      now you can see it's just giving us that
      1:59:58
      logout button because we haven't
      2:00:00
      actually received the web hook yet. As
      2:00:02
      soon as I send down the web hook from
      2:00:03
      here, so I go back over to my event
      2:00:05
      types event for the user created. give
      2:00:07
      this a refresh so it gets the brand new
      2:00:08
      event showing up inside of our page.
      2:00:10
      There we go. We can click on that event
      2:00:12
      and then we can send that down to our
      2:00:13
      dev server and that'll actually give us
      2:00:15
      the actual information. So you can see
      2:00:16
      here it shows the log out button before
      2:00:18
      we receive that web hook and then as
      2:00:20
      soon as we get the web hook you can now
      2:00:21
      see it shows me all of my user
      2:00:22
      information. Now before we get too much
    </chapter>
    <chapter title="Caching system" start_time="2:00:23">
      2:00:24
      further I do want to do one little bit
      2:00:25
      of housekeeping and that's going to be
      2:00:27
      dealing with the caching system inside
      2:00:28
      of our application. Right now we're not
      2:00:30
      dealing with caching anything. If you
      2:00:32
      can see here, I'm not caching this
      2:00:33
      particular function return. But
      2:00:35
      generally in Nex.js, it's a good idea to
      2:00:37
      do caching, especially for this dynamic
      2:00:38
      data. So to cache things using the new
      2:00:41
      dynamic IO way of doing things. We can
      2:00:43
      come in here and just say use cache just
      2:00:45
      like this. And to enable this since
      2:00:46
      we're in an experimental version of our
      2:00:48
      code, we need to go directly down into
      2:00:50
      our next config and we need to enable
      2:00:52
      this as an experimental feature. So we
      2:00:54
      can come in here, we can say we want to
      2:00:56
      do dynamic IO and we'll set that to
      2:00:58
      true. And that allows us to do that. and
      2:01:00
      we'll just need to restart our dev
      2:01:01
      server to make sure that this takes into
      2:01:02
      account. So, we'll just give that a
      2:01:04
      quick refresh real quick. And now we
      2:01:05
      should hopefully see that that'll take
      2:01:06
      into account these new changes. And if
      2:01:08
      we refresh our page, we should see
      2:01:10
      everything over here is working
      2:01:11
      properly. And it looks like it is. Now,
      2:01:12
      we need to make sure we invalidate our
      2:01:14
      cache at the proper times because right
      2:01:16
      now, if we go over to this particular
      2:01:17
      file that had that inside of it, which
      2:01:19
      was right here, you can see we're
      2:01:20
      caching it, but we're not specifying
      2:01:22
      what type of cache it is, how long it
      2:01:24
      lives for, any tags that are associated
      2:01:25
      with that cache. So, I like to create a
      2:01:27
      system in place that handles all of my
      2:01:29
      caching for me in a really easy and
      2:01:30
      seamless way. So, to do that, in this
      2:01:32
      lib folder, we're going to create a
      2:01:33
      brand new file called data cache.ts. And
      2:01:36
      this is where all of our caching logic
      2:01:37
      is going to go. We're going to have a
      2:01:39
      type for all of our different cache
      2:01:41
      tags. We'll say cache tag, just like
      2:01:43
      that. Make sure I spell that properly.
      2:01:45
      And this cache tag is going to be
      2:01:46
      something as simple as like users if we
      2:01:48
      want to cache the user information or
      2:01:50
      organizations for caching our
      2:01:51
      organization information. I'll copy over
      2:01:53
      all the different tags we're going to be
      2:01:54
      using just like this. So we have users,
      2:01:56
      organizations, job listings,
      2:01:57
      notification settings, resumes,
      2:01:59
      applications, and user settings for
      2:02:01
      organizations. Essentially, we're just
      2:02:02
      taking this stuff directly from our
      2:02:04
      database and mapping it one to one to a
      2:02:05
      caching tag. Then we're going to export
      2:02:08
      a function for getting all the different
      2:02:10
      tag types that we create. So one type of
      2:02:12
      tag that we're going to use very often
      2:02:13
      is the global tag. And this takes in one
      2:02:16
      of our cache tags just like this. And
      2:02:18
      it's just going to return to us a
      2:02:19
      string. We'll call it global tag. And
      2:02:22
      we'll return that as a constant
      2:02:24
      variable. So when we hover over this,
      2:02:25
      you can see these are our different
      2:02:26
      return types based on our cache tags.
      2:02:28
      The whole idea behind this global tag is
      2:02:31
      anytime that we're accessing data, for
      2:02:33
      example, I want to get all of the job
      2:02:34
      listings on my entire site. That is
      2:02:37
      global data. Anytime I update any job
      2:02:39
      listing, anytime I add any job listing,
      2:02:41
      anytime I delete any job listing, I want
      2:02:43
      to refresh that cache. This is a very
      2:02:46
      common type of caching where you want to
      2:02:47
      access all the information and anytime
      2:02:49
      any of it changes, you want to refresh.
      2:02:51
      Another really common type of
      2:02:52
      application caching would be if you want
      2:02:54
      to cache based on an ID specifically. So
      2:02:56
      this is going to take in a tag and it's
      2:02:58
      going to take in an ID which is a string
      2:03:01
      and we can pass that in just like this.
      2:03:03
      We'll say ID
      2:03:05
      id dash tag just like that. So in this
      2:03:08
      particular case where we have an ID tag
      2:03:10
      what this is really useful for our user.
      2:03:12
      For example, we have a specific ID for
      2:03:14
      our user. So I'm saying I want to
      2:03:16
      refresh the cache of this user anytime
      2:03:18
      the user with this specific ID changes.
      2:03:20
      If we add another user, I don't want to
      2:03:22
      refresh this cache. But as soon as this
      2:03:24
      user is deleted or updated in any way, I
      2:03:26
      want to refresh the cache for this
      2:03:28
      particular ID. So that is where this ID
      2:03:30
      style caching comes in. And there's
      2:03:32
      other types of caching that we may use.
      2:03:34
      For example, if we want to cache
      2:03:35
      something on the organization level or
      2:03:36
      the job listing level, but we'll get to
      2:03:38
      those when we need them because right
      2:03:39
      now these are kind of the main ones we
      2:03:41
      care about. And to make my caching
      2:03:43
      system even more robust, what I like to
      2:03:45
      do is inside of each one of my features
      2:03:46
      for my application, I like to create a
      2:03:48
      specific section in my database for a
      2:03:50
      cache. So we'll come in here with cache
      2:03:52
      and we want to create a cache for our
      2:03:53
      users.ts. And this is going to return to
      2:03:55
      me all the functions for creating
      2:03:57
      different cache entities for this. So
      2:03:58
      for example, I can create a user global
      2:04:01
      tag cache and that's just going to
      2:04:04
      return get global tag and it's going to
      2:04:06
      be for users just like that. And I can
      2:04:08
      do the exact same thing to create an ID
      2:04:10
      version. So I can say get user ID tag.
      2:04:14
      And this is going to be getting an ID
      2:04:15
      tag.
      2:04:17
      There we go. Which is going to be my
      2:04:19
      user as well as my ID.
      2:04:21
      So if we pass in an ID for a user, it's
      2:04:23
      going to give me the proper tag for
      2:04:24
      that. And the thing that pulls
      2:04:26
      everything together is this function
      2:04:27
      called revalidate
      2:04:30
      user cache. And it's going to take in
      2:04:31
      all the data it needs to revalidate. In
      2:04:33
      our case, just an ID. And it's going to
      2:04:35
      call essentially revalidate tag, which
      2:04:37
      is built into Nex.js. When you call
      2:04:38
      this, it revalidates all caches that are
      2:04:40
      tagged with a specific tag. And we're
      2:04:42
      going to pass it in our user global tag.
      2:04:45
      And we're going to pass it in our user
      2:04:48
      ID tag with our ID as well. There we go.
      2:04:52
      So now, anytime that we change our data
      2:04:54
      for a user, update a user, delete a
      2:04:56
      user, we're going to call this function,
      2:04:58
      and it's going to update all the caches
      2:04:59
      associated with our user, whether it's a
      2:05:01
      specific user cache or a global user
      2:05:04
      cache. So let's show you this in action.
      2:05:05
      I'm going to use this get user ID inside
      2:05:07
      of here. So I can come in here. I can
      2:05:09
      add a cache tag which is a function
      2:05:11
      built in XJS to say hey this function is
      2:05:13
      cached with this tag and I want to get
      2:05:15
      my user ID tag. I want to pass it in the
      2:05:18
      ID. So I'm saying get the tag for this
      2:05:20
      specific user. Then whenever I update
      2:05:22
      that user, it's going to refresh this
      2:05:24
      particular cache. Now to make sure I
      2:05:26
      refresh my user properly, anytime I
      2:05:28
      change data in my database, I want to
      2:05:30
      call revalidate user cache and pass in
      2:05:33
      my user's ID property. Same thing here.
      2:05:35
      Do the exact same thing. Pass in the ID
      2:05:37
      that I'm going to be revalidating. And
      2:05:39
      same thing in here. Pass in the user ID
      2:05:42
      for what I'm revalidating. Now, anytime
      2:05:44
      I delete, update, or add a user, it's
      2:05:46
      going to revalidate all the caches
      2:05:47
      associated with that user, as well as
      2:05:49
      the global user cache and any other
      2:05:51
      caches that I put inside of this
      2:05:53
      particular function. And the really
      2:05:54
      great thing about doing it this way is
      2:05:56
      when we go back into our get off
      2:05:57
      function, let's just find that function
      2:05:59
      real quick inside of clerk. There we go.
      2:06:01
      Whenever I try to access my user
      2:06:03
      information, the first time I access it,
      2:06:05
      there's no cache. So, it's going to have
      2:06:06
      to get the data. But then, as long as my
      2:06:08
      user ID doesn't change or my user data,
      2:06:11
      I'm sorry, doesn't change, it'll always
      2:06:12
      get the cache version, which means it
      2:06:14
      returns the data to me pretty much
      2:06:15
      instantly, which is exactly what I want
      2:06:17
      for an application like this. And to
      2:06:18
      make sure that everything is working
      2:06:20
      just fine, let's go ahead and look at
      2:06:21
      our application. You can see it's
      2:06:22
      returning my user. Let's log out and log
      2:06:24
      in as a different user to make sure it
      2:06:26
      pulls that new data when I log in with a
      2:06:27
      new user ID. And you can see that it's
      2:06:30
      pulling in that correct new information.
      2:06:31
      And now let's go ahead and we'll update
      2:06:33
      our profile. We're going to come in
      2:06:34
      here. I'll reset my last name to what it
      2:06:36
      actually should be. We'll close out of
      2:06:38
      that. And then I'll make sure that I
      2:06:39
      send that down to us. So we'll go into
      2:06:41
      our cloud here. Go back to the different
      2:06:43
      event types. Find the one for updating
      2:06:45
      our user. Make sure that we get the most
      2:06:47
      recent one right here. And we'll send
      2:06:48
      that down to our dev server. And we
      2:06:49
      should hopefully see that this data will
      2:06:51
      update as soon as we refresh our page.
      2:06:53
      So we'll come over to where we were.
      2:06:55
      Send that down to the dev server. And
      2:06:56
      now when I refresh, you can see it
      2:06:58
      properly updated, which means when my
      2:06:59
      cache data changed, it revalidated my
      2:07:01
      cache. So it got the most up-to-date
      2:07:03
      data. And now every time I refresh this,
      2:07:05
      it's not calling that function again
      2:07:06
      because it has the correct data already
      2:07:08
      in the cache. Now we're going to want to
      2:07:09
      do the same thing with our user
      2:07:10
      notification settings as well because we
      2:07:12
      did it for our users. So let's go ahead
      2:07:14
      and do it for our user notification
      2:07:15
      settings. I just copied over the file.
      2:07:17
      It's almost identical. We pass in the
      2:07:20
      global tag. We have an ID tag. And for
      2:07:22
      our user notification settings, the ID
      2:07:23
      is just the user ID because it's a one
      2:07:25
      to one relationship. And then when we
      2:07:26
      call revalidate, we're revalidating
      2:07:28
      everything. And we want to make sure
      2:07:30
      inside of our database function that we
      2:07:32
      call that revalidate function. And we
      2:07:34
      want to make sure we pass in our setting
      2:07:36
      do user ID. Just like that. Make sure we
      2:07:38
      import that. And now that's going to
      2:07:40
      make sure our cache for our user
      2:07:41
      settings is also revalidated properly.
      2:07:43
      This is probably one of my favorite
      2:07:45
      things about the new way of caching in
      2:07:46
      X.js JS is it makes it really easy to
      2:07:47
      create these robust caching systems that
      2:07:49
      are really performant while also being
      2:07:51
      relatively easy to use because that's
      2:07:52
      kind of the trade-off a lot of times
      2:07:53
      with caching. So now at this point we
      2:07:55
      have most of our kind of boilerplate
      2:07:57
      background code done which is great
      2:07:58
      because now that we've done all this
      2:08:00
      upfront work implementing new features
      2:08:01
      is actually going to be relatively quick
      2:08:03
      and you'll notice that the second half
      2:08:04
      of this tutorial or the later half of
      2:08:06
      this tutorial new features are going to
      2:08:07
      be added incredibly quickly compared to
      2:08:09
      this first half where I mean literally
      2:08:10
      we've created a sidebar which is not
      2:08:11
      very impressive for the amount of time
      2:08:13
      this has been going on. Now, for us, I
    </chapter>
    <chapter title="Finish sidebar" start_time="2:08:15">
      2:08:15
      want to work on the employer dashboard
      2:08:16
      before I start working on the side for
      2:08:18
      the actual job listings because we can't
      2:08:20
      really show a list of job listings until
      2:08:22
      we have the ability to create different
      2:08:23
      job listings. So, let's kind of minimize
      2:08:25
      and close all the stuff that we have.
      2:08:26
      And inside of our app, I'm going to
      2:08:28
      create two new folders. The first one is
      2:08:30
      going to be employer. That's where all
      2:08:31
      of our employee side or employer side
      2:08:33
      and organization side of things is going
      2:08:35
      to go. Then, we're going to create a new
      2:08:36
      folder called jobseker. And this is for
      2:08:38
      essentially all of the code that's going
      2:08:40
      to be for the jobseker side of things
      2:08:41
      because we almost have two different
      2:08:43
      applications. One for the employers and
      2:08:45
      one for the people looking for jobs.
      2:08:46
      Now, the reason I put job seeker in
      2:08:48
      parenthesis is because I want this to be
      2:08:49
      a route grouping. I don't actually want
      2:08:51
      it to change the URL of my route. I just
      2:08:53
      wanted to change what different grouping
      2:08:55
      I have inside my application for things
      2:08:56
      like shared layouts and so on. So now I
      2:08:58
      kind of have these two different
      2:09:00
      sections of my application that I want
      2:09:01
      to work on. And both of them are going
      2:09:03
      to have their own layout.tsx file. For
      2:09:06
      now, we'll just say export default
      2:09:09
      function job seeker layout. And of
      2:09:13
      course, we're just going to return the
      2:09:15
      children that are returned from this
      2:09:16
      function.
      2:09:18
      So, we know that the children property
      2:09:20
      is a React node. There we go. So, now
      2:09:23
      essentially it's just going to return
      2:09:24
      our basic children. And we can put our
      2:09:26
      page or whatever we want directly inside
      2:09:27
      of that section. And same thing with
      2:09:29
      employer here. We want to have a layout
      2:09:30
      that's essentially going to be the same
      2:09:32
      thing. We'll call this employer layout.
      2:09:35
      Just like that. Now, to make this a
      2:09:36
      little bit easier to work with, they're
      2:09:37
      both going to have sidebars, but they're
      2:09:38
      going to be having a few differences
      2:09:40
      between these sidebars. So, I'm going to
      2:09:41
      create a shared component for them. I'll
      2:09:43
      put them inside this sidebar section.
      2:09:45
      We'll move our client sidebar into here.
      2:09:47
      That's this section right here. And I'm
      2:09:48
      also going to create another file called
      2:09:50
      app sidebar.
      2:09:52
      Just like that, tsx. And this is going
      2:09:54
      to be where all of our shared sidebar
      2:09:55
      code goes. So, I'm going to take what we
      2:09:57
      have currently inside this page. I'm
      2:09:58
      going to essentially copy all of this
      2:10:00
      code and we're going to put it into
      2:10:01
      here. Export function app sidebar.
      2:10:05
      And we're just going to take all the
      2:10:06
      code that we have for our sidebar and
      2:10:08
      put it into here. And I'm even going to
      2:10:09
      copy over the imports because
      2:10:10
      essentially these are the imports that
      2:10:12
      we're going to need. So I might as well
      2:10:13
      copy them so we don't have to manually
      2:10:14
      import all of them. There we go. Now,
      2:10:16
      let me make sure that I get all my
      2:10:17
      imports proper. So this app client needs
      2:10:19
      to be imported from the correct
      2:10:20
      location. There we go. That works fine.
      2:10:22
      And now I essentially want to take all
      2:10:23
      the stuff that is going to be shared
      2:10:25
      between my pages and keep it. And the
      2:10:27
      stuff that's going to be different, I
      2:10:28
      want to put inside of its own section.
      2:10:30
      So, for example, this sidebar group in
      2:10:31
      the middle here, this is going to be
      2:10:32
      different for each application. It's
      2:10:34
      whether the employer side or the
      2:10:35
      employee side, it's very different. So,
      2:10:37
      we're going to put some type of label
      2:10:38
      called content where we put all of our
      2:10:40
      sidebar content. And we'll pass that in
      2:10:42
      up here just like that. And content will
      2:10:44
      just be a React node. There we go. The
      2:10:46
      next section that we have differences is
      2:10:48
      down here for our user button versus
      2:10:50
      organization button. If we're on the
      2:10:51
      user page, we look at user button. If
      2:10:53
      we're on the employer side, we should
      2:10:55
      have a your organization button here.
      2:10:57
      So, this is going to be for our footer
      2:10:59
      button just like that. And again, we're
      2:11:01
      going to pass that in as a prop
      2:11:05
      that is going to be a React node. There
      2:11:07
      we go. Make sure I get rid of some of
      2:11:09
      this stuff that we don't need.
      2:11:10
      Essentially, just imports that are no
      2:11:11
      longer needed now that we've removed a
      2:11:13
      lot of these different things. And then
      2:11:14
      finally, we have the section down here,
      2:11:16
      which is just our main content, which
      2:11:17
      we're going to call children. And we're
      2:11:19
      going to pass that in as the children
      2:11:20
      property.
      2:11:22
      There we go. And same thing up here.
      2:11:25
      Perfect. So now we've got all of our
      2:11:26
      shared content as well as all of the
      2:11:28
      content that differs between our
      2:11:29
      sections. So now inside of our page,
      2:11:31
      which we essentially want to make our
      2:11:33
      layout now over here, we can just use
      2:11:35
      this exact same code, but we can change
      2:11:37
      around what we're working with. So
      2:11:38
      inside this layout, we're going to
      2:11:39
      return here. This section down here is
      2:11:41
      going to be our children. And we're
      2:11:42
      going to make sure instead of using this
      2:11:44
      sidebar provider, this is our app
      2:11:46
      sidebar. Just like that. And we can get
      2:11:48
      rid of pretty much all of our main code.
      2:11:49
      We just want to return a content
      2:11:51
      section,
      2:11:53
      a footer button section, and then we
      2:11:55
      want to return our children. Now, our
      2:11:56
      children in this case is just this text
      2:11:58
      asf. Doesn't really matter super much
      2:12:00
      what that is. Let's close off our app
      2:12:01
      sidebar down here.
      2:12:04
      There we go. And we know that our
      2:12:06
      content is all of this section right
      2:12:08
      here. So, let's just copy that, paste
      2:12:09
      that into our content section. Our
      2:12:11
      footer button is just this button right
      2:12:13
      here. So, we'll paste that into here.
      2:12:15
      And all the rest of this content we can
      2:12:16
      completely get rid of minus just this
      2:12:18
      random text that we'll replace with real
      2:12:20
      code in just a little bit. There we go.
      2:12:22
      Give that a quick save. And now we just
      2:12:24
      need to make sure we import all these
      2:12:25
      different section components.
      2:12:31
      Get link imported.
      2:12:33
      And there we go. And our sidebar user
      2:12:36
      button. That should be all the different
      2:12:38
      imports that we need. I just want to
      2:12:39
      make sure that I import my version of
      2:12:41
      the signed out component. There we go.
      2:12:43
      And the children section is what's going
      2:12:45
      to go into here. There we go. So now we
      2:12:47
      have everything inside this layout just
      2:12:49
      like we want it to. Let's create a page.
      2:12:52
      This page is going to be export default
      2:12:56
      function. This is our homepage. The
      2:12:58
      first page that we render on our
      2:13:00
      application. Now just return the text
      2:13:02
      high. There we go. Now this old page we
      2:13:05
      no longer need. We can completely get
      2:13:06
      rid of this. And if we give this a save
      2:13:08
      and we hopefully refresh our page, you
      2:13:09
      can see the text high shows up and our
      2:13:11
      sidebar is still exactly the same as it
      2:13:12
      was before because we just kind of
      2:13:14
      swapped things around. The nice thing
      2:13:15
      though is that now I can essentially
      2:13:17
      take this sidebar, I can copy it and I
      2:13:19
      can use it on the employer side as well
      2:13:21
      and all I need to do is add in all these
      2:13:22
      different imports. So let's go ahead
      2:13:25
      real quickly go through import all these
      2:13:27
      different components.
      2:13:31
      Again, making sure that we import them
      2:13:32
      all from the correct location. And then
      2:13:34
      finally down here. Now, currently, we're
      2:13:36
      obviously going to change around some of
      2:13:38
      these things because we don't want to
      2:13:39
      show a user button, for example, on the
      2:13:40
      sidebar, but we have at least our
      2:13:42
      overall layout for the employer side.
      2:13:44
      And if we go to that slash employer play
      2:13:46
      page and we make sure, first of all, we
      2:13:48
      need a page in here. And this page is
      2:13:50
      going to look just like this. We'll call
      2:13:53
      this our employer homepage. And this
      2:13:56
      will say hi employer. There we go. So,
      2:13:59
      now if we go to that employer page, we
      2:14:01
      should see exactly the same stuff on the
      2:14:02
      sidebars and everything. And it says hi
      2:14:04
      employer. Now, to make it easier to
      2:14:05
      navigate between my employer page and my
      2:14:08
      non-emp employer page, because right now
      2:14:09
      there's no links or anything that allow
      2:14:10
      me to do that, I'm going to create a
      2:14:12
      really handy component that will make it
      2:14:13
      really easy for us to create a sidebar,
      2:14:15
      we'll call this sidebar, nav, menu
      2:14:18
      group.tsx.
      2:14:19
      And if we look at one of our layouts,
      2:14:21
      you'll notice that inside of this, we
      2:14:22
      have a sidebar group, menu, menu item,
      2:14:24
      menu button. It's a lot of the same code
      2:14:27
      to create a single link. There's a ton
      2:14:28
      of different components that go into it.
      2:14:30
      So essentially I just want to be able to
      2:14:31
      pass an array of where my links go and
      2:14:33
      it's going to automatically create this
      2:14:34
      different component for me. So inside of
      2:14:36
      this sidebar nav menu group we can
      2:14:38
      export a function with that name.
      2:14:42
      It's going to take in some objects and
      2:14:45
      these objects are going to be typed. So
      2:14:46
      we're going to have items. This is going
      2:14:48
      to be an array of objects where we have
      2:14:49
      an href which is a string. An icon. This
      2:14:52
      is going to be a React node for the icon
      2:14:54
      associated with it. A label that's just
      2:14:56
      going to be the text associated with
      2:14:58
      that particular link. And then also some
      2:15:00
      of our icons or our links should only
      2:15:02
      show up if we're signed in or signed
      2:15:03
      out. So we'll have an off status of
      2:15:05
      signed out or it'll be a status of
      2:15:09
      signed in. So for example, we can show
      2:15:11
      links only if we're signed in or only if
      2:15:13
      we're signed out. Also, if I want to
      2:15:15
      specify any class names, I can do that
      2:15:17
      as well. This is something I add to
      2:15:18
      pretty much all my components. So now we
      2:15:20
      have our items and we have our class
      2:15:22
      name and we can use that information
      2:15:24
      directly inside of here. And we kind of
      2:15:25
      want to mirror this particular syntax.
      2:15:27
      So, we'll just come in here with a quick
      2:15:28
      return and I want to import all these
      2:15:31
      different components that we're going to
      2:15:32
      be using. Make sure I get my own custom
      2:15:34
      signed out. I'm going to get our sidebar
      2:15:36
      menu. Sidebar menu button. We want to
      2:15:38
      get our link. We don't really care about
      2:15:39
      this component or this icon because
      2:15:41
      that's going to be different for each
      2:15:42
      one. But now we have our ability to
      2:15:43
      render out the exact stuff that we want
      2:15:45
      to render. So, what we can do inside of
      2:15:47
      here, we have our sidebar group, we have
      2:15:48
      our sidebar menu, and then I want to
      2:15:50
      loop through each one of our items and I
      2:15:52
      want to turn them into essentially a
      2:15:53
      component that we can use. So inside of
      2:15:55
      here, I want to get the HTML portion of
      2:15:58
      my component, which is essentially just
      2:15:59
      going to be this section right here. So
      2:16:01
      we'll copy that directly into there. We
      2:16:03
      have our item, we have our button, and
      2:16:04
      then we have our link that's going to go
      2:16:05
      to a particular href, which is just
      2:16:07
      item.href.
      2:16:09
      Inside of our link, we're going to have
      2:16:11
      our component as well as our span, which
      2:16:14
      is going to say item.
      2:16:18
      And let me make sure that I have all my
      2:16:19
      parentheses and everything proper. Looks
      2:16:21
      like I do for the most part. We can
      2:16:22
      return our HTML down here. That should
      2:16:24
      hopefully get rid of any errors that we
      2:16:25
      have. And actually, the reason I'm
      2:16:26
      getting an error is cuz I need to make
      2:16:27
      sure that this is typed as an array. And
      2:16:29
      now that should clean everything up. So
      2:16:30
      now the final thing I want to do is I
      2:16:31
      want to render out my item icon. Just
      2:16:34
      like that. So this is all the HTML for
      2:16:36
      my particular element exactly as I want
      2:16:38
      it, which is great. Also for my sidebar
      2:16:40
      menu button, this should say as child.
      2:16:42
      Actually, it already does say as child,
      2:16:43
      but also we want to add this is active
      2:16:45
      prop. And this is going to be if this is
      2:16:47
      the active link, we want to render that.
      2:16:49
      So we'll say if the path name is equal
      2:16:51
      to item.href, href then it's going to be
      2:16:53
      the active item on our list. So what we
      2:16:55
      can do is we can scroll up and we can
      2:16:56
      get that path name which is just path
      2:16:59
      name is equal to use path name which is
      2:17:01
      a hook that we can import directly just
      2:17:03
      like that. So now we have that path name
      2:17:05
      property. So if we're on the current
      2:17:06
      path it'll highlight this as my active
      2:17:08
      link. Also since we're in an array we
      2:17:10
      should wrap this in a key. So we'll put
      2:17:11
      the href directly on there. Now the
      2:17:13
      reason I'm not returning our HTML
      2:17:14
      directly is because if our item.au
      2:17:17
      status is equal to signed out for
      2:17:19
      example then what I want to do is I want
      2:17:21
      to wrap this in my signed out component
      2:17:23
      which we actually have right here. So
      2:17:24
      I'll just use that and I'll put the HTML
      2:17:26
      directly inside of that. And again we
      2:17:28
      need to make sure we specify a key on
      2:17:30
      this. So we'll say item.href. I
      2:17:33
      essentially want to do the exact same
      2:17:34
      thing for my signedin status but in this
      2:17:37
      case I want it to say signed component.
      2:17:42
      There we go. So now I have that properly
      2:17:44
      working. So if I'm signed out, render
      2:17:46
      wrapped on signed out. If I'm signed in,
      2:17:48
      wrap it in the signed in. Otherwise,
      2:17:49
      return the HTML as is. Finally, I want
      2:17:52
      to just be able to add my class name. So
      2:17:53
      we'll say class name of class name in
      2:17:55
      case I have any additional class names
      2:17:56
      to pass through. And now this allows me
      2:17:58
      to create a really easy sidebar menu. So
      2:18:00
      I can come all the way back to where we
      2:18:02
      have our sidebar being defined. We'll do
      2:18:03
      it in our job seeker section first. This
      2:18:06
      whole entire section I can replace with
      2:18:08
      a sidebar nav menu group. And inside of
      2:18:11
      here, we're going to specify a class
      2:18:13
      name of margin top auto. That'll just
      2:18:14
      push our links all the way to the
      2:18:16
      bottom. And then we need to define all
      2:18:18
      the different items for essentially all
      2:18:19
      the different links that we have
      2:18:20
      possible. So the very first link that I
      2:18:22
      want to have is a link that's just going
      2:18:24
      to bring me back to the job board. So
      2:18:25
      we'll just have that as an empty href.
      2:18:27
      Our icon is going to be the clipboard
      2:18:30
      list icon. And then finally, our label
      2:18:34
      for this one is just going to say job
      2:18:36
      board. There we go. So that's going to
      2:18:38
      be our very first icon. Also, I'm
      2:18:39
      getting an error because of the off
      2:18:41
      status related stuff. I didn't make that
      2:18:42
      an optional property when I should have.
      2:18:44
      So, what I want to do is I want to go
      2:18:45
      back into here. O status should be
      2:18:47
      optional. And also, I need to mark this
      2:18:49
      as a use client since we're using hooks
      2:18:51
      inside of it. So, there we go. That
      2:18:53
      cleaned that up. Now, if I look over
      2:18:54
      here and I expand this, you'll notice I
      2:18:56
      don't see anything. But, if I give this
      2:18:57
      a quick save, hopefully we should see a
      2:18:58
      link. And of course, I'm on the employer
      2:19:00
      page. Let's go back to the normal page.
      2:19:02
      And now, you can see that I have my job
      2:19:03
      board link and it's highlighted as my
      2:19:05
      active link because that's the page that
      2:19:06
      I'm currently on. Now, I'm going to copy
      2:19:08
      this down a couple times. We're going to
      2:19:10
      have our AI search page. That's going to
      2:19:13
      be having the brain circuit icon, and
      2:19:17
      this will just say AI search.
      2:19:20
      So, now you can see we have a link for
      2:19:21
      AI search down there. Next, we're going
      2:19:23
      to add another link. This one is going
      2:19:24
      to be for going to the employer
      2:19:26
      dashboard, and this will say layout
      2:19:28
      dashboard. Just like that. And we'll
      2:19:29
      call this employer dashboard.
      2:19:34
      And this one specifically has an off
      2:19:36
      status of signed in because I can only
      2:19:37
      go to the employer site if I'm currently
      2:19:39
      signed in. So now you can see that
      2:19:40
      employer dashboard. And the nice thing
      2:19:41
      is when I minimize this down on a full
      2:19:43
      screen, you can see if I minimize that,
      2:19:45
      I have my icon showing up, which is
      2:19:47
      exactly what I want. So that looks
      2:19:48
      really good. And then we have a final
      2:19:50
      link here, which is going to be for me
      2:19:51
      able to sign into the application. So
      2:19:53
      this will say sign in. This will be my
      2:19:56
      login icon.
      2:19:58
      Just like that. This will say login or
      2:20:00
      actually let's just make it say sign in.
      2:20:02
      And then my off status on this one is
      2:20:04
      signed out. There we go. So that button
      2:20:06
      will only show up if I'm signed out,
      2:20:07
      which is why it's currently not showing
      2:20:09
      up on my page, which is exactly what I
      2:20:11
      want. And now the really nice thing is
      2:20:12
      if I click on employer dashboard, it
      2:20:14
      brings us to the employer page and we
      2:20:15
      can go ahead and add in our own nav menu
      2:20:17
      on the employer page. So I'll copy this
      2:20:19
      over. We'll go over to our employer page
      2:20:22
      and we'll come in where this entire
      2:20:23
      section is and we'll just replace it
      2:20:24
      with our nav menu with all the stuff
      2:20:26
      that we want to do inside of here
      2:20:27
      instead. Now, this sidebar menu is going
      2:20:29
      to be a little bit different because
      2:20:30
      we're actually going to have multiple
      2:20:31
      sections. So, I'm going to just take
      2:20:32
      this, drop it down there like that.
      2:20:34
      We're going to have our sidebar nav menu
      2:20:36
      group. And then we're going to have a
      2:20:36
      section for listing out all the current
      2:20:38
      job listings as well. We'll call this
      2:20:40
      our sidebar group.
      2:20:44
      If I can spell properly. There we go. We
      2:20:45
      have our sidebar group. And inside of
      2:20:47
      here, we need a sidebar group label.
      2:20:49
      This will say job listings.
      2:20:52
      There we go. If we just give that a
      2:20:53
      quick save, obviously we're going to get
      2:20:54
      some errors because none of these icons
      2:20:55
      are being rendered properly. So, let's
      2:20:57
      just comment this out for now. And you
      2:20:58
      can see over here it says job listings
      2:21:00
      at the top. Also, we can give this an
      2:21:02
      action as well. So, we can come in here,
      2:21:04
      sidebar, group action. Just like that.
      2:21:07
      We'll give it a title so it's easy for
      2:21:08
      people to know what it says. Add job
      2:21:10
      listing. We'll make this an as child.
      2:21:13
      And essentially what we want to do is we
      2:21:14
      want to put a plus icon in here. So,
      2:21:16
      we'll say plus icon. This plus icon is
      2:21:18
      then going to render some text
      2:21:20
      afterwards, which is going to be
      2:21:21
      specifically for a screen reader. So,
      2:21:23
      we'll say screen reader only.
      2:21:25
      And this is going to say add job
      2:21:28
      listing. So now we essentially if I make
      2:21:30
      sure I close off everything properly and
      2:21:32
      actually I don't need to close anything.
      2:21:33
      I need to wrap this in a link because
      2:21:34
      that's the whole reason why we made it
      2:21:35
      as child. So it should say employer job
      2:21:38
      listings
      2:21:40
      new. There we go.
      2:21:43
      Now if I give that a save and I open
      2:21:45
      this up, you can see that I have this
      2:21:46
      plus button and when I click it, it'll
      2:21:47
      redirect me to job listings/ new, which
      2:21:49
      isn't a page yet, but at least we have
      2:21:51
      that section of our navbar. And then
      2:21:53
      below that, we would obviously add in
      2:21:54
      all of our job listings, but we'll get
      2:21:56
      to that once we create job listings.
      2:21:58
      Now, I want to go ahead and actually
      2:21:59
      create what all my different navigation
      2:22:01
      URL links are going to be. So, the first
      2:22:03
      one is going to be the same link to go
      2:22:04
      back to the job board. And then we don't
      2:22:06
      care about AI search or the employer
      2:22:07
      dashboard. All we care about is sign in.
      2:22:09
      So, really all we care about is these
      2:22:10
      two links. Now, if we open this up, we
      2:22:12
      have job listings at the top and we have
      2:22:14
      a link to the job board on the bottom.
      2:22:15
      And to be fair, we don't even need this
      2:22:17
      sign-in link really. I'm going to keep
      2:22:18
      it there just in case, but we should
      2:22:20
      never get to this page without being
      2:22:21
      signed in. So, actually, I'm just going
      2:22:22
      to completely remove it because there is
      2:22:23
      no way that we get to this page without
      2:22:24
      being signed in because this is a
      2:22:26
      private page. Now, here instead of our
      2:22:27
      sidebar user button, this should be our
      2:22:29
      sidebar organization button. And we'll
      2:22:32
      create that next because that's going to
      2:22:33
      be kind of the thing that glues
      2:22:34
      everything together. Before we do that
      2:22:35
      though, let's just clean up a lot of
      2:22:37
      these imports that are no longer needed
      2:22:38
      just to make our code a little bit
      2:22:39
      cleaner. And now, let's go ahead and
      2:22:41
      create that sidebar organization button.
      2:22:43
      And this is actually going to be very,
      2:22:44
      very similar to our user version as
      2:22:46
      well. So, I'm actually going to take the
      2:22:47
      user version and copy it over. We'll say
      2:22:49
      organizations/components
      2:22:51
      because that's where we want the code
      2:22:53
      for this to go. And then inside here,
      2:22:54
      I'm just going to take these two
      2:22:55
      components and copy them over. This
      2:22:57
      one's going to be called sidebar
      2:22:59
      organization button. And same thing
      2:23:01
      here, replace this
      2:23:03
      organization. There we go. So now let's
      2:23:05
      start with this button cuz it's going to
      2:23:07
      be rather straightforward where we have
      2:23:08
      user. I'm going to replace that with
      2:23:10
      organization. Just like that. So we have
      2:23:12
      our suspense version. And in the
      2:23:13
      suspense version, we need to get the
      2:23:15
      current user and the current
      2:23:16
      organization. So essentially I just want
      2:23:18
      to copy this code, paste it down just
      2:23:21
      like this and I want to create a get
      2:23:24
      organization function and up here get
      2:23:27
      current
      2:23:28
      organization. They're going to be very
      2:23:30
      similar. So essentially here I can get
      2:23:32
      my org ID. This is the currently signed
      2:23:34
      in organization for the user. We'll get
      2:23:36
      that information right here. And then
      2:23:38
      this is just saying, hey, if I have an
      2:23:40
      org ID, I want to call get organization
      2:23:42
      with that or ID. So really it's exactly
      2:23:45
      the same as what I did for my user. I'm
      2:23:46
      just swapping it out with the
      2:23:47
      organization's ID instead. Down here, I
      2:23:50
      want to get the organization ID tag,
      2:23:52
      which we don't have a function for yet,
      2:23:53
      but we'll create in a second. And then I
      2:23:55
      want to get my organization table if the
      2:23:57
      ID matches. So, we can say organization
      2:24:00
      table ID, just like that. So, now let's
      2:24:02
      go ahead and create the caching for our
      2:24:03
      organization as well. So, again,
      2:24:05
      something that's going to be very
      2:24:06
      similar to what we did with our user.
      2:24:08
      So, I'm going to go into my users
      2:24:09
      database. I'm going to go specifically
      2:24:11
      into the cache section for that. I'll
      2:24:12
      copy that over. And here we'll say
      2:24:14
      db/cache
      2:24:16
      and I want to do this cache right here.
      2:24:18
      And we'll change it to organizations.
      2:24:20
      Now our cache tags for these are
      2:24:22
      identical. All I'm going to do is take
      2:24:23
      the word user and swap it out for the
      2:24:25
      word organization. Otherwise everything
      2:24:27
      is exactly the same. So I'm not going to
      2:24:28
      make you watch me type that out multiple
      2:24:30
      times. Now we can come back into here.
      2:24:32
      We can import that. That way we have our
      2:24:34
      same caching system for both of these
      2:24:35
      all hooked up properly. That way we
      2:24:37
      don't over access things if we don't
      2:24:38
      need to. And now inside of here we can
      2:24:40
      actually get the current user and the
      2:24:41
      current organization. So what we want to
      2:24:43
      do is we're going to wrap this in a
      2:24:44
      promise.all. So we'll say promise.all.
      2:24:47
      We're going to wrap our git current
      2:24:48
      user. And we'll do the exact same thing
      2:24:51
      for get current organization.
      2:24:53
      Get current
      2:24:55
      organization. Just like that. Again,
      2:24:57
      we'll make this a little bigger so it's
      2:24:58
      easier to see. Make sure that I get all
      2:25:00
      this closed off properly. And this is
      2:25:02
      going to return to me an array. First
      2:25:04
      property is going to have my user
      2:25:06
      object. Second one is going to have my
      2:25:08
      organization. Just like that. Make sure
      2:25:10
      I spell that properly. There we And I
      2:25:12
      just need to make sure I await this
      2:25:13
      promise and that's going to give me all
      2:25:15
      my information. Now, if my user or my
      2:25:17
      organization is equal to null, well, I
      2:25:19
      can't actually render out what my button
      2:25:20
      should look like. So, we'll just give us
      2:25:22
      that log out button. Same exact fallout,
      2:25:23
      that fallback that we had before.
      2:25:25
      Otherwise, I want to render out my
      2:25:26
      sidebar organization
      2:25:30
      button client. Just like that. And we'll
      2:25:33
      make sure that we get rid of all these
      2:25:34
      imports that we no longer need. And this
      2:25:36
      is going to take my user and my
      2:25:38
      organization.
      2:25:40
      There we go. So now I can copy that and
      2:25:42
      inside this other file, the one that we
      2:25:44
      copied over, we can essentially just
      2:25:45
      replace the name to the sideboard
      2:25:47
      organization button. And then we can
      2:25:48
      replace the content that we want inside
      2:25:50
      of here because this is going to get in
      2:25:51
      an organization and a user. So we can
      2:25:53
      come in here, organization. We'll call
      2:25:57
      this organization. And we'll copy this
      2:25:59
      type
      2:26:01
      to get our organization. Now for our
      2:26:02
      user, the only thing that we actually
      2:26:04
      care about is going to be the email
      2:26:05
      property. And for our organization, the
      2:26:07
      image URL can actually be null. And of
      2:26:09
      course, there's no email on the
      2:26:10
      organization. Otherwise, these
      2:26:12
      properties are pretty much exactly the
      2:26:13
      same between the two of them. We just
      2:26:15
      need to make sure that when we're using
      2:26:16
      our user, we swap that out to make sure
      2:26:17
      we use the actual organization and so
      2:26:19
      on. So, here you can see we have our
      2:26:21
      user info. I'm going to replace that
      2:26:22
      with organization info just like that.
      2:26:26
      And this is going to take in our user as
      2:26:28
      well as our organization. So, we'll say
      2:26:30
      user
      2:26:33
      and organization.
      2:26:35
      There we go. And I can just make sure I
      2:26:37
      copy that to all the places that this
      2:26:39
      particular component is being used. So I
      2:26:40
      believe it's being used right here as
      2:26:42
      well. There we go. And then down here
      2:26:44
      where we're using this, it should take
      2:26:45
      in an organization and a user.
      2:26:51
      And we want to make sure we get those
      2:26:52
      types.
      2:26:54
      There we go. So now we have those types
      2:26:55
      proper. For our name initials, that's
      2:26:57
      going to be coming from our
      2:26:58
      organization.name.
      2:26:59
      And then we want to make sure we use our
      2:27:01
      organization image URL here. And by
      2:27:03
      default, if we don't have one, we're
      2:27:05
      going to set it to undefined. Just like
      2:27:07
      that. And same thing here. This is our
      2:27:09
      organization.name.
      2:27:11
      Our organization.name. And here's the
      2:27:13
      one place where we use the users
      2:27:15
      information is for their email. Other
      2:27:16
      than that, we pretty much keep
      2:27:18
      everything else exactly the same because
      2:27:19
      really we're just swapping out our
      2:27:20
      organization stuff for our user stuff.
      2:27:22
      Now, hopefully, if we import everything
      2:27:24
      properly, we should actually see this
      2:27:25
      rendering on our page. So, let's give
      2:27:26
      that a quick save. And I believe inside
      2:27:28
      of here, I need to import that button as
      2:27:30
      well. And now hopefully you can see we
      2:27:33
      have that organization button down here.
      2:27:35
      But we don't actually have an
      2:27:36
      organization we're signed into yet,
      2:27:37
      which is why it just says log out, which
      2:27:39
      is that fallback state, which is kind of
      2:27:40
      exactly what we want. So let's go ahead
      2:27:42
      and like finish out this button because
      2:27:44
      right now our drop-own menu has the
      2:27:45
      wrong in content inside of it. As you
      2:27:48
      can see, it has content for like user
      2:27:49
      profile and user profile, which we don't
      2:27:51
      want. So the very first dropown menu
      2:27:52
      item, this one is going to open our
      2:27:55
      organization profile for modifying our
      2:27:57
      organization. So up here, just swap that
      2:28:00
      out for our organization. And then down
      2:28:02
      here, we want to use the building to
      2:28:05
      icon, which is going to be an icon that
      2:28:06
      kind of looks like an organization. And
      2:28:08
      it'll say manage organization. There we
      2:28:11
      go. Next up for the list that we want to
      2:28:13
      have is going to be our settings for our
      2:28:15
      user. So we're going to say user
      2:28:16
      settings, and this is going to be the
      2:28:18
      user round cog icon. And this is going
      2:28:21
      to allow us to modify the settings for
      2:28:23
      the user like do you want to get email
      2:28:24
      notifications for new job listings for
      2:28:27
      this particular organization. So it's
      2:28:28
      kind of that organization user settings.
      2:28:30
      That's what this is going to be allowing
      2:28:32
      us to modify. And this is needing to go
      2:28:34
      to employer/ user settings just like
      2:28:36
      that. Next step that we need to work on
      2:28:38
      is going to be our pricing section. So
      2:28:40
      we can kind of copy this down as another
      2:28:42
      dropown menu item. And this one's going
      2:28:44
      to be for pricing. So if we want to
      2:28:45
      change our plan, there we go. For this
      2:28:48
      one, we want to have the credit card
      2:28:52
      icon. And this will say
      2:28:56
      change plan. Then with that done, we can
      2:28:58
      add in a drop-own menu separator because
      2:29:00
      I have another item that I want to add
      2:29:02
      in between our logout and our changing
      2:29:04
      of our plan. And this one is going to be
      2:29:06
      for swapping organizations. So this can
      2:29:08
      just go to slashorganizations
      2:29:10
      slash select. And I should make sure I
      2:29:12
      put a slash in front of these URLs so
      2:29:14
      they go to the right place. This will
      2:29:15
      allow us to change what organization
      2:29:17
      we're currently on. We'll call this
      2:29:19
      arrow left right icon. There we go. And
      2:29:22
      this is going to say switch
      2:29:25
      organizations. There we go. Then
      2:29:27
      finally, just like before, we have the
      2:29:28
      logout button down here. So essentially,
      2:29:30
      I just changed what's inside of our menu
      2:29:32
      options for our dropdown. Now, one thing
      2:29:34
      that you may notice, which is a bit of a
    </chapter>
    <chapter title="Organization selector" start_time="2:29:35">
      2:29:35
      problem with our page, is that we're on
      2:29:37
      the employer dashboard, but we don't
      2:29:38
      have an organization created or signed
      2:29:40
      into at all. This is something we want
      2:29:42
      to make sure that we avoid. So, what
      2:29:44
      we're going to do is we're going to go
      2:29:45
      to our layout for our employer, and
      2:29:47
      we're actually going to break this into
      2:29:48
      two different sections. We're going to
      2:29:50
      have our export default, which is what
      2:29:51
      we have for our employer layout, and
      2:29:53
      we're going to render that particular
      2:29:54
      section out. And this is just going to
      2:29:56
      wrap a suspended version of our page.
      2:29:58
      So, we can return here a suspense.
      2:30:02
      And this is very common pattern that we
      2:30:03
      have to use when we're working with this
      2:30:04
      dynamic IO way of doing things. And
      2:30:06
      we'll say layout suspense
      2:30:09
      just like that. And that's what we're
      2:30:10
      going to call the component that we have
      2:30:11
      down here. and we're not going to export
      2:30:13
      that or anything. And this layout
      2:30:14
      suspense is going to take in our
      2:30:16
      children. So essentially what's
      2:30:18
      happening is while we're doing our
      2:30:19
      loading, we're just going to be having
      2:30:21
      the suspend and render out no content at
      2:30:23
      all. And that's perfectly okay for this
      2:30:24
      particular use case. And the reason I'm
      2:30:26
      doing that is because inside of here,
      2:30:27
      I'm going to make this an async
      2:30:28
      function. I'm going to try to get my
      2:30:30
      current organization. So I'm going to
      2:30:31
      say org ID is equal to await get current
      2:30:35
      organization. There we go. And then if
      2:30:37
      my org ID is null,
      2:30:40
      well then I know I'm not signed into an
      2:30:42
      organization, so I shouldn't be here. So
      2:30:44
      I'm going to redirect the user. Just
      2:30:46
      going to return that. I'm going to
      2:30:47
      redirect them to slashorganizations/
      2:30:51
      select. There we go. So now when I save
      2:30:53
      this, we should hopefully get redirected
      2:30:54
      to /organizations/
      2:30:56
      select, which is a page that I'm going
      2:30:58
      to create now. So we can go into our
      2:30:59
      clerk section because this is going to
      2:31:00
      be handled by clerk for us. And we can
      2:31:02
      create an organizations slash select.
      2:31:06
      And then we can inside of here create a
      2:31:08
      page.
      2:31:10
      And this page is going to be rather
      2:31:12
      straightforward. I'm going to get
      2:31:13
      started by just pasting in some code.
      2:31:15
      I'll explain exactly what's going on.
      2:31:16
      Let me just create this suspended page
      2:31:18
      real quick, though. There we go. Make
      2:31:22
      sure I get all that proper. There we go.
      2:31:23
      Okay. So, for this props, we're taking
      2:31:25
      in search prams. And specifically, I'm
      2:31:27
      taking in a search pram of redirect with
      2:31:28
      a potential question mark. So, if I have
      2:31:30
      a redirect option being passed in, then
      2:31:32
      I want to redirect to that page.
      2:31:34
      Otherwise, don't redirect at all. So,
      2:31:35
      for example, if I navigate to a specific
      2:31:37
      page and then I'm not signed into an
      2:31:39
      organization, it'll direct me here. I'll
      2:31:41
      choose my organization and then I'll get
      2:31:42
      redirected to exactly the page I used to
      2:31:44
      be on. That's all this redirect prop is
      2:31:46
      there for. Now, for our suspended page,
      2:31:48
      it's going to take in those search
      2:31:49
      params. So, we're going to take in
      2:31:51
      essentially the search params property.
      2:31:52
      Exactly the same as we had up here. So,
      2:31:54
      we'll say search params is of type
      2:31:56
      props. Just like that. It's taking in
      2:31:57
      all the same properties we had from up
      2:31:59
      here. And inside of our suspended page,
      2:32:01
      all I want to do is I want to get what
      2:32:02
      that redirect is. So I'll say redirect
      2:32:05
      is equal to calling await search params
      2:32:08
      because this is a promise. This is the
      2:32:09
      whole reason we had to wrap inside of
      2:32:11
      the suspenses because we need to wait
      2:32:13
      for those search params. And then we'll
      2:32:15
      say that our redirect URL is either
      2:32:17
      equal to redirect if we passed it in
      2:32:20
      otherwise it'll be equal to employer.
      2:32:23
      There we go. So we're either going to
      2:32:24
      redirect them back to the employer page
      2:32:25
      by default or a specific URL that they
      2:32:27
      want to go to. Then what we're going to
      2:32:29
      do is we're going to return organization
      2:32:32
      list. And this organization list is a
      2:32:34
      component directly from clerk. And
      2:32:36
      inside here we want to do a few things.
      2:32:38
      First of all, we want to hide the option
      2:32:39
      to choose your personal account because
      2:32:40
      we only want them to be able to choose
      2:32:42
      an organization. We're also going to
      2:32:44
      hide the slug, which is just kind of
      2:32:45
      like a URL friendly way of displaying
      2:32:47
      organizations. We don't need it. And we
      2:32:49
      also don't care about the invitation
      2:32:50
      screen. So we'll skip that as well. Then
      2:32:53
      finally, after they select an
      2:32:54
      organization URL, we will redirect them
      2:32:56
      back to our redirect URL. And if they
      2:32:59
      create a UR or create an organization,
      2:33:01
      for example, they don't have one yet,
      2:33:02
      we'll also redirect them back to that
      2:33:04
      URL. So this is going to work for both
      2:33:05
      cases where they either create a
      2:33:07
      organization or select an organization.
      2:33:09
      So now notice we're getting a new error.
      2:33:10
      Essentially, we just need to make sure
      2:33:11
      we enable organizations in our
      2:33:13
      application. So inside of our
      2:33:14
      application, wherever we have
      2:33:15
      organizations, you can see right here,
      2:33:17
      organization management, enable
      2:33:19
      organizations. And now we can use them
      2:33:20
      throughout our entire application. So we
      2:33:22
      can come over here and we can give this
      2:33:24
      a quick refresh. And now you can see I
      2:33:26
      have the ability to create an
      2:33:26
      organization because I don't have any
      2:33:28
      organizations I'm a part of. That's why
      2:33:29
      the list by default will show you a
      2:33:31
      create screen. Otherwise, it'll show you
      2:33:33
      the list of organizations you're in. So,
      2:33:34
      let me just go ahead and we'll create an
      2:33:36
      organization. We'll just call this WDS
      2:33:38
      comp. And we'll create that
      2:33:39
      organization. And now you can see I've
      2:33:41
      been redirected back to this page. It
      2:33:42
      says hi employer, but you'll notice it
      2:33:44
      still says log out down here instead of
      2:33:45
      my big organization picker. The reason
      2:33:48
      for that again is because we need to
      2:33:49
      make sure we hook up our web hooks to be
      2:33:51
      able to send the information from clerk
      2:33:53
      over to our application. If we look
      2:33:55
      inside of ingest, you'll notice it
      2:33:56
      actually received our web hook. If we go
      2:33:58
      over to our event types, we should see
      2:34:00
      organization created and it has a brand
      2:34:02
      new web hook inside of here that was
      2:34:03
      sent to us for that organization we
      2:34:05
      created. So we just need to make sure we
      2:34:06
      set up a way to consume that web hook
      2:34:08
      inside of our application. So what we
    </chapter>
    <chapter title="Clerk organization webhooks" start_time="2:34:10">
      2:34:10
      can do is inside of our source services
      2:34:12
      ingest inside of clerk we need to
      2:34:14
      essentially create three more for
      2:34:15
      creating updating and deleting our
      2:34:17
      organization. Now I'm going to go ahead
      2:34:18
      I'm going to copy my clerk create user
      2:34:20
      to get started as a nice little starting
      2:34:22
      point. We'll say this is going to be
      2:34:24
      creating an organization create db
      2:34:27
      organization.
      2:34:28
      There we go. Going to update it in a
      2:34:30
      bunch of different places at once. So
      2:34:31
      there's our event. Right now we're
      2:34:32
      getting an error because we don't have
      2:34:34
      that event hooked up inside of our
      2:34:35
      application. So, let's make sure we go
      2:34:36
      into our client and we set up the event
      2:34:38
      for all three of these. So, we're going
      2:34:40
      to have our organization
      2:34:42
      deleted and we want one for created and
      2:34:44
      so on. And make sure I spell
      2:34:45
      organization properly. So, this is going
      2:34:47
      to be created updated. And this should
      2:34:50
      take our organization
      2:34:52
      JSON. There we go. For both of these. So
      2:34:55
      now at least we have the proper typing
      2:34:56
      set up. So at least we don't have any
      2:34:58
      errors for that. We verify our web hook
      2:34:59
      just like we did with all the rest of
      2:35:01
      them. And then finally we can create our
      2:35:02
      organization just like this. So, this is
      2:35:05
      going to return to us an organization
      2:35:06
      ID, but we don't even care because we
      2:35:07
      don't need to bother with the settings
      2:35:09
      down here. We can get rid of that
      2:35:10
      completely. Also, we don't need to worry
      2:35:12
      about email or anything like that. All
      2:35:13
      we care about is our org data just like
      2:35:16
      that. That's coming from our data. And
      2:35:17
      then we want to insert an organization
      2:35:20
      just like this. And the organization,
      2:35:22
      we'll create a function for that before
      2:35:23
      we dive into the rest of the code. So,
      2:35:24
      inside of our features, inside of
      2:35:26
      organizations, I essentially just want
      2:35:28
      to copy what I did for my users and I
      2:35:30
      want to put it into here. This is going
      2:35:31
      to be for insert organization
      2:35:34
      and this is going to be for my
      2:35:36
      organization
      2:35:37
      table. Just like that. And we want to do
      2:35:39
      the exact same thing for update and
      2:35:41
      delete. So we'll say update
      2:35:44
      and delete. Again, they're going to be
      2:35:46
      coming from the organization table on
      2:35:49
      all of these. Make sure I just import
      2:35:51
      that in all of those places. There we
      2:35:53
      go. This is going to be our
      2:35:54
      organization.
      2:35:57
      Perfect. Same thing here. And this is
      2:36:00
      going to be my organization ID. And we
      2:36:02
      want to revalidate our organization
      2:36:04
      cache. So let me make sure I do that in
      2:36:05
      both places as well. And that should be
      2:36:07
      everything I need to make sure that
      2:36:08
      updating and deleting and or inserting
      2:36:11
      our organizations works just like we
      2:36:12
      expect it to. So now if I go back to
      2:36:14
      here I can import that function. I can
      2:36:17
      take our org data. I can get our ID from
      2:36:19
      it. I can also get our name which is
      2:36:20
      going to be much simpler because
      2:36:21
      organizations don't have a first and
      2:36:22
      last name. They just have a single name.
      2:36:24
      We're also going to get our image URL.
      2:36:26
      They obviously don't have a in an email
      2:36:29
      to associate with them. So that we can
      2:36:30
      get that information and we don't even
      2:36:31
      need to return anything. And that's all
      2:36:33
      we need to do to insert this
      2:36:34
      organization into our database. So now
      2:36:36
      we should be able to just send down that
      2:36:38
      event to our dev and it should work. So
      2:36:39
      we click send. We can look and we can
      2:36:41
      see our runs. You can see that so far it
      2:36:44
      doesn't look like we have anything that
      2:36:45
      ran inside here. And that's because of
      2:36:47
      course we have a failure because I don't
      2:36:48
      have these events hooked up. Let's go
      2:36:50
      all the way into our app inside of API
      2:36:53
      our route and make sure we add this as a
      2:36:55
      function. Make sure I import that. And
      2:36:58
      now we should be able to send that down
      2:36:59
      just fine and it'll work. So let's go
      2:37:01
      back into the cloud. Send that down to
      2:37:03
      our dev server. And we should see here
      2:37:05
      that we have organization created and it
      2:37:07
      successfully ran through all of our
      2:37:08
      different steps, which is exactly what
      2:37:10
      we want. And now we should see when we
      2:37:11
      go to our application and refresh. There
      2:37:13
      we go. We have our WDS comp down here
      2:37:15
      with our URL or our image. And if we
      2:37:17
      open this up, we have the option to do
      2:37:19
      all these different things such as
      2:37:20
      switching organizations. Now, you can
      2:37:21
      see I can swap or create a brand new
      2:37:23
      one. I can come into here. I can change
      2:37:25
      what plan we're on, which we don't have
      2:37:26
      a page for yet. I can change my
      2:37:28
      settings, which we don't have a page for
      2:37:29
      yet. And then, finally, I can manage all
      2:37:30
      the stuff related to my organization,
      2:37:32
      like adding new members and so on. Now,
      2:37:34
      to save us all a little bit of time,
      2:37:35
      instead of typing out the create and or
      2:37:37
      the update and delete versions, I'm
      2:37:38
      going to copy them over. I'm again going
      2:37:40
      to explain what the code is doing, but
      2:37:42
      you'll notice it's pretty much identical
      2:37:44
      to what we did inside of the organ or
      2:37:46
      the user version. So you can see we
      2:37:48
      named everything properly, hooked it up
      2:37:49
      to the updated event, and here we
      2:37:51
      verified the web hook and we call update
      2:37:52
      organization with our new information.
      2:37:54
      Same thing with delete. We set up the
      2:37:56
      delete web hook, we verified that it was
      2:37:58
      correct, and then we made sure we delete
      2:37:59
      the organization with this delete
      2:38:00
      organization function. And if there's no
    </chapter>
    <chapter title="Employer dashboard" start_time="2:38:02">
      2:38:02
      ID, we throw an error for it. So now
      2:38:03
      let's go ahead and actually implement
      2:38:05
      this dashboard page because we kind of
      2:38:07
      have all the nuts and bolts done now.
      2:38:09
      Finally, I know it's been taking forever
      2:38:10
      to get to this point, but now inside of
      2:38:12
      this employer section, we can go into
      2:38:14
      our page and instead of just rendering
      2:38:15
      out some random text, what I want to do
      2:38:17
      inside here is I want to first get the
      2:38:18
      current organization. And again, we're
      2:38:20
      going to need to make sure we wrap that
      2:38:21
      inside of a suspense. So, we're going to
      2:38:23
      have a function. We'll just define it
      2:38:25
      down here. Suspended page. Just like
      2:38:30
      that. This is going to be async, and
      2:38:32
      we're going to wrap that inside of
      2:38:33
      suspense.
      2:38:35
      And this is going to be our suspended
      2:38:36
      page. There we go.
      2:38:39
      And then inside of here, make sure we
      2:38:41
      import that. Perfect. Now, what we can
      2:38:43
      do inside of our suspended page is we
      2:38:45
      just make sure that we properly redirect
      2:38:46
      the user and do whatever else we need to
      2:38:47
      do. So, first let's try to get the
      2:38:49
      organization that they're a part of,
      2:38:50
      we'll say org ID is equal to await get
      2:38:53
      current organization. Just like that.
      2:38:55
      This gives us that ID for the
      2:38:57
      organization. And if the org ID is equal
      2:39:01
      to null, well, we should never actually
      2:39:02
      have it be equal to null, but if it is,
      2:39:04
      we'll just return null from our data.
      2:39:05
      Next, what we want to do is we want to
      2:39:07
      get all of our job listings. And
      2:39:08
      specifically, I just want to get the
      2:39:09
      most recent one. So, we'll say job
      2:39:11
      listing is equal to weight most recent
      2:39:16
      job listing. I'll call this get just so
      2:39:19
      it's a little bit more consistent. And
      2:39:21
      we're going to pass in here the
      2:39:22
      organization that we want to get this
      2:39:24
      for. And then we have an async function
      2:39:26
      for dealing with that. So, async
      2:39:28
      function
      2:39:30
      get most recent job listing takes in an
      2:39:33
      organization ID. We again want to make
      2:39:36
      sure that we use cache on this and we
      2:39:39
      want to add a cache tag. This one's
      2:39:40
      going to be a little bit more
      2:39:41
      complicated of a cache tag, but we'll
      2:39:42
      get to it in a second. For now, I'll
      2:39:44
      just leave a comment that says to-do so
      2:39:46
      that way we remember to actually do this
      2:39:47
      particular thing. And then when we
      2:39:49
      return calling our database, we want to
      2:39:51
      query on our job listing table, not the
      2:39:53
      application table. We want the job
      2:39:55
      listing table. We want to find the first
      2:39:57
      one and we want to specifically get it
      2:39:59
      where our organization ID is equal to
      2:40:02
      that organization ID. So we'll say
      2:40:04
      organization ID is equal to our org ID.
      2:40:07
      And here we're also going to do a little
      2:40:08
      bit of a sort. So we're going to say
      2:40:10
      order by and we want to get it
      2:40:11
      descending. So essentially what I want
      2:40:12
      to do is I want to get the most recently
      2:40:14
      created one. So we'll say created ad. So
      2:40:16
      whatever the most recently created job
      2:40:18
      listing was is the one that I want to
      2:40:20
      actually render first. And the way that
      2:40:22
      this get most recent job listing is
      2:40:24
      going to work is if we have a recent job
      2:40:25
      listing, I want to redirect to that
      2:40:26
      page. Otherwise redirect the user to the
      2:40:28
      new page because we don't really have
      2:40:30
      anything to show on the dashboard. So if
      2:40:32
      job listing is equal to null
      2:40:36
      then I want to redirect the user and I
      2:40:39
      want to redirect them to the employer
      2:40:42
      slashjob listings
      2:40:46
      slash new page. Otherwise
      2:40:50
      I want to redirect them to that job
      2:40:52
      listing. So we can come in here job
      2:40:53
      listings slash and whatever that job
      2:40:55
      listing ID is.
      2:40:58
      Make sure that I put that inside of
      2:41:00
      brackets. Just like that. And down here,
      2:41:02
      I only really care about the ID column.
      2:41:04
      So, I'm going to just return the ID
      2:41:05
      column and nothing else. That's just
      2:41:07
      going to save me a little bit of
      2:41:08
      bandwidth. So, I don't have to return
      2:41:09
      too much information. There we go. So,
      2:41:11
      now I'm redirecting us back to the
      2:41:12
      proper page. And you can see here, we're
      2:41:14
      getting redirected to the new page cuz
      2:41:15
      we don't have any job listings, which is
      2:41:17
      exactly what I want. Now, we're going to
      2:41:18
      go through and deal with the caching for
      2:41:20
      our job listings next. So, what I want
      2:41:21
      to do inside of our features section,
      2:41:23
      we're going to create a brand new
      2:41:24
      folder. This one is going to be job
      2:41:26
      listings. Just like that. Make sure I
      2:41:28
      spell it properly. And inside of the job
      2:41:30
      listings folder, I want to create a new
      2:41:32
      file. So that's going to be in DB. And
      2:41:34
      then we want to call this job listings.
      2:41:36
      There we go. TS. I want to do the exact
      2:41:39
      same thing inside of here. We'll create
      2:41:40
      a folder called cache. And inside of
      2:41:42
      that, I will create a new file,
      2:41:46
      job listings.ts.
      2:41:48
      And this is again going to be very
      2:41:49
      similar to what we did for our user. So
      2:41:51
      I'll take my user information, copy it
      2:41:53
      into here. But there are going to be a
      2:41:54
      few changes. So, first of all, anywhere
      2:41:56
      that I have user, I just want to change
      2:41:58
      this to say job listings. There we go.
      2:42:01
      Just like that. And let's make sure that
      2:42:03
      this is lowercase because that's how I
      2:42:05
      actually have it set up. There we go.
      2:42:07
      So, this works perfectly fine for global
      2:42:08
      job listings as well as job listings
      2:42:10
      with a specific ID. But if we look back
      2:42:12
      at the actual page where we're using
      2:42:14
      this, you'll notice we're actually
      2:42:15
      querying based on organization ID. So, I
      2:42:17
      only want to revalidate my cash when a
      2:42:19
      job listing changes for a specific
      2:42:21
      organization. Not an individual job
      2:42:23
      listing and not all job listings, only
      2:42:25
      job listings under one single
      2:42:27
      organization. So, to do that, we're
      2:42:29
      going to create another function kind of
      2:42:30
      in the middle here. That's going to be
      2:42:32
      our job listing organization tag. And
      2:42:35
      this is going to take in an organization
      2:42:37
      ID that it's going to use in place here.
      2:42:39
      And instead of a get ID tag, this is
      2:42:41
      going to be a git organization tag. Now,
      2:42:44
      this get organization tag is going to be
      2:42:46
      pretty straightforward. We're going to
      2:42:47
      come in here. Get organization tag. It
      2:42:49
      takes in our organization
      2:42:52
      ID. Just like that. Here, it's going to
      2:42:54
      be for a specific organization and for a
      2:42:57
      specific ID. So, essentially this new
      2:42:59
      tag that I created doesn't matter what
      2:43:00
      you call it. Doesn't matter what the
      2:43:02
      text you put here is. All that matters
      2:43:03
      is that this is now associated with
      2:43:05
      organization level management. So,
      2:43:07
      anytime all the things under an
      2:43:09
      organization change, it's going to
      2:43:10
      refresh this particular thing. So in our
      2:43:12
      case, whenever any job listing under an
      2:43:14
      organization changes, it's going to
      2:43:16
      refresh this cache. And now down here, I
      2:43:19
      want to make sure I call this with my
      2:43:21
      org ID. And when I pass in my parameters
      2:43:24
      here, I want to pass along an ID as well
      2:43:25
      as an org ID. So I'm going to pass it
      2:43:27
      along as an object actually,
      2:43:30
      which going to be a string. There we go.
      2:43:32
      And make sure here.
      2:43:35
      Whoops. Put that one too early. There we
      2:43:37
      go. So we have our ID and our
      2:43:39
      organization ID. And I need to make sure
      2:43:42
      that's a capital I there, capital I
      2:43:44
      there. And we can pass that along right
      2:43:45
      there. So now I'm properly revalidating
      2:43:47
      all three of those different cache tags.
      2:43:49
      So now I can use this exact tag inside
      2:43:51
      my function. So let's go all the way
      2:43:53
      back to this page here. Here's my cache
      2:43:55
      tag. Pass that in. And we're going to
      2:43:57
      pass in the org ID. So now that this
      2:43:59
      should be hopefully properly cached
      2:44:01
      using that tag that I just created. So
      2:44:03
      anytime I update job listings under an
      2:44:05
      organization, it's going to refresh this
      2:44:07
      cache. So now let's go ahead and
    </chapter>
    <chapter title="New job listing form" start_time="2:44:08">
      2:44:08
      actually create this page. So this is
      2:44:10
      going to be joblistings
      2:44:12
      slash new just like that. And we want to
      2:44:15
      create a new file called page.tsx
      2:44:17
      directly inside that folder there. And
      2:44:19
      inside this page we're going to export a
      2:44:22
      default function called new job listing
      2:44:24
      page. Whoops. Make sure I get it inside
      2:44:27
      of here. There we go. And inside of
      2:44:30
      here, we're just going to return
      2:44:31
      essentially a card on the page. So we're
      2:44:33
      going to add a div.
      2:44:36
      This is going to have some class names
      2:44:37
      on it. max width of 5 XL because we
      2:44:39
      don't need it to be super large. We're
      2:44:41
      going to put MX auto just to make sure
      2:44:42
      it's centered. And we're going to put
      2:44:44
      padding of four to make sure we space it
      2:44:45
      out from the edge of our actual space.
      2:44:47
      We just put a little text inside of
      2:44:48
      here. You can see that padding just
      2:44:50
      pushed us away from the edges, which is
      2:44:51
      what we want. Next, I'm going to put an
      2:44:53
      H1 that says new job listing. And to
      2:44:57
      make sure that the text is large and
      2:44:59
      readable, we'll come in here with a text
      2:45:00
      of 2XL, font of bold. Whoops, bold.
      2:45:04
      There we go. and we'll add some margin
      2:45:06
      on the bottom of two. There we go. We
      2:45:08
      have that nice large text. Next, we have
      2:45:10
      some padding that says this does not
      2:45:12
      post the listing yet. It just saves a
      2:45:17
      draft. That way, people know that when
      2:45:18
      they're creating this job listing, it's
      2:45:20
      not actually going to be saved for them
      2:45:21
      or it's not going to be posted to other
      2:45:22
      people. It's just going to be saved for
      2:45:24
      a draft. So, then we can come in here,
      2:45:26
      text muted, foreground, and finally
      2:45:28
      margin bottom six to give us a large
      2:45:30
      amount of space underneath this. Then
      2:45:32
      this is where our card comes in which
      2:45:34
      we're going to import from shad CN. So
      2:45:36
      let's just add in an extra terminal
      2:45:37
      here. npx
      2:45:40
      shad cn at latest. And we want to add in
      2:45:44
      specifically the card component. Give
      2:45:46
      that a second to run. It's going to ask
      2:45:47
      us to do the force where we're going to
      2:45:49
      do that. So just one second. And
      2:45:50
      actually we didn't even need to force to
      2:45:52
      install this which is great. And now we
      2:45:53
      have access to our card component. And
      2:45:56
      specifically we want to put this inside
      2:45:57
      the card content. And then this is where
      2:45:59
      we want to put our form. So this is the
      2:46:01
      text that we're going to put and this is
      2:46:02
      where we're going to import a brand new
      2:46:04
      component called job listing form which
      2:46:06
      we're going to create because we want to
      2:46:08
      share this form between our update and
      2:46:10
      our new page which is what we're
      2:46:11
      currently on. So let's create a brand
      2:46:12
      new component for that. We're going to
      2:46:14
      go into our features for our job
      2:46:16
      listings which it looks like I
      2:46:17
      accidentally put that inside my
      2:46:18
      organizations folder. There we go. So
      2:46:20
      now our job listings I want to create
      2:46:22
      some components inside of here. And
      2:46:24
      specifically I want to create a job
      2:46:25
      listing form. So we're going to say
      2:46:27
      export function job listing form. Just
      2:46:30
      like that. Now, for this form, we're
      2:46:31
      going to need to import the form, the
      2:46:33
      input, and the select components from
      2:46:36
      Shadan. So, we might as well go ahead
      2:46:37
      and get those started. We'll make sure
      2:46:38
      we force install those. That'll get
      2:46:40
      everything that we need. I want to make
      2:46:41
      sure I just do a quick save on all my
      2:46:43
      different pages to hopefully make sure
      2:46:44
      everything references properly here. I'm
      2:46:47
      going to import that job listing form.
      2:46:49
      And now, at least we have everything
      2:46:50
      rendering and we can go ahead and
      2:46:51
      actually implement what this form looks
      2:46:53
      like. So, first I want to get my form,
      2:46:55
      which is going to be from the use form
      2:46:56
      hook. Just like that. And up here, we're
      2:46:59
      going to make sure we add this as a
      2:47:00
      client component. Now, behind the
      2:47:02
      scenes, Shad CN uses React hook form.
      2:47:04
      So, that's kind of what we're working
      2:47:05
      with right here. And inside of here, I
      2:47:07
      want to add a resolver. This is going to
      2:47:08
      be using ZOD resolver. So, we can come
      2:47:10
      in here with ZOD resolver. Just like
      2:47:12
      that. And we're going to pass it in
      2:47:13
      whatever schema we're going to be using.
      2:47:15
      And it doesn't look like this wants to
      2:47:16
      autoimp import. So, we're going to
      2:47:17
      manually import this, which is Zod
      2:47:19
      resolver.
      2:47:21
      That's coming from at
      2:47:22
      hookformresolvers/zod.
      2:47:25
      There we go. That gives us the zod
      2:47:26
      resolver. and we pass in some type of
      2:47:28
      schema here which we're going to create
      2:47:30
      and we're actually going to put that
      2:47:31
      inside of its own folder. So we're going
      2:47:32
      to come in here with actions and inside
      2:47:35
      this actions folder we're going to
      2:47:36
      create a brand new file called
      2:47:37
      schemas.ts and this is because pretty
      2:47:39
      much all of our schemas are directly
      2:47:41
      tied to actions that we're taking. These
      2:47:42
      are server actions that I'm specifically
      2:47:44
      talking about server functions. So what
      2:47:46
      I want to do is I want to export a
      2:47:47
      constant called job listing schema
      2:47:51
      and this is going to be a zod object. So
      2:47:53
      we'll say Z object and we specifically
      2:47:57
      want to mention all the different
      2:47:58
      properties that we need. So for example,
      2:48:00
      we're going to have a title which is a Z
      2:48:01
      dot string.
      2:48:04
      We're going to say that it's a minimum
      2:48:05
      of one just like that. Next, we're going
      2:48:07
      to do the exact same thing with
      2:48:08
      description.
      2:48:12
      Again, it's going to be a minimum size
      2:48:14
      of one. Make sure I spell all that
      2:48:16
      properly. There we go. Then I want to
      2:48:18
      have an experience level. And experience
      2:48:21
      level is going to be a little bit
      2:48:22
      interesting because it's going to be an
      2:48:23
      enum that uses that experience levels
      2:48:25
      variable at the top there. And we want
      2:48:27
      to do this for a bunch of different
      2:48:28
      enums. So we're going to have a location
      2:48:30
      requirement
      2:48:32
      enum. And that's just right there.
      2:48:34
      Location requirements. Make sure I get
      2:48:36
      that imported properly. Then the next
      2:48:38
      one that we're going to be working on is
      2:48:40
      our type. And I believe I called this
      2:48:42
      job type. Job listing types. There we
      2:48:44
      go. Next, we're going to have our wage,
      2:48:46
      which is not an ENM. So we'll just come
      2:48:48
      in here. Wage. This is going to be a
      2:48:50
      number. It's going to be specifically an
      2:48:53
      integer. It's going to be a positive
      2:48:54
      integer. The minimum value it can be as
      2:48:56
      one. And we can also let this be
      2:48:58
      nullable because they could pass in no
      2:49:00
      value for this. Then we're going to have
      2:49:02
      a wage interval, which is another one of
      2:49:04
      these. So we're going to say wage
      2:49:05
      interval just like this.
      2:49:08
      Whoops. Wage intervals. There we go. And
      2:49:10
      again, this one can be nullable because
      2:49:12
      they could pass in no wage at all. Next,
      2:49:14
      we're going to have a state
      2:49:15
      abbreviation. So I can say state
      2:49:19
      abbreviation and this is going to be
      2:49:21
      something that can be nullable. So
      2:49:22
      instead of having a minimum value of one
      2:49:24
      here, I'm going to have it be nullable.
      2:49:26
      And I'm also going to do a little
      2:49:27
      transform here. This is kind of a trick
      2:49:29
      I like to use where we're going to take
      2:49:30
      our value and if our value.trim is equal
      2:49:34
      to an empty string, well then I want to
      2:49:36
      return the value of null. Otherwise,
      2:49:37
      I'll return what my value was. All this
      2:49:39
      does is it takes empty values and
      2:49:41
      converts them to null. That way we don't
      2:49:43
      save an empty string in our database.
      2:49:45
      Instead, we're storing null, which is
      2:49:46
      really what we're trying to represent.
      2:49:48
      I'm going to do the exact same thing
      2:49:49
      with city. It's literally exactly the
      2:49:51
      same. It's going to convert any empty
      2:49:53
      strings to null. And this is again a
      2:49:54
      nullable value. Now, the final thing
      2:49:56
      that I need to do is I need to add a
      2:49:57
      little bit of refinement to this because
      2:49:59
      the way that I have my code set up is I
      2:50:00
      have these location requirements. And
      2:50:02
      this could be in office, hybrid, or
      2:50:04
      remote. And if you specify a remote job,
      2:50:06
      you don't need a state or city to go
      2:50:08
      with it cuz it's remote. But if you have
      2:50:09
      a job that's in office or hybrid,
      2:50:11
      obviously you need a state or city where
      2:50:13
      that particular job is defined. So I'm
      2:50:15
      going to add a refinement here. And this
      2:50:17
      refinement if it returns false
      2:50:18
      essentially says that there's some type
      2:50:19
      of error. So this is going to take in my
      2:50:22
      full listing. So like all of my
      2:50:23
      properties that we have up here. And I
      2:50:25
      want to check to see a specific thing.
      2:50:27
      So I'm going to return if my
      2:50:28
      listing.loation requirement is equal to
      2:50:31
      remote. Well, that means we're fine. It
      2:50:32
      doesn't matter if there's a city or not.
      2:50:34
      But if this is not equal to remote
      2:50:36
      remote, then I want to check to see if
      2:50:37
      the listing city is not equal to null.
      2:50:40
      So essentially what this code is doing
      2:50:41
      is if I'm remote, return true. Okay,
      2:50:43
      we're fine. Otherwise, I'm checking my
      2:50:45
      city to see if it's not equal to null.
      2:50:47
      If it's not equal to null, I return
      2:50:48
      true. It's fine. If my city is null
      2:50:50
      though, then that means that I have a
      2:50:52
      non- remote job listing without a city
      2:50:54
      being defined, which is obviously a
      2:50:55
      problem because I need to have a city
      2:50:56
      associated with it. So here I'm going to
      2:50:58
      set my message equal to required for non
      2:51:02
      remote listings. And I'm specifically
      2:51:04
      going to say the path for this
      2:51:07
      is going to be an array that points to
      2:51:09
      city. That way it's going to be on my
      2:51:11
      city object itself. And I essentially
      2:51:12
      want to do the exact same thing but for
      2:51:14
      state. So down here state required for
      2:51:17
      non- remote. And this is going to check
      2:51:19
      my state property. And this is actually
      2:51:21
      state abbreviation. And down here same
      2:51:24
      thing, state abbreviation. So now I've
      2:51:26
      just refined this a little bit more to
      2:51:27
      make sure that extra conditions are met
      2:51:29
      that you can't really check in the
      2:51:30
      normal ZOD schema. So now let's go into
      2:51:32
      our job listing form here and I want to
      2:51:34
      use that job listing schema that I just
      2:51:36
      created. There we go. And now I also
      2:51:37
      need to define some default values. So
      2:51:39
      my default values are just going to take
      2:51:41
      everything I've defined and set them
      2:51:43
      essentially to empty strings or null or
      2:51:45
      whatever it needs to be. So description
      2:51:46
      is going to be an empty string by
      2:51:48
      default. My state abbreviation is going
      2:51:50
      to be null because I could have none of
      2:51:52
      that being passed in. Same thing with
      2:51:53
      city that is null. My wage is null.
      2:51:58
      My wage interval is going to be set to
      2:52:00
      yearly by default because most jobs are
      2:52:02
      salary based, at least for developers.
      2:52:04
      Experience level we're going to set to
      2:52:05
      junior. Our type is going to be set to
      2:52:08
      full-time. And then finally, our
      2:52:09
      location requirement here we're going to
      2:52:11
      set to in office as the default. So this
      2:52:13
      is all of our default values for our
      2:52:15
      form. And then we can go ahead and
      2:52:16
      actually start implementing what our
      2:52:18
      form is going to look like. So down
      2:52:19
      here, we're going to return a form
      2:52:22
      object directly coming from shad CN.
      2:52:24
      Make sure you import the correct one.
      2:52:26
      And we're going to pass it in all of our
      2:52:27
      different form properties. Then inside
      2:52:29
      here, we're going to specify a form
      2:52:31
      that's going to have our onsubmit
      2:52:32
      property, which is calling
      2:52:33
      form.andsubmit, where we pass in our own
      2:52:36
      onsubmit handler. So this is just a
      2:52:38
      function onsubmit. Right now it doesn't
      2:52:40
      do anything, but essentially this
      2:52:41
      function is going to take in all of our
      2:52:43
      data, which is going to be essentially
      2:52:44
      the type of object. So we're going to
      2:52:46
      say type of job listing schema. Just
      2:52:49
      like that. And make sure we import zod.
      2:52:51
      There we go. And now you can see that
      2:52:53
      that's giving us proper type safety on
      2:52:55
      all the data for our property. And we
      2:52:56
      can do whatever we want with it. For
      2:52:58
      now, I'll just console log data so at
      2:52:59
      least we have something inside of there.
      2:53:01
      Then I want to add some class names.
      2:53:03
      We'll say space Y of six. And I'm also
      2:53:05
      going to put an at@ container in here.
      2:53:07
      So we can style things with container
      2:53:08
      queries. And for the most part for my
      2:53:10
      application, I'm actually really heavily
      2:53:12
      using container queries. And the main
      2:53:13
      reason is is the width of my container
      2:53:15
      changes whether or not my sidebar is
      2:53:17
      open or closed. So it makes more sense
      2:53:18
      to use container queries rather than
      2:53:20
      media queries because again my container
      2:53:22
      size changes drastically based on the
      2:53:23
      size of my sidebar. Now let's go back
      2:53:26
      into our actual code and we'll start
      2:53:28
      implementing all the different form
      2:53:29
      fields that we need. Now most of my form
      2:53:31
      fields I'm going to wrap inside of a div
      2:53:33
      cuz we're going to put them side by
      2:53:34
      side. But on smaller screens we're going
      2:53:36
      to stack them vertically. So I'm going
      2:53:38
      to come in here with a class name of
      2:53:39
      grid grid columns one. And then on a
      2:53:42
      medium screen size, and this is a medium
      2:53:44
      container size specifically, I'm going
      2:53:46
      to say mid grid columns of two. So on a
      2:53:48
      really small screen, they're one column
      2:53:49
      wide, while on a larger screen, they are
      2:53:51
      two columns wide. The gap in the x
      2:53:53
      direction is going to be four, and the
      2:53:55
      gap in the y direction is going to be
      2:53:57
      six. And the reason my gap in the y
      2:53:58
      direction is six is to match this gap
      2:54:00
      right here. That way, they're exactly
      2:54:01
      the same. Then finally, we're going to
      2:54:03
      put our items at the start just so if we
      2:54:05
      have an error message below one item,
      2:54:07
      they both are still aligned at the top
      2:54:09
      instead of being aligned in the center,
      2:54:10
      which looks really strange. Now, we can
      2:54:12
      go ahead and implement each one of the
      2:54:14
      form fields that we want. And for our
      2:54:15
      form field, we need a name. In our case,
      2:54:17
      we're going to put title as the name of
      2:54:19
      this particular form field. We need to
      2:54:21
      specify our control, which is our form.
      2:54:24
      And then we have a render function,
      2:54:25
      which is where all the magic happens.
      2:54:27
      This takes in an object, which is going
      2:54:28
      to be our field. That's kind of the main
      2:54:30
      thing that we're going to care about
      2:54:31
      most of the time. And then inside of
      2:54:33
      here, what we want to do is actually
      2:54:34
      return whatever we want to render. So in
      2:54:37
      our case, we're going to render out a
      2:54:38
      form item. This form item is going to
      2:54:42
      have a form label, which is going to say
      2:54:44
      job title. That's just what displays to
      2:54:46
      the user. Our form control is going to
      2:54:48
      be the thing that allows us to control
      2:54:49
      this input. And then we're going to have
      2:54:51
      the actual input that we're rendering,
      2:54:52
      which in our case is just going to take
      2:54:54
      all the properties from our field and
      2:54:56
      use them. So this is allowing us to like
      2:54:57
      onchange set everything because as you
      2:54:59
      can see field has different properties
      2:55:01
      like onchange and so on. So if we come
      2:55:02
      in here with like field dot you can see
      2:55:04
      on blur on change value all that
      2:55:06
      different stuff. Finally we can add a
      2:55:08
      form message and this is going to show
      2:55:09
      our error message if there is an error
      2:55:11
      on our page. Now if we give that a quick
      2:55:13
      save you can see we have our job title
      2:55:14
      showing up on the lefth hand side of our
      2:55:15
      page. Next I essentially want to copy
      2:55:18
      this down cuz we're going to do the
      2:55:19
      exact same thing but this is going to be
      2:55:20
      for our wage input instead. So for our
      2:55:22
      wage input let's change this to say
      2:55:24
      wage. And this input is going to be a
      2:55:26
      little bit more complex because it's
      2:55:27
      going to be a type of number here. So
      2:55:29
      let's add our type of number. The value
      2:55:31
      is going to be equal to our field value
      2:55:33
      or an empty string. So if our wage is
      2:55:36
      null, we're just going to be passing in
      2:55:37
      an empty string here. Also, I want to
      2:55:39
      add in a few custom class names. I'm
      2:55:41
      going to say that the rounded on the
      2:55:42
      right side is going to be equal to none.
      2:55:44
      And that's because I'm going to add a
      2:55:45
      drop down on the right hand side. So I
      2:55:47
      want to make sure we don't have any
      2:55:48
      rounding conflicts between them. Lastly,
      2:55:50
      we want to set up an onchange here.
      2:55:53
      onchange.
      2:55:55
      There we go. And this onchange function
      2:55:57
      is just going to call field.onchange.
      2:56:00
      And it's going to say is the number not
      2:56:02
      a number essentially. Did I pass in
      2:56:04
      something that's not a number? So like
      2:56:06
      an empty string in our case. So e.target
      2:56:09
      dov valueue as number. There we go. So
      2:56:12
      if I don't have a valid number, then I
      2:56:14
      want to return undefined. Otherwise my
      2:56:16
      target is going to be e.target.value
      2:56:19
      as number. There we go. So essentially
      2:56:21
      I'm just trying to say hey if I don't
      2:56:23
      have a valid number return undefined as
      2:56:25
      my particular type and actually it
      2:56:26
      probably makes more sense to return null
      2:56:28
      here. So we are going to return null. So
      2:56:30
      now you can see I have my wage input and
      2:56:31
      that right hand side has no borders
      2:56:33
      which is exactly what I want because I'm
      2:56:34
      also going to add another form field
      2:56:36
      directly after this. So we can come in
      2:56:38
      here with a form field. This one is a
      2:56:40
      name is going to be wage interval.
      2:56:44
      We need to specify the control just like
      2:56:46
      we did on all the other ones. So we'll
      2:56:48
      say form.cont control. And then finally,
      2:56:50
      we have our same exact render function.
      2:56:52
      So for this one, we'll put our field in
      2:56:54
      here, and we're going to render down
      2:56:57
      kind of very similar stuff to what we
      2:56:59
      did up here. We're going to have our
      2:57:00
      label and our form control, and so on.
      2:57:01
      So we have our form label, which is
      2:57:03
      going to be wage. And we want to make
      2:57:04
      sure that we wrap this inside of a form
      2:57:06
      item,
      2:57:08
      just like that. So let's make sure we
      2:57:10
      close that off down here.
      2:57:14
      Looks like it's actually right here.
      2:57:15
      There we go. Form item. Perfect. We got
      2:57:18
      all that closed off properly. And in
      2:57:19
      this case, we're going to be using a
      2:57:20
      select instead. So here, I want to have
      2:57:23
      a select. We don't even need a label for
      2:57:24
      this one. So we're going to come in here
      2:57:25
      with a select. Our value is going to be
      2:57:28
      equal to our field value or an empty
      2:57:31
      string. Again, if we don't actually have
      2:57:33
      a value, it's going to default to an
      2:57:34
      empty string.
      2:57:36
      And we essentially want to wrap
      2:57:38
      everything inside of that. So we're
      2:57:39
      going to put that all inside of our
      2:57:40
      select here. Make sure that we import
      2:57:42
      our select from the correct location.
      2:57:44
      And then what we can do inside of our
      2:57:45
      form control is we can have our select
      2:57:47
      trigger. So we can have our select
      2:57:49
      trigger just like this. That essentially
      2:57:51
      replaces this entire input component
      2:57:53
      right here. The class name on this is
      2:57:55
      rounded left none again because I don't
      2:57:57
      want to have any rounding occur on the
      2:57:59
      lefth hand side. So we will close this
      2:58:01
      off. And inside this select trigger I'll
      2:58:03
      just have a slash symbol as well as my
      2:58:05
      select value. There we go. So
      2:58:07
      essentially whatever my value is that's
      2:58:09
      being selected is going to show up here.
      2:58:10
      So for example, it could have the text
      2:58:12
      yearly being displayed right there,
      2:58:13
      which is essentially whatever the
      2:58:14
      selected value for this is going to be.
      2:58:16
      Now we can also specify what our
      2:58:18
      selected content is. So here our select
      2:58:20
      content is going to be our wage
      2:58:22
      intervals
      2:58:24
      and we want to map through each one of
      2:58:26
      those intervals.
      2:58:28
      And we essentially want to return a
      2:58:30
      select item. Make sure we import the
      2:58:32
      correct one. There we go. Our key
      2:58:36
      is interval. Our value is our interval.
      2:58:41
      And then to render out what our interval
      2:58:43
      is, I'm actually going to create a
      2:58:44
      little handy function called format wage
      2:58:46
      interval. And we're going to pass it in
      2:58:48
      our interval just so we format this in
      2:58:50
      the correct way. So let's actually
      2:58:51
      create this function before we finish
      2:58:52
      out what the rest of this component is
      2:58:54
      going to look like. So inside my job
      2:58:55
      listings, I'm going to create a new
      2:58:56
      folder called lib. And inside of here,
      2:58:59
      I'm going to create a formatterers file.
      2:59:01
      And I'm gonna export a function with
      2:59:03
      that exact name. This is going to take
      2:59:04
      in an interval
      2:59:06
      which is a wage interval. And then we
      2:59:08
      just want to render that out. So
      2:59:09
      essentially what this code is going to
      2:59:11
      do is if the text is hourly, it's going
      2:59:12
      to render hour. If it's yearly, it's
      2:59:14
      going to render year. And then this
      2:59:15
      little code just throws an error if we
      2:59:16
      enter something invalid. And the nice
      2:59:18
      thing about it is it'll actually throw a
      2:59:19
      TypeScript error if we forget to put one
      2:59:21
      of our different values in our case,
      2:59:23
      which is really handy and useful. So now
      2:59:25
      back into here, we can import this
      2:59:26
      particular function. And now we should
      2:59:28
      see that that is rendering out properly.
      2:59:29
      And you can see that it's it doesn't
      2:59:31
      look great because I think I imported
      2:59:32
      something from the wrong location. One
      2:59:34
      of these came from Radex. Yep. I need to
      2:59:36
      fix that. These should be imported from
      2:59:38
      Shad CN and not from Radex directly.
      2:59:41
      There we go. So now you can see when I
      2:59:43
      drop down on that, it looks really good.
      2:59:44
      But I need to make sure they're side by
      2:59:45
      side. To do that, I can come all the way
      2:59:47
      up into here where I have my form label
      2:59:49
      and right below it, I can just create a
      2:59:51
      div with a class name of flex. And I can
      2:59:53
      wrap essentially all of this different
      2:59:55
      content just like that. And now you can
      2:59:57
      see that they are side by side. Also,
      2:59:58
      I'm going to add a form description.
      3:00:01
      Description. There we go. That just says
      3:00:04
      optional. So, we know that this is an
      3:00:05
      optional field that they don't have to
      3:00:07
      pass in. So, now to finish out the rest
      3:00:08
      of the rows, we kind of just need to
      3:00:10
      copy what we've done, paste it down, and
      3:00:11
      change around a few values. So, inside
      3:00:13
      of here, let's paste this down and work
      3:00:14
      on the very next property, which is
      3:00:16
      where we're going to deal with city and
      3:00:17
      state. So, this one's going to be a
      3:00:19
      little bit more complicated cuz we
      3:00:20
      essentially need another level of grid
      3:00:22
      nesting because city, state are going to
      3:00:23
      show up right next to each other, except
      3:00:24
      for on really small screens, they're
      3:00:26
      going to show up stacked vertically. So,
      3:00:28
      I'm going to create another div. It's
      3:00:29
      going to have almost the exact same
      3:00:30
      styles. So, I'm going to kind of copy
      3:00:32
      this over to do a little bit of
      3:00:33
      cheating. The only difference is where
      3:00:34
      our break points are going to be. So,
      3:00:36
      instead of breaking on the medium screen
      3:00:38
      size, we're going to break on the extra
      3:00:40
      small screen size. And our gap in the X
      3:00:42
      direction is going to be slightly
      3:00:43
      smaller so that these elements look
      3:00:44
      slightly closer together. Then, we can
      3:00:46
      go ahead and we can add in the form
      3:00:48
      field specifically for our city just
      3:00:50
      like this. And we can come in here and
      3:00:52
      say city on this one. And since our
      3:00:54
      value could be null, we need to make
      3:00:55
      sure that of our field. show you is
      3:00:57
      null. Then we return an empty string
      3:00:59
      instead. There we go. So now we have our
      3:01:01
      city showing up on just one section.
      3:01:03
      Just like that. We can create another
      3:01:05
      form field. This one is going to be a
      3:01:06
      select. So it's going to be kind of
      3:01:08
      similar to what we did here. So I'm
      3:01:09
      going to copy this one in particular.
      3:01:12
      Going to paste that down as our next
      3:01:13
      option. And this is going to be for our
      3:01:15
      state abbreviation. There we go. This
      3:01:17
      one is going to have a label. So we're
      3:01:19
      going to come in here with a form label
      3:01:20
      that says state. So now we have our
      3:01:22
      state showing up. Now we just need to
      3:01:23
      make sure we specify what the values are
      3:01:25
      going to be. So, for our select trigger,
      3:01:27
      we don't actually need to do anything
      3:01:28
      fancy. All we just want to do inside of
      3:01:30
      here is add a full width on that so at
      3:01:31
      least it fills the entire screen size,
      3:01:33
      which is what we want. Next, inside of
      3:01:35
      our select content, we want to have
      3:01:36
      essentially all of our state select
      3:01:38
      items. Now, to loop through all the
      3:01:39
      different states that we have, I'm going
      3:01:41
      to be using a JSON file. So, I'm just
      3:01:43
      going to copy this over. It'll be in the
      3:01:44
      GitHub repository linked in the
      3:01:46
      description, but if we paste that down,
      3:01:47
      make sure that's in the right folder.
      3:01:48
      You can see that this just associates
      3:01:50
      essentially a name here or a name with
      3:01:52
      the abbreviation. Just one to one
      3:01:54
      mapping between the two. And I'm going
      3:01:56
      to create a really simple helper
      3:01:57
      function that allows me to convert this
      3:01:58
      into some objects for my select option.
      3:02:00
      So inside of my features, inside the
      3:02:02
      components, I'm going to create a brand
      3:02:03
      new one called state select items
      3:02:07
      just like that. TSX. I'm just going to
      3:02:09
      copy the code for it because it's
      3:02:10
      relatively straightforward. As you can
      3:02:12
      see, all that we're doing inside of here
      3:02:13
      is we're taking the states which is from
      3:02:15
      that JSON file. We're converting it into
      3:02:17
      an array by using object. entries. That
      3:02:19
      gives us an abbreviation and a name. And
      3:02:21
      we're creating a select item for each
      3:02:23
      one of those different options. Super
      3:02:24
      straightforward code. Now, what we need
      3:02:26
      to do is use that inside of our form. So
      3:02:28
      here, instead of using our wage
      3:02:29
      intervals, essentially we're going to
      3:02:31
      use that custom component that we just
      3:02:32
      created. That will loop through all of
      3:02:34
      our states for us. So now, if I click
      3:02:36
      over here, you can see that every single
      3:02:37
      one of these states shows up. Now, one
      3:02:39
      thing we need to modify is currently
      3:02:40
      when we try to select an option, it's
      3:02:41
      not being saved. And that's because we
      3:02:43
      need to set up the on value change
      3:02:45
      property. And we can for now just set
      3:02:47
      that to field on change. That's not
      3:02:49
      quite going to work perfectly, but it's
      3:02:51
      going to work well enough that we can
      3:02:52
      select something and it shows up. We
      3:02:54
      need to do the exact same thing up
      3:02:55
      inside of our wage section as well. So
      3:02:57
      here where we have our select, we want
      3:02:59
      to make sure that we specify the on
      3:03:01
      value change. And this one's going to be
      3:03:02
      a little bit different because we
      3:03:04
      actually have the option that maybe null
      3:03:06
      could be passed along for this one. So
      3:03:07
      I'm going to come in here with a value
      3:03:09
      and we'll just say value or we're going
      3:03:13
      to pass along null just to make sure
      3:03:14
      it's properly showing up as the correct
      3:03:16
      value. We don't ever get undefined and
      3:03:17
      empty string will show up as null. But
      3:03:19
      we again shouldn't have that happen. And
      3:03:20
      you can see we can swap between the two.
      3:03:22
      That's working just fine. Now the
      3:03:24
      problem that we're having is when I
      3:03:25
      select Arkansas, I can't unselect this.
      3:03:27
      There's no way to unselect this option.
      3:03:29
      So I need to add my own custom ability
      3:03:31
      to unselect a particular option. So
      3:03:33
      inside of my select items, I'm going to
      3:03:34
      add a brand new select item. This is
      3:03:36
      going to be a select item which has a
      3:03:38
      value which we're going to set to none
      3:03:40
      select value just to kind of denote
      3:03:43
      we're not actually selecting anything.
      3:03:44
      I'm going to add a class name to this of
      3:03:46
      text muted foreground and I'm going to
      3:03:48
      set this to the value of clear. Now
      3:03:50
      let's just create this variable. We'll
      3:03:51
      do it way at the top of our page up
      3:03:53
      here.
      3:03:55
      And we'll just set it equal to none.
      3:03:56
      Doesn't really matter what the text on
      3:03:58
      this is because it's only used
      3:03:59
      internally. But now you can see we have
      3:04:01
      that none select value. And if we
      3:04:03
      actually open this up, you can see we
      3:04:04
      have that clear option right there,
      3:04:05
      which allows us to set this to clear.
      3:04:07
      Now, there's two problems. One is that
      3:04:08
      clear option always shows up. I don't
      3:04:10
      want it to show up. And two, it's
      3:04:11
      setting our value to clear, which we
      3:04:12
      don't really want. So, first, if our
      3:04:15
      field value is not equal to null, then
      3:04:18
      what I want to do is I want to render
      3:04:20
      out this clear option. So, if we have a
      3:04:21
      value, show me the clear option. But if
      3:04:23
      we don't have a value, I don't want to
      3:04:25
      show it. So in order to make sure we
      3:04:26
      change from a null or change to a null
      3:04:29
      value up here where we're doing our
      3:04:30
      field on change, I want to get our
      3:04:32
      value. I want to see if my val is equal
      3:04:34
      to the none selected value option, then
      3:04:36
      I want to render something in
      3:04:37
      particular. And we'll actually do this
      3:04:39
      directly inside my field on change. So
      3:04:41
      if I have the none value selected, I
      3:04:43
      want to return null. Otherwise, I want
      3:04:45
      to return my value. So essentially, if I
      3:04:47
      select the clear option, change my value
      3:04:49
      to null instead of changing it to clear.
      3:04:51
      So now we should see if I click clear,
      3:04:53
      it actually clears out my state input.
      3:04:54
      and that clear option is no longer
      3:04:56
      there. And then as soon as I select
      3:04:57
      something, clear is there and I can
      3:04:58
      clear it out again. Now, the next
      3:04:59
      section that we're going to be doing
      3:05:00
      right after this, let me just minimize
      3:05:02
      that down. Copy this over. Everything
      3:05:04
      inside this wage section, we don't need
      3:05:06
      anymore. So, I'm going to completely
      3:05:07
      delete that and all this other stuff
      3:05:10
      associated with it. I'm going to paste
      3:05:11
      in our next option, which over here is
      3:05:13
      not going to be state, but instead it's
      3:05:15
      going to be our location requirement.
      3:05:17
      So, we can say location requirement. And
      3:05:19
      inside of this location requirement, we
      3:05:21
      kind of need to do a pretty similar
      3:05:22
      thing, but this one we can't clear out.
      3:05:24
      So we don't need to worry about clearing
      3:05:25
      out this information. We can just pass
      3:05:27
      along the field on change just like
      3:05:29
      this. That's going to work fine. Same
      3:05:31
      thing up here. Field value is going to
      3:05:33
      be passed along just fine because we
      3:05:34
      don't have an option for this to be a
      3:05:36
      null value. Then we have our select
      3:05:38
      value. We make sure it fills up the full
      3:05:39
      width. And down here instead of doing
      3:05:41
      this section here, we just want to take
      3:05:43
      our location requirements.
      3:05:46
      There we go. And we want to map through
      3:05:47
      each one location requirement. And I'd
      3:05:50
      want to just render that out as a select
      3:05:52
      item.
      3:05:54
      There we go. Our key is our location
      3:05:56
      requirement.
      3:05:58
      Value is the location requirement. And
      3:06:01
      then I want to format our job location.
      3:06:04
      Actually, we'll just call it format
      3:06:06
      location requirement. There we go.
      3:06:09
      And pass it in our location requirement.
      3:06:11
      And again, we're going to go into our
      3:06:12
      formatterers and export a function with
      3:06:15
      that name. It's going to take in
      3:06:18
      a location requirement.
      3:06:21
      And I'll just copy over the code for
      3:06:22
      this one again because it's super
      3:06:23
      straightforward. We're just converting
      3:06:24
      to some human readable names based on
      3:06:26
      what we did. And again, we're making
      3:06:27
      sure we have that fancy little
      3:06:28
      TypeScript check right here to make sure
      3:06:30
      we actually have all of them defined. So
      3:06:32
      now let's import that real quick. And we
      3:06:34
      should hopefully see we now have the
      3:06:35
      option to select whatever location
      3:06:37
      requirement we want. I'm going to
      3:06:38
      minimize down some of our fields that we
      3:06:40
      have right here. So we're going to
      3:06:41
      minimize that down. Minimize that down.
      3:06:42
      And for this next one, I'm going to copy
      3:06:44
      it in. I'll go through all the code
      3:06:45
      exactly, but it's super super basic.
      3:06:47
      We've done this on the last couple. So
      3:06:48
      you can see here we're doing our job
      3:06:50
      type one. Same thing with our field and
      3:06:52
      value on changes. The only difference is
      3:06:53
      we're looping through each of our types
      3:06:55
      and we're going to be calling a format
      3:06:56
      job type function which we're going to
      3:06:58
      create. Same thing down here. Experience
      3:06:59
      level. Loop through our experience
      3:07:01
      levels. Call the format experience level
      3:07:03
      function. Super straightforward. That's
      3:07:04
      exactly what these two columns are for.
      3:07:06
      They're pretty much identical to our
      3:07:07
      location requirement. All we need to do
      3:07:09
      is define the formatterers for them.
      3:07:11
      Again, I feel okay copying and pasting
      3:07:12
      these in because if we look at these
      3:07:14
      real quick, let me just make sure I
      3:07:15
      import experience level and job listing
      3:07:18
      type. You'll see that all I'm doing is
      3:07:20
      taking the string and making a human
      3:07:21
      readable version. Super straightforward
      3:07:23
      exactly what's going on here. So now if
      3:07:25
      I come back into here, I can import
      3:07:27
      these two functions. Just like that.
      3:07:30
      Give that a save. And now you can see we
      3:07:32
      can change between the different job
      3:07:33
      types that we have exactly like we want.
      3:07:35
      And to make sure everything's mobile
      3:07:36
      responsive, you can see as I shrink down
      3:07:38
      my screen size, things are changing to
      3:07:39
      stack above and below each other, which
      3:07:41
      is why we have all those container query
      3:07:42
      related styles for our application. Now,
      3:07:44
      we can minimize down this row and we're
      3:07:46
      on our final attribute inside of here,
      3:07:48
      which is going to be a form field. And
      3:07:49
      this is going to be for the description.
      3:07:51
      So, we can come in here with
      3:07:53
      description. Make sure we close that
      3:07:55
      off. Our control, whoops, spelled that
      3:07:57
      wrong. Control is our form. And then
      3:08:00
      finally, we have our render function.
      3:08:02
      And this one is going to be a little bit
      3:08:03
      more complex than the rest of them
      3:08:05
      because we're actually going to be using
      3:08:06
      a markdown editor directly for this. So
      3:08:08
      inside of here, we're going to create
      3:08:10
      our form item. And then we're going to
      3:08:12
      have our form label.
      3:08:14
      This is going to say description. This
      3:08:16
      one's going to take up the full width,
      3:08:18
      which is why we don't have those extra
      3:08:19
      divs. Then we have a form control. And
      3:08:22
      inside here, I want to render out a
      3:08:23
      markdown editor, which is a component
      3:08:25
      we're going to create in a little bit.
      3:08:27
      So, we'll take all of our field
      3:08:29
      properties and we're going to take
      3:08:31
      whatever our markdown should look like
      3:08:33
      and that's going to be field.value. Just
      3:08:35
      like that. And there we go. Now, we can
      3:08:37
      just make sure if we have an error, it
      3:08:39
      shows up in this field or the form
      3:08:40
      message section. Now, this markdown
      3:08:42
      editor is going to be built on top of
      3:08:43
      the MDX editor library just to make this
      3:08:46
      a lot easier to work with. So, let's go
      3:08:47
      ahead and install the library that we're
      3:08:49
      going to be using. We're most likely
      3:08:51
      going to need to force install this. So,
      3:08:52
      I might as well just come in here with a
      3:08:54
      force. There we go. That way, it's going
      3:08:56
      to be force installed. And you can see
      3:08:58
      that they have specific instructions on
      3:08:59
      how to get this to work inside of the
      3:09:01
      app router, which is really handy. So,
      3:09:03
      now that we have all that installed,
      3:09:04
      let's go into our application. What I
      3:09:05
      want to do is I want to go into my
      3:09:07
      components folder. I want to create a
      3:09:08
      brand new folder inside of here
      3:09:09
      specifically for my markdown related
      3:09:11
      components. And I'm going to create a
      3:09:12
      brand new component called markdown
      3:09:15
      editor tsx. Just like that. And this is
      3:09:18
      where the specific section right here
      3:09:19
      comes in. In order to do this, we need
      3:09:21
      to make sure we import it. We're using a
      3:09:23
      dynamic utility with SSR equal to false.
      3:09:26
      So this is actually quite simple to do.
      3:09:28
      All I need to do is I want to import
      3:09:29
      dynamic from next slashdnamic.
      3:09:34
      There we go. And then I want to export a
      3:09:36
      constant variable called markdown
      3:09:37
      editor. This is going to be my
      3:09:38
      component. I'm going to call dynamic.
      3:09:40
      And all I want to do is import whatever
      3:09:43
      that function is going to be. And make
      3:09:44
      sure I actually call this as a function.
      3:09:46
      There we go.
      3:09:48
      And import is just going to point to the
      3:09:50
      location where my file is that's going
      3:09:52
      to contain my markdown editor. So I'm
      3:09:53
      going to call that markdown editor with
      3:09:55
      an underscore at the front. And all we
      3:09:58
      need to do to make sure that this works
      3:09:59
      properly is to disable SSR. So we're
      3:10:01
      going to set SSR equal to false. That's
      3:10:03
      kind of what this particular line of
      3:10:04
      code right here is telling us to do. Now
      3:10:06
      what we can do is create this markdown
      3:10:08
      editor file, which I'm going to create
      3:10:09
      right here, underscoremarkdowned.tsx.
      3:10:13
      And we want to make sure we mark this as
      3:10:14
      a default export. So we're going to
      3:10:16
      export this as a default function mainly
      3:10:18
      because when we import dynamically write
      3:10:20
      this, it imports the default export by
      3:10:22
      default. So we'll call this internal
      3:10:25
      markdown editor just so we don't
      3:10:26
      accidentally use this anywhere else.
      3:10:28
      This is going to take in a ref. It's
      3:10:30
      going to take in a class name and it's
      3:10:31
      going to take in a bunch of props for
      3:10:33
      everything we want to do. And this
      3:10:34
      specifically is going to take in my MDX
      3:10:39
      MDX editor props. Just like that. Make
      3:10:42
      sure I get that imported properly.
      3:10:47
      MDX editor props
      3:10:52
      from and that is at MDX editor and the
      3:10:54
      rest of the props that I want to be able
      3:10:55
      to have is my ref. So we can just come
      3:10:57
      in here and say ref is equal to ref from
      3:11:00
      react and it's the MDX editor methods.
      3:11:03
      There we go. That is exactly what we
      3:11:06
      want to make sure we do to get our
      3:11:07
      actual ref being imported properly. And
      3:11:09
      this again is all inside the
      3:11:10
      documentation as you can see right here.
      3:11:12
      I've just updated it slightly because
      3:11:13
      you don't need to worry about forward
      3:11:14
      ref anymore because we're using React
      3:11:16
      19. Next, what we can do is we can
      3:11:18
      render out our MDX editor. And this MDX
      3:11:20
      editor is a rather simple component that
      3:11:22
      is going to take in essentially a bunch
      3:11:24
      of different configurations as well as
      3:11:26
      all the different props we want. So,
      3:11:27
      first we can pass in our props that
      3:11:29
      we're getting in and then we can pass in
      3:11:31
      all the rest. So, class name is going to
      3:11:32
      be easy. So, we're going to come in here
      3:11:33
      with CN. This is going to take our
      3:11:35
      markdown class names which are going to
      3:11:37
      be some classes I define in a little
      3:11:39
      bit. Kind of our default class names.
      3:11:41
      Then if we're in dark mode, we want to
      3:11:43
      specifically pass along the dark theme
      3:11:45
      style that allows us to actually do dark
      3:11:47
      mode. And then we're going to pass in
      3:11:49
      any additional class names we have. So
      3:11:51
      first of all, I can come up to the top
      3:11:52
      of our function and I can make sure that
      3:11:55
      this is actually being returned. There
      3:11:57
      we go. So I can say const is dark mode
      3:12:01
      is equal to use is dark mode. And I can
      3:12:04
      just call that function. Also, this
      3:12:07
      should be a client component because
      3:12:08
      everything on here is a client related
      3:12:10
      object. Just like that. I also want to
      3:12:12
      make sure I pass along my ref. So, I can
      3:12:14
      come in here. Ref is equal to ref. Now,
      3:12:17
      these markdown class names are something
      3:12:18
      we're going to use in multiple places.
      3:12:19
      So, I'm going to paste that in. We're
      3:12:21
      going to be using the pros feature
      3:12:22
      directly built into Tailwind, which
      3:12:24
      allows us to actually automatically
      3:12:25
      style things that are in a markdown
      3:12:27
      format really easily. So, if we look at
      3:12:28
      how we install this Tailwind library, we
      3:12:30
      can just install this as a dev
      3:12:31
      dependency. Going to need to most likely
      3:12:33
      force install this. That's going to run
      3:12:35
      fine. And then we just add this as a
      3:12:36
      plugin directly into our Tailwind file.
      3:12:38
      So that's inside of our app, inside of
      3:12:40
      our global CSS at the very top of our
      3:12:42
      page. We can just add in that plugin
      3:12:45
      just like this. And now we have the
      3:12:46
      plug-in support specifically for
      3:12:48
      Tailwind typography. And this is all we
      3:12:50
      need to do. And now all these pro styles
      3:12:51
      are going to work automatically, which
      3:12:53
      is great. Now kind of the last thing to
      3:12:54
      specify is how we want to configure what
      3:12:56
      this MDX editor is going to look like.
      3:12:58
      So first of all, I want to say that we
      3:12:59
      want to suppress HTML processing. I
      3:13:01
      don't want to allow these organizations
      3:13:03
      to pass HTML into their markdown. That's
      3:13:05
      not something I want. Completely
      3:13:06
      suppress that. That essentially is going
      3:13:08
      to escape and sanitize any HTML. Then we
      3:13:11
      need to specify the plugins that we
      3:13:12
      want. And all these are built in which
      3:13:14
      is really nice. For example, we want the
      3:13:15
      headings plugin that allows them to
      3:13:17
      specify what headings they want to use.
      3:13:19
      We want the lists plugin that allows
      3:13:21
      them to create list. We want the quote
      3:13:23
      plugin. We want the thematic break
      3:13:25
      plugin that's just allowing them to
      3:13:27
      create an HR essentially. We want the
      3:13:29
      markdown shortcut plugin. Just allowing
      3:13:31
      them to do different shortcuts for
      3:13:33
      markdown. The table plugin. And then
      3:13:35
      finally, we're going to have the toolbar
      3:13:37
      plugin. And this allows them to
      3:13:38
      essentially have a nice little toolbar
      3:13:40
      that has different options they can
      3:13:41
      click on. Very similar to like Microsoft
      3:13:42
      Word. So inside of here, we specify our
      3:13:45
      toolbar contents, which is going to be a
      3:13:47
      function. We'll make this into an arrow
      3:13:48
      function.
      3:13:51
      There we go. And inside of here, we have
      3:13:53
      a bunch of pre-built components we can
      3:13:55
      use. For example, we have the block type
      3:13:57
      select component we're going to use. We
      3:13:59
      have the bold italic component,
      3:14:03
      the list toggle component, the insert
      3:14:07
      thematic break component, and then
      3:14:09
      finally the insert table component.
      3:14:11
      There we go. So, these are all the
      3:14:12
      different ways that they can modify our
      3:14:14
      code inside the toolbar section. So,
      3:14:16
      these are essentially enabling the
      3:14:17
      feature in markdown and this section is
      3:14:19
      enabling the button for them to interact
      3:14:21
      with that in the toolbar itself. And
      3:14:23
      that's all we need to do to get the
      3:14:24
      editor to work. You can see it's really
      3:14:25
      just about plugging in a bunch of
      3:14:27
      different things. Now, we want to make
      3:14:28
      sure that we import everything properly.
      3:14:30
      So, let's go over here and make sure
      3:14:32
      that we import this particular
      3:14:34
      component. And we should hopefully be
      3:14:35
      able to see it show up on the side of
      3:14:36
      our page. We have a few problems with
      3:14:38
      our TypeScript code or not our
      3:14:39
      TypeScript, our Tailwind code. Does this
      3:14:42
      need to be imported maybe up here, down
      3:14:44
      here, or maybe our import didn't work
      3:14:46
      properly? No. Looks like our import
      3:14:47
      worked. We may need to restart our
      3:14:48
      server. I'll try that just to see if
      3:14:50
      that works real quick because we did add
      3:14:52
      a brand new plugin. That could be
      3:14:53
      something that kind of messes with the
      3:14:54
      tailwind. It's not sure how to handle
      3:14:55
      that. So, let's try to refresh that to
      3:14:57
      see if that works properly. And of
      3:14:58
      course, the issue is I forgot a
      3:15:00
      semicolon at the end of my plugin. That
      3:15:01
      should hopefully fix the issue. There we
      3:15:03
      go. Now, everything works. Obviously, as
      3:15:04
      you can see, our styles are not perfect
      3:15:06
      here. I want to go ahead and add my own
      3:15:08
      custom styles to make this look a little
      3:15:09
      bit better. So, inside of here, we can
      3:15:11
      scroll all the way down to the very
      3:15:12
      bottom inside of our base layer. And I
      3:15:14
      want to add specific styles for my NDX
      3:15:16
      editor because there's a bunch of
      3:15:18
      different things that we can actually
      3:15:19
      style built into the editor. So, we can,
      3:15:20
      for example, style the root content
      3:15:23
      editable.
      3:15:25
      And for this section, we're actually
      3:15:26
      going to be applying a ton of different
      3:15:28
      styles because these are essentially all
      3:15:30
      the styles that Tailwind removes by
      3:15:31
      default. We're going to be adding back
      3:15:32
      in. Now, I'm going to go through what
      3:15:33
      each of these is doing, but if we save,
      3:15:35
      we should hopefully at least see
      3:15:36
      something showing up a little bit better
      3:15:37
      on the side of our screen in a little
      3:15:38
      bit. But essentially, what we're
      3:15:40
      applying is we're adding a border to
      3:15:41
      this by giving it the input color. So,
      3:15:43
      it's just a color. We're saying that if
      3:15:45
      it has focus visible, we're adding
      3:15:46
      another border around it that's a little
      3:15:48
      bit better. Essentially, I just copied
      3:15:49
      the styles from the tail or from the
      3:15:51
      shad CN input and paste them into here.
      3:15:53
      So, you can see here we're adding a ring
      3:15:54
      around it. So, essentially a focus
      3:15:56
      state. We're giving it a little bit of
      3:15:57
      rounding on the edges. No rounding on
      3:15:59
      the top because we have a toolbar that's
      3:16:00
      going to be on the top. We get rid of
      3:16:02
      any background that it has. Add a little
      3:16:04
      bit of padding. Give it a shadow. And
      3:16:05
      then finally, we're just doing a little
      3:16:06
      bit of an animation on the colors and
      3:16:08
      the box shadow and so on. And also here,
      3:16:10
      we're adding more of that ring around
      3:16:12
      it. And then some just disabled
      3:16:13
      properties and so on. So, for the most
      3:16:15
      part, I just took the Tailwind or the
      3:16:16
      Shad CN input component styles, pasted
      3:16:19
      them into here, and then modified them
      3:16:20
      slightly. Also, I want to come in here
      3:16:22
      with one simple style, and I just want
      3:16:24
      to remove the outline from other
      3:16:27
      elements that are going to be rendered
      3:16:28
      inside of here. This just helps to
      3:16:29
      remove some outlines that are there from
      3:16:31
      the styling of the actual application
      3:16:32
      that we don't actually need. Now, also
      3:16:34
      to make sure we get some default styles
      3:16:35
      as well, I'm going to go into our layout
      3:16:37
      for our entire page. Right below where
      3:16:39
      we import our global CSS, I'm going to
      3:16:41
      import the styles for this markdown
      3:16:42
      editor as well. That'll give us a bunch
      3:16:44
      of default styles. So, at least we have
      3:16:45
      some styles being rendered. And if I
      3:16:47
      give this a quick save, we should
      3:16:48
      hopefully see some of our other styles
      3:16:49
      being rendered as well. I don't see our
      3:16:51
      styles being applied though. And that's
      3:16:52
      I believe because this should have no
      3:16:53
      hyphen between it. It should be one
      3:16:55
      word. And now if I give that a save, you
      3:16:56
      can see it just added some of those
      3:16:58
      styles. We get the nice focus state
      3:16:59
      around it. Essentially the exact same
      3:17:01
      thing as we get for the inputs up here.
      3:17:02
      You can see I pretty much just copy
      3:17:03
      pasted it. Now our toolbar looks
      3:17:05
      terrible. So we need to make sure we
      3:17:06
      styled that next. So let's come down
      3:17:08
      here. MDX editor- toolbar. Luckily, the
      3:17:12
      styles we need to apply are much more
      3:17:14
      minimal. So, we'll come in here. We'll
      3:17:15
      add a background of the card color.
      3:17:17
      Border of the card color. We'll give it
      3:17:19
      a rounded medium style. We're also going
      3:17:22
      to make sure that we round it. Border on
      3:17:24
      the bottom is none. And we're going to
      3:17:26
      make sure that's marked as important
      3:17:27
      because we need to override the styles
      3:17:28
      built into it. Shadow is going to be
      3:17:31
      small. And then we're going to make sure
      3:17:32
      these elements wrap on a really small
      3:17:33
      screen size. So, you can see that just
      3:17:35
      kind of cleaned that up a little bit.
      3:17:36
      And if I go to a very small screen size,
      3:17:38
      you can see my elements are just
      3:17:40
      wrapping down to the next page instead
      3:17:41
      of overflowing my container. Finally,
      3:17:43
      the last thing I want to do is to make
      3:17:44
      sure my popup right here works properly.
      3:17:46
      So, I can come into here, MDX, Whoops.
      3:17:52
      MDX editor
      3:17:55
      popup
      3:17:57
      container. We're going to set that to be
      3:18:00
      a zindex of 50 just so that if we're in
      3:18:03
      like a dialogue or something, it
      3:18:04
      properly shows up over top of
      3:18:05
      everything. And then finally, you'll
      3:18:07
      notice our dark theme inside of here
      3:18:09
      does not work properly. So, let's come
      3:18:10
      in here. We're going to select that dark
      3:18:12
      theme class, and we're going to change
      3:18:13
      the base page background variable, which
      3:18:17
      is a variable built into the actual MDX
      3:18:19
      editor that we can change. I'm going to
      3:18:21
      change it to that muted variable. I'm
      3:18:23
      going to set that to important. So, now
      3:18:25
      if I just give that a quick save, notice
      3:18:26
      I'm getting an error. I believe it's
      3:18:27
      because I have a space here that
      3:18:29
      shouldn't be here. Essentially, flex
      3:18:31
      wrap has a space between it maybe. Let
      3:18:33
      me see. Flex wrap. There we go. I just
      3:18:36
      had a interesting space there that
      3:18:37
      shouldn't have been there. So now you
      3:18:38
      can see that that has worked and that
      3:18:40
      this has now changed to that dark color
      3:18:41
      when we're in our dark theme, which is
      3:18:42
      what we want. Now the last thing we need
      3:18:44
      to do is just add a button for
      3:18:45
      submitting this form. So we're going to
      3:18:46
      go back to our job listing form. Scroll
      3:18:49
      all the way down to the very bottom here
      3:18:51
      and we can add a simple button.
      3:18:53
      This is going to be nice and easy part
      3:18:55
      of our application where we add in a
      3:18:56
      button. It's going to be disabled
      3:18:59
      if we are currently submitting our form.
      3:19:01
      So formstate
      3:19:03
      issubmitting.
      3:19:06
      There we go. That make sure it's
      3:19:08
      disabled. We're also going to set the
      3:19:10
      type of this to be submit. Even though
      3:19:12
      that's the default, I like to be
      3:19:13
      explicit. And then we're going to make
      3:19:14
      sure it fills the full width. So we'll
      3:19:16
      set the W to full. So now we have that
      3:19:18
      button down here. Let's add some text
      3:19:19
      inside of here that says create job
      3:19:21
      listing. Just like that. So now it'll
      3:19:22
      create a job listing when we click on
      3:19:24
      that button. Right now it doesn't do
      3:19:25
      anything, but you can see we do get our
      3:19:26
      errors at least, which is really nice.
      3:19:28
      Now, one thing you notice is these are
      3:19:29
      not super nice error messages. String
      3:19:31
      must contain at least one character.
      3:19:32
      Let's go ahead and actually try to fix
      3:19:34
      that up a little bit. We'll go into our
      3:19:36
      schema and where we have our min, we're
      3:19:38
      just going to say required. So that way
      3:19:40
      it's a little bit nicer of an error
      3:19:41
      message for those. So now if we click
      3:19:43
      create, you can see it just says
      3:19:44
      required, required, required for non-
      3:19:46
      remote listings, and so on. Now, one
      3:19:47
      thing I'm noticing is my state error
      3:19:49
      message is not showing up. I most likely
      3:19:50
      forgot to include it inside of my job
      3:19:52
      listing section. So, let's go back to
      3:19:54
      that form where we were just working
      3:19:55
      inside of. I'm going to go wherever I
      3:19:57
      have my state, which is this second one.
      3:20:00
      So, this is the city. And then here's my
      3:20:01
      state abbreviation. And I most likely
      3:20:03
      just forgot to put my form message down
      3:20:05
      here, which I did. So, now you can see
      3:20:06
      that's showing up properly. There we go.
      3:20:08
      Fixed that little error that we had.
      3:20:09
      Now, the very next thing is to make sure
      3:20:10
      the rest of our button is working. And I
      3:20:12
      want to add a loading state when we're
      3:20:13
      in the loading state for this button.
      3:20:15
      Right now it doesn't do anything but we
      3:20:17
      can imagine that this onsubmit function
      3:20:19
      it's going to be asynchronous and we're
      3:20:20
      just going to make it do a simple wait.
      3:20:22
      So we're going to say new promise
      3:20:25
      resolve set timeout resolve 1 second. So
      3:20:29
      now you can see this button is going to
      3:20:30
      be disabled for 1 second whenever we
      3:20:32
      click on this particular button.
      3:20:33
      Obviously we need to make sure our data
      3:20:35
      is set properly. So let's just come in
      3:20:36
      here and set some information. Click
      3:20:38
      create. You can see it's disabled for 1
      3:20:39
      second and then it comes back to normal.
      3:20:40
      Now we want to add a little bit of a
      3:20:42
      loading state to this. So I'm going to
      3:20:43
      create a function or custom component
      3:20:46
      called loading swap which is going to
      3:20:47
      take in an is loading property which we
      3:20:49
      already know is based on our form if
      3:20:51
      it's submitting or not. So what this is
      3:20:52
      going to do is it's going to return a
      3:20:53
      loading spinner or it's going to return
      3:20:55
      whatever text we have inside of here
      3:20:56
      depending on if the loading state is
      3:20:58
      true or false. So let's go ahead and
      3:20:59
      create that component. We'll come into
      3:21:01
      our components folder because this one's
      3:21:02
      kind of generic. So we can just create
      3:21:04
      it here.
      3:21:06
      Export function with that name. And we
      3:21:08
      know is loading is the only variable
      3:21:10
      that we care about inside of here.
      3:21:15
      and it's going to be a boolean. Also, I
      3:21:18
      guess we have children, so we might as
      3:21:19
      well use those as well.
      3:21:23
      There we go. Now, this loading swap is
      3:21:25
      going to be using one of my favorite
      3:21:26
      features built into CSS for when you
      3:21:28
      want to make something an equal size as
      3:21:30
      another thing. So, like when I want to
      3:21:32
      swap between two different things and I
      3:21:33
      want to make them equally sized, this is
      3:21:35
      going to be the perfect place for doing
      3:21:36
      that. So, I'm going to come into here. I
      3:21:38
      want to return a div. And this div is
      3:21:40
      going to be a grid. I want to center all
      3:21:42
      my items. So we'll say item center and
      3:21:44
      justify
      3:21:46
      center just like that. And we'll say
      3:21:48
      actually specifically justify items
      3:21:49
      center. So perfectly centered inside of
      3:21:51
      our container. I'm going to have another
      3:21:52
      div. This is going to be a class name.
      3:21:54
      We're going to put a bunch of class name
      3:21:56
      stuff inside of here. Whoops. Make sure
      3:21:58
      I get that down on the new line there.
      3:21:59
      Close that off. There we go. I want to
      3:22:02
      call CN specifically because I'm going
      3:22:04
      to take a column start of one, a column
      3:22:07
      end of one, a row start of one, and a
      3:22:10
      row end of one.
      3:22:13
      Start one. Just like that. So
      3:22:14
      essentially, I'm saying this div takes
      3:22:16
      up my first cell in my grid. I now want
      3:22:18
      to copy that down and do the exact same
      3:22:20
      thing for a second grid. I want them
      3:22:22
      both to take up the exact same space in
      3:22:24
      my grid. This way, they overlap each
      3:22:26
      other and I'll only show one element at
      3:22:28
      a time. The nice thing about this though
      3:22:29
      is when I swap one element for the other
      3:22:31
      element, it'll make sure whatever the
      3:22:33
      larger of the two elements is is how
      3:22:35
      much space this thing will take up. This
      3:22:37
      is really important because normally
      3:22:38
      when you swap your text in a button, the
      3:22:40
      button will change size. But with this
      3:22:42
      particular case, we won't have anything
      3:22:44
      changing size when we swap between them.
      3:22:46
      I'll show you exactly what that looks
      3:22:47
      like once we finish writing out the rest
      3:22:48
      of the code. So in the is loading state,
      3:22:51
      this one I want to be invisible when
      3:22:53
      we're loading. So we're going to say
      3:22:54
      invisible. Otherwise, it's going to be
      3:22:56
      set to visible. So invisible makes it so
      3:22:58
      it doesn't show up on the screen,
      3:22:59
      doesn't show up for screen readers, but
      3:23:01
      it still takes up space, and that's the
      3:23:02
      important part. It takes up space
      3:23:04
      without actually being on the screen.
      3:23:06
      That's how we make sure the button
      3:23:07
      doesn't change size. Then finally, I'm
      3:23:09
      actually going to have the ability to
      3:23:10
      pass in some custom class names. So
      3:23:12
      we'll come in here with class name, just
      3:23:14
      like that. Paste it down, and we'll make
      3:23:16
      it an optional string. Again, this is
      3:23:18
      something I do on almost all of my
      3:23:19
      components. And this is where we render
      3:23:21
      out our children. So by default, if
      3:23:22
      we're not loading, we render the
      3:23:24
      children. Otherwise, I essentially want
      3:23:25
      to do this exact same thing inside of
      3:23:27
      here. So, if we're loading, this one is
      3:23:30
      going to be visible. Otherwise, it's
      3:23:31
      going to be invisible. I think we need
      3:23:33
      to put one more div in here to make this
      3:23:35
      work. No, we don't have to. It's just
      3:23:36
      getting some weird styles. Oh, cuz I
      3:23:38
      need to return up here. There we go. And
      3:23:39
      inside of here, I want to return a
      3:23:41
      loading icon. So, I'll say loader to
      3:23:44
      icon. We'll say the class name on this
      3:23:46
      is going to be animate spin. There we
      3:23:48
      go. So, now we're gonna get a nice
      3:23:49
      little spinning animation in the case
      3:23:51
      that we're loading. So, let's see if
      3:23:52
      this actually works. If I click on this
      3:23:54
      button, you can see, of course, I need
      3:23:55
      to pass in some information. We'll make
      3:23:57
      that a remote job. There we go. Create
      3:23:58
      job listing. You can see it spins and
      3:24:00
      then it goes back to normal. Now, to
      3:24:01
      show you how this actually works in the
      3:24:03
      case of buttons being a different size,
      3:24:04
      we'll remove this full width. So, you
      3:24:06
      can see the button is exactly the size
      3:24:07
      of our create job listing text. When I
      3:24:09
      click on it, you can see the size of my
      3:24:11
      button does not change when I change
      3:24:12
      that loading spinner state. While if I
      3:24:15
      actually was just swapping the text,
      3:24:16
      you'll see that I get an error. So, for
      3:24:18
      example, I'll come in here and I'll just
      3:24:20
      swap the text with nothing else. none of
      3:24:21
      our other fancy tricks that we did. So,
      3:24:23
      here we go. If we are submitting the
      3:24:25
      form, then I want to do that loader to
      3:24:28
      icon. Otherwise, I want to do my text
      3:24:31
      that I had right here. There we go.
      3:24:34
      Comment this out. So, now you can see
      3:24:35
      our button still looks the same right
      3:24:37
      now. If we go ahead and we submit some
      3:24:38
      information, click create, you'll see
      3:24:40
      how my button shrinks down in size
      3:24:41
      because of the fact that I'm swapping
      3:24:44
      the text without keeping the original
      3:24:45
      size of the old thing. That's why I
      3:24:47
      really like this loading swap component.
      3:24:49
      I use it all over the place in different
      3:24:50
      applications. It's a really neat trick
      3:24:52
      to be able to keep your button the same
      3:24:53
      size. Now, for this component, it
      3:24:55
      doesn't matter as much because we're
      3:24:56
      going to be using a full width button,
      3:24:58
      but it still does give us the nice
      3:24:59
      little spinner. Now, let's go ahead and
      3:25:00
      actually make this do something when we
      3:25:01
      submit it. Because right now, all that's
      3:25:03
      happening is it's logging out some data
      3:25:04
      and doing a fake weight, which we don't
      3:25:06
      really want. We want to actually submit
      3:25:07
      this data and saving our database. So,
      3:25:09
      inside of the folder where we have our
      3:25:11
      job listing actions, I want to create a
      3:25:13
      new file called actions.ts.
      3:25:15
      And this is where we're going to put our
      3:25:16
      actions that we're going to use. and
      3:25:18
      this is use server. So these are our
      3:25:19
      actual server actions. We're going to
      3:25:21
      export an async function called create
      3:25:24
      job listing. This is going to take in
      3:25:26
      unsafe data because we don't know that
      3:25:28
      this is safe data. It's coming from the
      3:25:29
      client. It could be a bunch of bogus
      3:25:31
      data. We don't know. So we need to make
      3:25:32
      sure we actually test this data, but we
      3:25:34
      know it should hopefully be in the type
      3:25:36
      of job listing schema. So we can say job
      3:25:39
      listing schema
      3:25:42
      and this should say type of. There we
      3:25:44
      go. Close that off. So that's the shape
      3:25:46
      that we hope that our data is supposed
      3:25:48
      to be in because it's coming from our
      3:25:50
      client. But we don't know if that's the
      3:25:51
      shape that the data is going to be in.
      3:25:53
      Now what I want to do is first get the
      3:25:54
      organization for the user. So we can say
      3:25:56
      org ID is equal to a weight get current
      3:25:58
      organization. Just like that. Then if
      3:26:01
      our org ID is equal to null, well
      3:26:04
      obviously we can't create this. So we'll
      3:26:05
      return an error down to the user. We'll
      3:26:08
      just do it as an object that says error
      3:26:10
      true message. And the message will just
      3:26:14
      be a simple thing that's like you don't
      3:26:15
      have permission to do this or something
      3:26:16
      along those lines. You don't have
      3:26:17
      permission to create a job listing. Then
      3:26:19
      what I want to do is I want to get my
      3:26:21
      success and my data by checking to see
      3:26:23
      if this data matches our schema. So
      3:26:25
      we'll do a safe parse on our unsafe
      3:26:27
      data. Then we can check to see if our
      3:26:30
      success is false. If success is false,
      3:26:32
      well then there is just going to be an
      3:26:33
      error. So we want to return that to the
      3:26:35
      user. There is an error creating your
      3:26:36
      job listing. Finally, we can go ahead
      3:26:38
      and actually insert the job listing
      3:26:39
      because we know that we have an
      3:26:41
      organization. We know the data was
      3:26:42
      successfully parsing our you know schema
      3:26:44
      so it matches our schema. So we can say
      3:26:47
      that we want to get a job listing by
      3:26:49
      calling insert job listing. It's a
      3:26:52
      function we're going to create in a
      3:26:53
      little bit. We'll pass along all of our
      3:26:54
      data. We'll pass along the organization
      3:26:57
      ID and the status for this is going to
      3:26:59
      be draft because it's going to be the
      3:27:01
      first instance of this. Finally, if that
      3:27:03
      was all successful, then I want to
      3:27:04
      redirect the user to the employer/job
      3:27:08
      listings
      3:27:10
      slash whatever the job listing ID is.
      3:27:12
      So, we can redirect them to that new
      3:27:14
      page. Now, we want to create a database
      3:27:16
      function for this. So, inside of our
      3:27:17
      database, we have job listings right
      3:27:19
      here. And I want to create that insert
      3:27:20
      function. So, I'm just going to copy
      3:27:22
      from our users because it's going to be
      3:27:23
      pretty similar. So, right here, copy
      3:27:25
      that code from user. Go into here. This
      3:27:27
      is going to be insert job listing. Just
      3:27:30
      like that. our job listing table.
      3:27:34
      Same thing here. Make sure I import my
      3:27:37
      database. There we go. My value here is
      3:27:40
      going to be my job listing.
      3:27:44
      And we want to revalidate my job listing
      3:27:47
      cache based on the job listing ID. But
      3:27:49
      we also need the organization ID.
      3:27:51
      Luckily, we have that though. So, we can
      3:27:53
      say ID
      3:27:55
      and organization ID is
      3:27:57
      joblisting.organization
      3:27:58
      ID. There we go. So now we're properly
      3:28:00
      revalidating everything. It looks like
      3:28:02
      here I'm getting an error cuz my ID here
      3:28:04
      could be a string or undefined. So I
      3:28:06
      need to make sure I get the ID returned
      3:28:08
      from here instead because when I create
      3:28:09
      an job listing, it doesn't always have
      3:28:11
      an ID. So we can just say here const new
      3:28:14
      listing. This is going to be in an array
      3:28:15
      because when you call insert, it always
      3:28:17
      returns to an array. We don't need to
      3:28:18
      worry about on conflict do nothing. So
      3:28:20
      we can completely remove that line. But
      3:28:22
      we do want to return specific values. In
      3:28:24
      our case, I want to return an ID, which
      3:28:26
      is my job listing table ID. And I want
      3:28:30
      to return an organization ID, which is
      3:28:32
      my joblisting.organization
      3:28:34
      ID. So now I can pass in my new listing
      3:28:36
      here. And that's going to pass along
      3:28:37
      that information. And I can also return
      3:28:39
      this data as well. So now I have my new
      3:28:41
      listing, which is just an ID and an
      3:28:43
      organization ID that allows me to
      3:28:45
      revalidate my code. And then where I'm
      3:28:47
      using this actual function, which is
      3:28:48
      directly here inside my action, I'm
      3:28:50
      getting that job listing and using the
      3:28:51
      ID specifically returned from it. So you
      3:28:54
      can see if I spell this properly now
      3:28:55
      everything is hooked up and we should be
      3:28:57
      able to actually create a job listing by
      3:28:58
      doing this and be redirected to the
      3:29:00
      correct page if everything works
      3:29:01
      successfully. So what we want to do is
      3:29:03
      we want to go all the way back to where
      3:29:04
      we have this form right here and inside
      3:29:07
      this form is where we're going to do our
      3:29:08
      code. So instead of doing this await of
      3:29:10
      a promise I want to actually call this
      3:29:11
      function which is going to be called
      3:29:13
      create job listing. I'm going to pass
      3:29:16
      along my data and we're going to get a
      3:29:18
      response by calling a wait on that. Now
      3:29:20
      this could return to us an error so we
      3:29:22
      should probably handle that. So if our
      3:29:23
      response is an error, then we want to
      3:29:25
      render out a toast message. And we're
      3:29:26
      going to use shad CN for this again. So
      3:29:28
      we can come in here, go all the way down
      3:29:30
      to where we're importing our shad CN
      3:29:32
      components. We want to do our shad CN
      3:29:34
      component right here. This one is going
      3:29:36
      to be our sauner component, which is the
      3:29:38
      toast library that we're going to be
      3:29:39
      using. Make sure we force install that.
      3:29:41
      Everything else should work properly.
      3:29:43
      There we go. And now what I want to do
      3:29:45
      is I want to call toast, which comes
      3:29:46
      from sonner. There's an error version of
      3:29:48
      it. And I want to pass in my message. So
      3:29:50
      now if we have an error, it's going to
      3:29:51
      return to us that error message. So we
      3:29:53
      can actually test to see what this looks
      3:29:55
      like with an error first. So inside of
      3:29:57
      my actions here, I'm just going to say
      3:29:58
      if my org ID is not equal to null, it's
      3:30:00
      going to return an error. So it should
      3:30:02
      return an error every time because we do
      3:30:03
      have an organization ID. So if I click
      3:30:05
      create job listing, you can see it
      3:30:07
      rendered real quick, but it looks like
      3:30:09
      it didn't quite do what we expected it
      3:30:10
      to do. Actually, I believe it did work,
      3:30:12
      but we actually need to make sure that
      3:30:13
      we render our toast properly by going
      3:30:15
      into our layout for our entire
      3:30:16
      application. And down here somewhere in
      3:30:19
      our body, we need to render the wrapper
      3:30:20
      for our toast to render. So we can just
      3:30:23
      say toaster just like this. And this is
      3:30:24
      where our toast are going to render. Now
      3:30:26
      hopefully if we change around what our
      3:30:28
      code looks like to actually render
      3:30:29
      something, click create. You can see you
      3:30:31
      don't have permission to create a job
      3:30:32
      listing. Shows up right here as our
      3:30:33
      error text. So let's go ahead and change
      3:30:35
      that back so it actually does succeed
      3:30:37
      because we obviously don't have an error
      3:30:39
      in this particular case. And I want to
      3:30:40
      create a brand new job listing. We'll
      3:30:42
      call it front-end developer. We'll say
      3:30:44
      that it's a remote job. And we'll just
      3:30:46
      say test description. And we might as
      3:30:47
      well make that into a heading. And
      3:30:49
      actually, it looks like when I do that
      3:30:50
      that the text color is incorrect. That's
      3:30:52
      not what we want our text color to be.
      3:30:54
      We'll fix that actually. Now, let's go
      3:30:55
      into our global CSS. And we want to make
      3:30:57
      sure that the text color for everything
      3:30:58
      is going to be inherit. And actually,
      3:31:00
      when I dive into the error, it's
      3:31:01
      specifically dealing with tailwind and
      3:31:03
      not actually the MDX editor. It's that
      3:31:05
      the tailwind styles for my pros inverted
      3:31:07
      are not being applied properly. So,
      3:31:09
      let's make sure we go back to my
      3:31:11
      markdown editor. This is where I'm
      3:31:12
      checking my dark mode properly. That's
      3:31:15
      fine. my markdown class names. It should
      3:31:17
      be getting my dark mode and inverting
      3:31:18
      that with this pros invert. But it looks
      3:31:20
      like this is not working as I expect.
      3:31:21
      Now, I'm not 100% sure why it's not
      3:31:23
      working in this particular case, but one
      3:31:25
      thing that we can do to make it
      3:31:26
      relatively easy is if we're in dark
      3:31:28
      mode, we can just set pros invert
      3:31:31
      manually just like this. And that'll at
      3:31:33
      least invert those colors for us. And we
      3:31:35
      can see we have a test description with
      3:31:36
      some stuff underneath of it. And that's
      3:31:38
      working fine. I'm not 100% sure why
      3:31:40
      Tailwind is not picking up on that
      3:31:41
      properly, but at least we have a
      3:31:42
      workaround. So now let's go ahead and
      3:31:44
      create that job listing. And you can see
      3:31:45
      it created it and we got redirected to
      3:31:47
      the page. We just don't have a listing
      3:31:48
      page for this yet. So to at least get it
    </chapter>
    <chapter title="Employer job listing page" start_time="3:31:49">
      3:31:50
      so we can see what's going on on our
      3:31:51
      page. Let's go over to our job listing
      3:31:53
      section. Let's create a new folder.
      3:31:54
      We'll call job listing ID. Inside of
      3:31:57
      here, we'll create a page.tsx. We'll
      3:32:00
      just export a default function. Job
      3:32:03
      listing page. And this job listing page
      3:32:07
      is going to return null. So at least we
      3:32:09
      can just see something on our page. We
      3:32:10
      have our sidebar showing up and it's all
      3:32:12
      rendering properly within it which is
      3:32:13
      great. So now let's work on this job
      3:32:15
      listing page. Then we can work on
      3:32:16
      editing and that's going to give us a
      3:32:17
      great starting place to be able to build
      3:32:19
      out the rest of our application rather
      3:32:21
      quickly hopefully. So let's create a
      3:32:22
      function here for our suspended page.
      3:32:24
      There we go. And then we have our job
      3:32:26
      listing page up here which is going to
      3:32:27
      take in our params. And we know that
      3:32:29
      these params are going to be a promise.
      3:32:32
      So we can say params just like that. And
      3:32:34
      then we could type out whatever our
      3:32:35
      params are. And we know that it's going
      3:32:37
      to be a promise that returns to us a job
      3:32:40
      listing
      3:32:43
      ID as a string.
      3:32:45
      There we go. Close that off. Now we have
      3:32:47
      our params. And essentially I just want
      3:32:49
      to wrap this in a suspense. There we go.
      3:32:52
      And I can say job listing. And actually
      3:32:55
      I called this suspended page. There we
      3:32:56
      go. And the suspended page needs to take
      3:32:59
      in our params. So imagine we'll make a
      3:33:01
      type called props. And that props type
      3:33:03
      is just this. There we go.
      3:33:06
      And then I can just call this props.
      3:33:12
      There we go. And now what I can do is I
      3:33:14
      can say that I want to get my params
      3:33:16
      down here
      3:33:18
      from my props type. Now what I can do is
      3:33:21
      I can first check to see do we have an
      3:33:22
      organization because if we don't
      3:33:24
      obviously we have a problem. So we'll
      3:33:25
      get the current organization.
      3:33:27
      Make this a little bit bigger so it's
      3:33:28
      easier to see. And if we don't
      3:33:33
      There we go. If that's equal to null,
      3:33:35
      then we can just return null because we
      3:33:37
      shouldn't be able to get to this point.
      3:33:38
      We could return undefined or not found
      3:33:39
      or whatever we want. We're just going to
      3:33:40
      return null because again, we shouldn't
      3:33:42
      be able to get to this particular place
      3:33:43
      without an organization.
      3:33:46
      Then we're going to get our job listing
      3:33:47
      ID by calling await params.
      3:33:51
      Next, we want to get our job listing.
      3:33:54
      There we go. And that is calling await
      3:33:56
      get job listing which is a function
      3:33:59
      we'll create where we pass in our job
      3:34:02
      listing ID as well as most importantly
      3:34:04
      the org ID because we only want to be
      3:34:06
      able to render job listings for specific
      3:34:08
      organizations. If you're in an
      3:34:09
      organization you can't access someone
      3:34:11
      else's job listings. So if job listing
      3:34:14
      is equal to null well then we'll return
      3:34:16
      not found just like that. And then
      3:34:18
      finally we have that function get job
      3:34:21
      listing. It's going to be an
      3:34:22
      asynchronous function. Takes in a job
      3:34:25
      listing ID and an organization ID.
      3:34:30
      Just like that. Might as well just call
      3:34:32
      this org ID. Save us a few characters.
      3:34:35
      We're going to cache this. And for the
      3:34:37
      cache tag on this one, we're
      3:34:38
      specifically going to be getting the job
      3:34:41
      listing ID tag. And we'll pass it in
      3:34:43
      that ID, which we might as well just
      3:34:44
      call it ID. There we go. Then what we
      3:34:46
      can do is we can return
      3:34:49
      database.query query job listing table,
      3:34:53
      not the application table. There we go.
      3:34:55
      Find the first and we want to
      3:34:58
      specifically get it where two different
      3:35:00
      things are equal. So we have our job
      3:35:02
      listing table ID is equal to our ID and
      3:35:06
      then also where our job listing table
      3:35:11
      organization ID is equal to our org ID.
      3:35:13
      There we go. We're just checking to make
      3:35:15
      sure that both of those are true before
      3:35:16
      we get our job listing information. So
      3:35:18
      then once we have a job listing, well,
      3:35:19
      we can actually render out what that job
      3:35:21
      listing should look like. So let's do a
      3:35:23
      quick return here with a div. This class
      3:35:24
      name is going to be space y6 to space
      3:35:27
      out all of our different content
      3:35:29
      vertically. We're going to make a
      3:35:30
      maximum size of 6xl so it doesn't get
      3:35:33
      too terribly large on really large
      3:35:34
      screen sizes. Make sure it's centered.
      3:35:37
      And then we're also going to be using
      3:35:38
      some padding as well. And we're going to
      3:35:40
      put this inside of its own container
      3:35:41
      again to do some container queries on.
      3:35:44
      Next, we're going to have a div that's
      3:35:45
      going to contain even more information,
      3:35:46
      like our header type information. So,
      3:35:48
      this one, we're going to have a class
      3:35:49
      name of flex. We're going to put the
      3:35:52
      items in the center. We're going to
      3:35:54
      justify some space between these items,
      3:35:56
      a gap of four to give them quite a bit
      3:35:58
      of space from each other. And on a max
      3:36:00
      screen size of 4 XL, so a quite large
      3:36:02
      screen size, we're going to convert this
      3:36:03
      over to a column based layout. And
      3:36:05
      again, on the max screen size of 4 XL,
      3:36:08
      we're going to change the items to be at
      3:36:10
      the start instead of in the center. So,
      3:36:12
      this allows us to have the things that
      3:36:13
      would be side by side instead be
      3:36:15
      vertically stacked. So, that way all of
      3:36:16
      our job information is going to be
      3:36:18
      vertically stacked with all of our
      3:36:19
      buttons. Those are the two different
      3:36:20
      things we're going to put inside of
      3:36:21
      here. So, this first section of our div
      3:36:23
      is going to contain all of our job
      3:36:25
      information. And the second div is going
      3:36:26
      to change all of our buttons for
      3:36:28
      editing, updating, deleting, so on, all
      3:36:30
      that different stuff. So, inside of
      3:36:31
      here, I want to have an H1, which
      3:36:32
      contains our job listing.title. Just
      3:36:35
      like that. And I want to add some
      3:36:36
      classes to this so it's a little bit
      3:36:38
      easier to see. So, we can say text to
      3:36:40
      XL, font bold, and we're going to change
      3:36:42
      the tracking to tight to put the letters
      3:36:44
      a little closer together. So, now if I
      3:36:45
      save, you can see front-end developer is
      3:36:47
      showing up at the top. Next, I want to
      3:36:49
      have a div that's going to contain all
      3:36:50
      the different badges that we have. So,
      3:36:52
      going to put a class name, flex flex
      3:36:55
      wrap,
      3:36:57
      a gap of two, and a margin on the top of
      3:36:59
      two. And then here is where we're going
      3:37:00
      to render out our badges. And of course,
      3:37:02
      we need to make sure we import this from
      3:37:04
      Shad CN. So, let's add the badge
      3:37:06
      component as well. And we'll need to
      3:37:08
      make sure we force that most likely.
      3:37:09
      There we go. So now we have the ability
      3:37:11
      to actually render out a badge. And
      3:37:13
      let's just close that off for now. And
      3:37:15
      inside of here, I'm going to call format
      3:37:17
      job listing status. There we go. And
      3:37:21
      this is going to take in my job listing
      3:37:22
      status. So this is going to be like
      3:37:24
      active, published, and so on. So import
      3:37:27
      this badge just like that. And let's
      3:37:28
      create this format function for us. I'm
      3:37:30
      going to kind of close out of all these
      3:37:31
      tabs we're not using now just to clean
      3:37:33
      up some space. Again, minimize this down
      3:37:35
      into our job listing formatterers and
      3:37:38
      we're going to create a formatter for
      3:37:40
      that.
      3:37:42
      Now, I'll just copy this over because
      3:37:43
      it's just like all the other ones.
      3:37:45
      Again, we're just doing essentially a
      3:37:47
      loop through to make sure we change the
      3:37:49
      value to something that is more readable
      3:37:50
      in English than like underscore
      3:37:52
      published. There we go. So, now we can
      3:37:54
      format that job listing status so we at
      3:37:56
      least get the first badge showing up.
      3:37:57
      And I'm actually going to change the
      3:37:58
      default styles for a badge cuz I'm not a
      3:38:00
      huge fan of how they look by default.
      3:38:02
      So, we're going to go into our badge
      3:38:03
      here, and specifically I want to scroll
      3:38:04
      up to all these variant styles up here.
      3:38:06
      So, first of all, the thing that I want
      3:38:08
      to do is I want to add a brand new
      3:38:09
      variant specifically for size. So,
      3:38:10
      inside of here, I want to add a variant
      3:38:12
      for size. We're going to have a small
      3:38:13
      size, which is going to be text extra
      3:38:15
      small. We're going to use this to make
      3:38:18
      our SVGs a certain size. So, we're going
      3:38:19
      to say SVG
      3:38:22
      size 3. We're going to do two padding on
      3:38:25
      the right and left. And then padding on
      3:38:26
      the top and bottom is going to be 0.5.
      3:38:29
      So, rather small. I'm going to copy that
      3:38:30
      down a couple times because it's going
      3:38:31
      to be pretty similar. We're just going
      3:38:32
      to be changing around the values for
      3:38:34
      medium and large. Now, small is what the
      3:38:37
      default is from shad CN. I'm going to
      3:38:39
      make our default medium instead. So,
      3:38:41
      we're going to have slightly bigger than
      3:38:43
      normal sizes for our badges. So, here
      3:38:45
      text of small. This is going to be a
      3:38:47
      size of four. We're going to use a
      3:38:49
      padding of three here and a padding of
      3:38:50
      one here. This will be 1.5. This will be
      3:38:53
      five or sorry, four and this will be
      3:38:56
      five. And then finally, our text is
      3:38:58
      going to be the base size here. So, at
      3:38:59
      least we have all of our sizing done.
      3:39:01
      Now, up here, we just need to remove
      3:39:02
      essentially all the things that deal
      3:39:04
      with sizes. So, like padding on the left
      3:39:05
      and right, we need to get rid of that.
      3:39:07
      Text small, we need to get rid of that.
      3:39:09
      Also, we need to come through here and
      3:39:10
      make sure that our SVG sizes are
      3:39:12
      removed. So, we'll get rid of that. And
      3:39:13
      I think that should be about everything
      3:39:15
      that we need to get removed. You can see
      3:39:16
      immediately when I save that, we have a
      3:39:18
      larger size here because by default, our
      3:39:19
      size is now medium, which is larger than
      3:39:21
      the normal default size in Shad CN. So
      3:39:23
      now we can come back through here and
      3:39:24
      get the rest of our badges that we want.
      3:39:26
      But we're actually going to be using
      3:39:27
      these badges in a lot of different page
      3:39:29
      places in our application. So I'm going
      3:39:30
      to export them into a separate
      3:39:32
      component. Job listing badges. And this
      3:39:35
      is essentially just going to take in my
      3:39:36
      job listing. So we'll pass in our full
      3:39:40
      job listing just like that. There we go.
      3:39:42
      And now I want to create this component.
      3:39:44
      We're going to put it essentially inside
      3:39:45
      of our job listing component section.
      3:39:50
      We're going to export that as a function
      3:39:51
      just like that. And inside of here,
      3:39:53
      we're going to be taking in that job
      3:39:54
      listing.
      3:39:57
      And we're going to type that as well. So
      3:39:59
      we'll say just like this, it's going to
      3:40:00
      be a job listing. And we could say that
      3:40:03
      it's going to be the type of our job
      3:40:06
      listing table.infer
      3:40:09
      select just like that. And that will
      3:40:10
      give us all the props for our job
      3:40:12
      listing. But we don't want all the props
      3:40:13
      for our job listing. We only want
      3:40:15
      specific ones. So I'm going to come
      3:40:16
      through here and pick just the
      3:40:18
      properties that we want. And I'm
      3:40:19
      actually just going to copy down the
      3:40:21
      different properties that we want. So
      3:40:22
      I'll paste that in. Again, mostly just
      3:40:24
      so you don't have to watch me type it
      3:40:25
      all out. But we're going to be getting a
      3:40:26
      wage based one, a state and city based
      3:40:28
      one, a type based, an experience level,
      3:40:30
      location requirement, and if it is a
      3:40:31
      featured job or not. Those are the
      3:40:33
      things we want to show in our job
      3:40:34
      listing sections. Next, what I want to
      3:40:37
      do is I want to get my badge props
      3:40:39
      because we're going to be rendering a
      3:40:40
      bunch of badges with all the exact same
      3:40:42
      props. So we're going to get our badge
      3:40:43
      props. to give us type safety. We're
      3:40:45
      going to say that it's going to satisfy
      3:40:46
      the component props for the type of
      3:40:50
      badge just like this. There we go. That
      3:40:53
      way, at least we get some autocomplete
      3:40:55
      inside of here. And specifically, I want
      3:40:56
      the variant for these all to be outline.
      3:40:59
      And I want to add some specific class
      3:41:01
      names for them. And the class name here
      3:41:02
      is going to be that if it is featured.
      3:41:04
      And let me make sure that I change that
      3:41:05
      a little bit. So, it should be I can
      3:41:07
      just come up here. Job listing is
      3:41:10
      featured. There we go. That way we
      3:41:12
      extract out that prop. So if it is
      3:41:13
      featured then what I want to do is I
      3:41:15
      want to make my border primary
      3:41:19
      35.
      3:41:22
      And actually I want to change why this
      3:41:24
      is happening. The reason I am putting
      3:41:25
      this border on here is because when I
      3:41:27
      have these details on a job listing
      3:41:28
      that's featured the featured job listing
      3:41:30
      has a different background. But that's
      3:41:31
      only in one place in our app, not all
      3:41:33
      the places. So instead, like I do with
      3:41:35
      most of my components, I'm going to take
      3:41:36
      in some custom class names. So we'll
      3:41:38
      come in here. We'll add in our own
      3:41:39
      custom class name section. We'll make
      3:41:41
      this a string that is optional and
      3:41:44
      instead I'm going to pass in some custom
      3:41:45
      class names here. So we can say that our
      3:41:47
      class name is just going to be equal to
      3:41:49
      whatever those custom class names are.
      3:41:51
      So now we can go ahead and actually
      3:41:52
      define what all of our different stuff
      3:41:53
      is going to look like. So we can come in
      3:41:54
      here with a return and we want to just
      3:41:56
      return a bunch of different badges. So
      3:41:58
      let's come in here with a badge just
      3:42:00
      like that. Make sure we close that off.
      3:42:02
      And then we want to put our text inside
      3:42:04
      of here. Let's put format wage as our
      3:42:06
      first one. So not format wage interval.
      3:42:07
      This is actually going to be format wage
      3:42:09
      which takes in our wage and our wage
      3:42:11
      interval.
      3:42:12
      Make sure I spell all that properly.
      3:42:14
      There we go. And these should be coming
      3:42:16
      from up here. So, let me say wage wage
      3:42:19
      interval. There we go. Whoops.
      3:42:22
      State abbreviation city type experience
      3:42:26
      level location requirement. There we go.
      3:42:28
      And we can move is featured down to the
      3:42:30
      bottom. That way it's in the same order
      3:42:31
      as it is down here. So, there we go.
      3:42:33
      Now, we have this format wage function
      3:42:34
      that we're going to want to create.
      3:42:36
      First of all, let's take our badge props
      3:42:38
      though and pass it along here. So all of
      3:42:39
      our badges would look exactly the same.
      3:42:41
      And we also want to only render this if
      3:42:43
      we have a wage. So if wage is not equal
      3:42:45
      to null and wage interval is not equal
      3:42:48
      to null, then we can render out this
      3:42:50
      component.
      3:42:52
      Otherwise, don't render out this badge.
      3:42:53
      So now let's create this as our
      3:42:55
      formatter. So, inside of our formatter,
      3:42:58
      we'll export a function called format
      3:43:02
      wage, which takes in a wage and a wage
      3:43:04
      interval,
      3:43:06
      which is a wage interval. There we go.
      3:43:08
      I'm just going to copy the code in for
      3:43:10
      this one again because it's rather
      3:43:11
      straightforward. All we're doing is
      3:43:12
      we're creating an internationalization
      3:43:14
      number formatter in the English format
      3:43:15
      because this is an English US-based job
      3:43:18
      board. We're styling the currency as
      3:43:19
      US-based currency with no decimal points
      3:43:22
      unless they are actually needed. And
      3:43:23
      then if it's hourly, we put per hour at
      3:43:25
      the end. Otherwise, we just render the
      3:43:27
      yearly wage as is because most people
      3:43:29
      when they see a salary, assume it's a
      3:43:30
      yearly based salary. Now, we can come in
      3:43:33
      here, say format wage, get rid of that.
      3:43:35
      We can come over here, import this. So,
      3:43:37
      at least we should be able to see that
      3:43:38
      badge showing up. And right now, I don't
      3:43:40
      see anything. And that's because this
      3:43:41
      job doesn't have any salary associated
      3:43:43
      with it. Also, inside of my badge, I
      3:43:45
      want to add an icon. So, we're going to
      3:43:46
      say banknote icon just so we have a
      3:43:49
      little bit of an icon that shows us that
      3:43:50
      this is a moneybased icon that we want
      3:43:52
      to render on the screen. I then am
      3:43:54
      essentially going to copy that and do
      3:43:55
      the exact same thing for state. So, if
      3:43:57
      our state
      3:44:00
      abbreviation is not equal to null or our
      3:44:04
      city is not equal to null, then we want
      3:44:06
      to render out the city version. And for
      3:44:08
      this one, I'm going to use a map pin
      3:44:10
      icon. There we go. And for the class
      3:44:13
      name on this one, I'm going to put a
      3:44:14
      size of 10 just because this one is a
      3:44:16
      little bit smaller of an icon. So, I
      3:44:18
      want to bump it up a little bit to make
      3:44:19
      it look more in line with the rest of
      3:44:20
      our icons. Now, the reason I'm allowing
      3:44:22
      this to work if state abbreviation is
      3:44:24
      equal to null or if city is equal to
      3:44:25
      null. Let me make sure I get my
      3:44:26
      parenthesis right on this.
      3:44:30
      There we go. The reason I'm allowing
      3:44:31
      either to be null and only one needing
      3:44:33
      to be allowed is because you could
      3:44:35
      specify just a state, like this is just
      3:44:36
      a job for California, or you could
      3:44:38
      specify a city and a state or even just
      3:44:40
      a city. But honestly, that's probably
      3:44:42
      not what's going to happen very often.
      3:44:44
      So now we want to create a format job
      3:44:46
      listing location that's going to take in
      3:44:48
      those properties. So we're going to have
      3:44:50
      our state abbreviation and our city that
      3:44:52
      we're going to pass into this function.
      3:44:54
      And again, we just want to create that
      3:44:55
      function.
      3:44:58
      And this is going to take in those two
      3:45:00
      parameters,
      3:45:02
      state abbreviation, which is a string,
      3:45:04
      and city, which is a string. Make sure I
      3:45:07
      get my spacing properly.
      3:45:09
      And the important thing to note is they
      3:45:11
      technically could be null. So we want to
      3:45:13
      make sure it's either that or null that
      3:45:15
      passes in. So if my state abbreviation
      3:45:18
      equals null and my city equals null,
      3:45:21
      well then I'm just going to return the
      3:45:22
      text none because we don't have anything
      3:45:24
      passed in for the location. Otherwise,
      3:45:27
      I'm going to create my location parts as
      3:45:28
      an array. And I want to first check if
      3:45:31
      city is not equal to null.
      3:45:34
      Then I'm going to take my location parts
      3:45:36
      and I'm going to add in my city. There
      3:45:38
      we go. I'm going to do the exact same
      3:45:40
      thing with state. Just like that. But
      3:45:42
      this one's a little bit different
      3:45:43
      because this is a state abbreviation.
      3:45:44
      Actually, it's going to be exactly the
      3:45:46
      same because we don't actually really
      3:45:47
      care much. We just want to make sure we
      3:45:49
      convert this to uppercase. There we go.
      3:45:51
      Going to put that inside of curly braces
      3:45:53
      so it's a little bit more clear what's
      3:45:54
      going on. So, I'm converting my state to
      3:45:56
      an uppercase version. And then finally,
      3:45:58
      I'm going to take my location parts and
      3:46:00
      I'm going to join them on a comma with a
      3:46:02
      space in between. So, if we pass in just
      3:46:04
      a city, it'll show just the city. If we
      3:46:06
      pass in just a state, it'll show just
      3:46:07
      the state. If we pass in both of them,
      3:46:09
      it's going to show them with a comma in
      3:46:11
      between them, which is exactly what we
      3:46:12
      want. So now we can get our location.
      3:46:15
      And if we give that a save again,
      3:46:16
      nothing shows up because we don't have a
      3:46:17
      location specified for this particular
      3:46:19
      element. Now we can copy this down again
      3:46:21
      for our next one. And this one is going
      3:46:23
      to be for the format job location.
      3:46:26
      Actually, I just call it location
      3:46:28
      requirement. There we go. So we want to
      3:46:29
      get our location requirement. And we
      3:46:32
      want to format that. And our icon for
      3:46:34
      this one is going to be the building
      3:46:35
      icon. There we go. We don't need to
      3:46:37
      worry about putting any custom size on
      3:46:38
      this. And now, as you can see, that is
      3:46:40
      showing up, which is looking really
      3:46:41
      good. The next thing that we can focus
      3:46:43
      on is going to be the job type. So, we
      3:46:45
      can say format job type. And this is
      3:46:48
      going to be the type. There we go. And
      3:46:51
      this one is going to have an hourglass
      3:46:53
      icon.
      3:46:54
      There we go. So, we can see this is a
      3:46:56
      full-time job. And then finally, let's
      3:46:58
      come in here with one more graduation
      3:47:00
      cap icon format experience level. There
      3:47:04
      we go. And this is our experience level.
      3:47:06
      And again, now you can see that this is
      3:47:08
      for a junior developer job. Now, the
      3:47:09
      last badge that we want to put in is the
      3:47:11
      is featured badge. So, we can say if is
      3:47:13
      featured, then we want to render out our
      3:47:15
      own badge inside of here. So, we can say
      3:47:17
      badge
      3:47:18
      just like this. This badge is going to
      3:47:20
      be a little bit different because it's
      3:47:21
      not going to use the same styles as all
      3:47:23
      the rest of them. It'll say featured
      3:47:24
      inside of it, but we want to modify what
      3:47:26
      our badge props are real quick. So, we
      3:47:28
      could say badge props. Then, we want to
      3:47:31
      specify what the class name is going to
      3:47:32
      be specifically. This is where our code
      3:47:34
      is going to get a little bit more
      3:47:35
      complex. We're going to come in here
      3:47:36
      with our class name. And we're actually
      3:47:38
      going to put in our default class names
      3:47:40
      first, the or not default, the ones that
      3:47:41
      we custom pass in because we want to
      3:47:43
      make sure that this specific badge has
      3:47:45
      things overridden. So, we want our
      3:47:47
      border to be our feature color, which is
      3:47:49
      going to be a style that we're going to
      3:47:51
      create in just a second. Also, we want
      3:47:53
      to make sure our background is going to
      3:47:54
      be that same exact featured color, but
      3:47:56
      we want this one to essentially be a
      3:47:58
      partially transparent one of 50.
      3:48:00
      Finally, our text is going to be the
      3:48:02
      featured foreground color. And now, all
      3:48:04
      we need to do is to create these
      3:48:06
      specific colors for this badge. Now,
      3:48:08
      currently, this is not a featured job.
      3:48:10
      So, we see it's not showing up. I'm
      3:48:11
      going to change this to not featured.
      3:48:12
      And now, you can see that it is showing
      3:48:14
      up right there. It's saying featured.
      3:48:16
      Now, to get our featured colors, what we
      3:48:17
      want to do is we want to go into our
      3:48:19
      global CSS. We're going to scroll down
      3:48:20
      to kind of where we have our accent. And
      3:48:22
      instead, I'm going to add a brand new
      3:48:24
      style. We'll just do it directly above
      3:48:25
      here. And this is going to be for
      3:48:26
      featured. Now, this is the light style.
      3:48:28
      It's going to be a purpley-ish color.
      3:48:30
      And I'm going to do the exact same thing
      3:48:31
      for our dark styles as well. I'm just
      3:48:33
      going to be copying the styles over. I
      3:48:35
      just went to a color picker to find
      3:48:36
      these particular styles, but it's a kind
      3:48:38
      of purplish based color. So, now we have
      3:48:40
      those inside of there. If we give this a
      3:48:41
      refresh, you'll see it's still not quite
      3:48:43
      hooking up properly. And that's because
      3:48:44
      all the way up here where we define our
      3:48:46
      theme, we need to also define our theme
      3:48:48
      up here. So, I'm going to make sure that
      3:48:49
      I copy the correct one here. Paste that
      3:48:51
      down. And then where it says accent, I'm
      3:48:53
      going to change that to featured. Now,
      3:48:54
      if I get that to save, you can see
      3:48:56
      that's changed to that purple color that
      3:48:57
      we created. And we have a different
      3:48:58
      color for our light mode and our dark
      3:49:00
      mode just to make sure it matches well
      3:49:01
      with all of our different backgrounds.
      3:49:03
      So, that right there, if we go back to
      3:49:04
      our page, handles essentially the
      3:49:05
      left-hand side of our page. Now, we can
      3:49:07
      minimize this down and we can work on
      3:49:09
      what is going to be the right hand side
      3:49:10
      of our page inside of this section. So,
      3:49:12
      first of all, this is going to be a
      3:49:13
      bunch of buttons. So, we're going to
      3:49:14
      align them in the center, a gap of two.
      3:49:17
      And if this section is empty, I'm going
      3:49:19
      to add a negative margin on the top of
      3:49:21
      four. Now, this may seem really weird,
      3:49:23
      but the reason that this could be empty
      3:49:24
      is because only users that have the
      3:49:26
      ability to edit job listings are going
      3:49:28
      to have buttons in this section. So, if
      3:49:30
      they can't edit things, this will be
      3:49:31
      completely empty. But because we have a
      3:49:33
      gap of four set up, it'll still add a
      3:49:35
      space of four underneath of this element
      3:49:37
      even though this div is empty. So, this
      3:49:39
      div is empty. we essentially are
      3:49:40
      removing that margin on the top by rem
      3:49:43
      or we're adding or getting rid of margin
      3:49:44
      on the top to essentially offset this
      3:49:46
      gap right here. So really all this is
      3:49:48
      doing is if this has no buttons, we're
      3:49:50
      essentially pretending this div doesn't
      3:49:51
      exist. Now the reason we can't wrap this
      3:49:53
      inside of our check though is because we
      3:49:54
      have like four or five different buttons
      3:49:56
      and each one has different permissions.
      3:49:57
      So it would be unwieldy to wrap the
      3:49:59
      entire thing in a check. So instead we
      3:50:01
      just add this empty property which does
      3:50:02
      the same thing for us. Now before we
      3:50:04
      start dealing with permissions and
      3:50:05
      everything, I just want to first add a
      3:50:06
      simple button so we can kind of see what
      3:50:08
      we're dealing with. So, we're going to
      3:50:09
      add in a simple button here. This is
      3:50:11
      going to say as child, and this button
      3:50:13
      is going to be an outline button.
      3:50:15
      There we go. Make sure that I actually
      3:50:17
      render this properly by importing it.
      3:50:20
      And we'll make sure we import it from
      3:50:21
      the correct location. And here, this is
      3:50:23
      going to be a link that's going to go to
      3:50:24
      the edit page. So, we'll come in here,
      3:50:26
      get a link that brings us to the edit
      3:50:28
      page, which is going to be slash
      3:50:30
      employer/joblistings.
      3:50:33
      And we want to get our job listing
      3:50:38
      ID. Whoops. Joblisting ID. There we go.
      3:50:41
      And we want to go to the edit page
      3:50:43
      specifically. Now, we can come inside of
      3:50:45
      here. I want to use the edit icon. There
      3:50:49
      we go. And then what I want to do is I
      3:50:51
      want to have the text edit. And the size
      3:50:54
      of my icon is going to be four. So,
      3:50:57
      we'll just come in here. Size of four.
      3:50:58
      Give that a quick save. And now you can
      3:51:00
      see we have our edit button showing up
      3:51:01
      right there. And if we're on a large
      3:51:03
      enough screen size, quite larger screen
      3:51:05
      size, I might have to zoom out just a
      3:51:06
      little bit. You can see that the edit
      3:51:07
      button has now moved over to the right
      3:51:09
      hand side instead because we're on a
      3:51:10
      much larger screen size. While if I zoom
      3:51:12
      it in, you can see it shows up on the
      3:51:14
      bottom. So, let's zoom it back in a
      3:51:16
      little bit so it's easier for us to see.
      3:51:18
      Minimize that down over. And there we
      3:51:19
      go. Now, before we start adding the rest
      3:51:21
      of the buttons in, those ones are going
      3:51:22
      to be quite a bit more complicated. They
      3:51:23
      have complicated permissions and so on.
      3:51:25
      What I want to do is I want to add the
      3:51:26
      section for rendering out our markdown,
      3:51:28
      which goes below pretty much everything
      3:51:29
      that we have inside of here. So, we can
      3:51:31
      just come down here and we want to
      3:51:33
      render out our markdown, but we only
      3:51:34
      want to render out some of the markdown
      3:51:36
      because if we render out all of the
      3:51:37
      markdown they type in, it could be a
      3:51:39
      very large page and we also want to show
      3:51:40
      all the applications and stuff for the
      3:51:42
      job on the same page. So, instead, we're
      3:51:44
      going to render out just part of the
      3:51:45
      description with the option to click a
      3:51:47
      button to view the full description. So,
      3:51:49
      we're actually going to create a
      3:51:50
      component for this called markdown
      3:51:52
      partial, which allows us to render out
      3:51:54
      essentially just some of the markdown
      3:51:56
      that we want. So we can have our
      3:51:58
      dialogue markdown and this is going to
      3:51:59
      be the markdown that is rendered in the
      3:52:01
      dialogue the popup that allows us to
      3:52:03
      view everything and we're going to
      3:52:04
      create a component which is called
      3:52:05
      markdown renderer and we're going to
      3:52:08
      pass it in a source and the source is
      3:52:10
      just going to be whatever our markdown
      3:52:11
      is. In our case it's our job listing
      3:52:14
      desescription just like that. There we
      3:52:16
      go. Make sure I close off that
      3:52:18
      component. So now that's our dialogue
      3:52:20
      markdown entirely done. I will copy that
      3:52:22
      down for our main markdown because our
      3:52:24
      main markdown is essentially the same,
      3:52:26
      but I'm going to add a class name here.
      3:52:28
      And the class name is pros
      3:52:31
      small. All that allows us to do is to
      3:52:33
      use a small version of text. So the main
      3:52:35
      version of our text isn't so large. It's
      3:52:37
      a little bit smaller, which is really
      3:52:38
      useful. And then we'll add in a dialogue
      3:52:41
      title. This is just what the title of
      3:52:42
      our dialogue element will be. And it'll
      3:52:44
      say description just so we know what
      3:52:46
      this particular thing says. Now we need
      3:52:48
      to create all these different
      3:52:49
      components. So let's create this
      3:52:50
      markdown renderer first. So we can come
      3:52:52
      into our components tab. We can go into
      3:52:53
      the markdown folder that we created.
      3:52:55
      Create a brand new file, call it
      3:52:57
      markdown renderer.tsx.
      3:52:59
      This is going to export
      3:53:01
      a function called markdown renderer.
      3:53:04
      Just like that. And this is going to
      3:53:05
      take in a class name,
      3:53:09
      some options, as well as different props
      3:53:12
      that we want to pass along. And these
      3:53:14
      are going to be using the MDX remote
      3:53:17
      props. and we're just going to combine
      3:53:19
      in our own class name as a string. And
      3:53:22
      this MDX remote is actually a library
      3:53:24
      we're going to be using. So if we go
      3:53:25
      over to the code for this library, you
      3:53:27
      can see we can just install and next MDX
      3:53:30
      remote, which the really nice thing is
      3:53:31
      is this is a library essentially
      3:53:33
      directly built in to work with Next. So
      3:53:34
      it's going to be really good at working
      3:53:36
      directly with Next. And we just give
      3:53:38
      that a quick second. There we go. You
      3:53:40
      can see that that has worked properly.
      3:53:41
      It says if we're using Turboac, we'll
      3:53:42
      need to add the following to our Next.js
      3:53:44
      config. I didn't end up having to do
      3:53:45
      that and I was using Turopac. Maybe this
      3:53:47
      issue has been fixed, but we can just
      3:53:49
      ignore that for now. And the next step
      3:53:50
      is just all the examples of how to get
      3:53:52
      started with MDX remote. It's relatively
      3:53:54
      simple. The main thing you need to know
      3:53:55
      is this must render on the server. It
      3:53:57
      cannot render on the client. So, we're
      3:53:59
      going to go ahead. We have this
      3:54:00
      component. We know it's rendering on the
      3:54:02
      actual server. So, that's fine. And
      3:54:04
      here, let's make sure, of course, we
      3:54:05
      import our type. Looks like I need to
      3:54:07
      manually import this.
      3:54:10
      We want to get that from next MDX remote
      3:54:13
      slash. And we want to make sure we get
      3:54:15
      the RSC. Because if we're using React
      3:54:17
      Server components, we must import from
      3:54:19
      the React server component version. It's
      3:54:20
      very important. Now, let's wrap this
      3:54:22
      inside of a div that's going to be using
      3:54:24
      that CN function to take all of our
      3:54:26
      markdown classes. So, our markdown class
      3:54:29
      names, and then combining them with our
      3:54:30
      custom class names, such as making our
      3:54:32
      text smaller. Then we have our MDX
      3:54:34
      remote, and this is what allows us to
      3:54:36
      edit everything out or render
      3:54:37
      everything, I'm sorry. So, here is our
      3:54:39
      props that we're going to be passing
      3:54:40
      along. And then also, we have our
      3:54:42
      options. So, the reason that we're
      3:54:44
      extracting our options up here is
      3:54:45
      because we want to pass along some
      3:54:46
      custom options to MDX options. So, we
      3:54:49
      have our MDX options just like this.
      3:54:52
      Make sure that I put this inside of an
      3:54:53
      object because this allows us to
      3:54:55
      configure what type of plugins we're
      3:54:56
      using. So, we have our remark plugins
      3:54:58
      and our remark plugins we're going to be
      3:55:00
      using remark
      3:55:02
      GFM. Essentially, this just allows us to
      3:55:04
      use formatting from GitHub, things like
      3:55:06
      tables which are not built into native
      3:55:08
      markdown. So what we can do is we can
      3:55:09
      install this library which is called
      3:55:11
      remark gfm. We'll just do a quick force
      3:55:13
      on that to make sure that it actually
      3:55:15
      works. And that'll give us that actual
      3:55:16
      thing. And then we can take whatever the
      3:55:18
      rest of our options are. So we can say
      3:55:20
      options.m MDX options plugins. And if we
      3:55:24
      don't have any options, we'll use an
      3:55:26
      empty string by default. Come in here.
      3:55:28
      Looks like I might need to manually
      3:55:30
      import this.
      3:55:32
      Remark.
      3:55:34
      There we go. That's going to be imported
      3:55:36
      properly. And then we can also make sure
      3:55:38
      inside of this MDX options, we get the
      3:55:40
      rest of our options. MDX options.
      3:55:43
      Whoops, there we go. MDX options. So
      3:55:45
      really all that this custom component we
      3:55:47
      created did is it added in support for
      3:55:49
      this GitHub flavored stuff that added
      3:55:51
      like tables and stuff. And then we added
      3:55:53
      the ability to have our markdown class
      3:55:54
      names by default. So hopefully
      3:55:56
      everything looks the same between all of
      3:55:57
      our different markdown classes. Now the
      3:55:59
      next thing we need to do is this
      3:56:00
      markdown partial.tsx.
      3:56:03
      Make sure I spell that properly. And
      3:56:05
      this one's going to be a little bit more
      3:56:06
      confusing. First of all, we have the
      3:56:08
      markdown components that we said that we
      3:56:10
      need to pass in that we've already dealt
      3:56:11
      with and covered. And the reason we're
      3:56:12
      passing them in is because this is
      3:56:14
      actually going to need to be a client
      3:56:15
      component to be able to handle all of
      3:56:17
      our different resizing and so on because
      3:56:19
      we need to be able to check to see if
      3:56:20
      things are overflowing. So, we're going
      3:56:22
      to create a variable called is
      3:56:23
      overflowing and set is overflowing.
      3:56:27
      There we go. We'll set that equal to use
      3:56:29
      state and we'll set that to false by
      3:56:31
      default just so we don't have to worry
      3:56:32
      about anything. There we go. Then what
      3:56:34
      we can do down here is we can get a
      3:56:36
      reference to where our markdown
      3:56:38
      container is. We'll use a ref for that
      3:56:41
      and this is going to be an HTML div
      3:56:43
      element and we'll set it to null by
      3:56:45
      default. This is going to reference what
      3:56:46
      our markdown container is so we can
      3:56:48
      handle the overflow related content
      3:56:49
      inside of this. Then we'll create a
      3:56:51
      function called check overflow which is
      3:56:54
      going to take in a node which is our
      3:56:55
      case our markdown reference or whatever.
      3:56:57
      So it's an HTML div element just like
      3:57:00
      that. And we can set is overflowing.
      3:57:03
      Make sure I put that inside the actual
      3:57:04
      function. There we go. We can set is
      3:57:06
      overflowing to the node.scroll height is
      3:57:09
      greater than the node.client height. So
      3:57:12
      essentially if the scroll container size
      3:57:13
      is larger than the client container
      3:57:15
      size, that means we have more text than
      3:57:16
      we can fit inside of the container. This
      3:57:18
      is true of any element. If the scroll
      3:57:20
      height is larger than the client height,
      3:57:21
      that means it is overflowing its current
      3:57:23
      container. Then to make sure that we
      3:57:24
      actually call this check overflow
      3:57:26
      function in the place it needs, we're
      3:57:27
      going to be setting up two different
      3:57:28
      effects. The first one is going to be a
      3:57:30
      use effect and the second one is going
      3:57:31
      to be a use layout effect. Now, this use
      3:57:34
      effect is only for hooking up an event
      3:57:35
      listener on resize. So, when we change
      3:57:37
      the size of our window, that changes how
      3:57:39
      large our text is and how tall it is,
      3:57:41
      which means it could change if we're
      3:57:42
      overflowing or not. So, that's what this
      3:57:44
      does. Essentially, every time we change
      3:57:45
      our window, we check the overflow
      3:57:46
      property. Use layout effect is an effect
      3:57:48
      that is run after our page completely
      3:57:51
      renders. So, after our page renders, all
      3:57:52
      of our text is on it. Everything is good
      3:57:54
      to go. There's no more changes to be
      3:57:55
      made. This then checks, hey, is this
      3:57:57
      thing currently overflowing? because if
      3:57:58
      so now we need to change around what
      3:58:00
      we're rendering on the page. So now
      3:58:01
      comes where we actually render out the
      3:58:03
      content itself. So the first thing I
      3:58:05
      want to render is the div that contains
      3:58:06
      our markdown. So we can make this our
      3:58:08
      markdown ref. And inside of here we can
      3:58:10
      add some class names. For example, we'll
      3:58:12
      have a max height of 300 pixels. This is
      3:58:14
      going to be our overflow size. Anything
      3:58:15
      over that is going to be hidden. So
      3:58:17
      overflow hidden is going to be set. And
      3:58:19
      we're also going to set a position of
      3:58:20
      relative just so we can absolutely
      3:58:22
      position some overflow styling as well.
      3:58:24
      And then I'm going to specify my main
      3:58:26
      markdown just like that. So this is
      3:58:27
      whatever my main markdown container is.
      3:58:29
      And if I'm overflowing, I want to render
      3:58:31
      some additional content on the page. And
      3:58:33
      this is just going to add a little bit
      3:58:34
      of a fade effect to our animation. So
      3:58:37
      add a class name here, a background.
      3:58:39
      It's going to be a gradient background
      3:58:40
      to the top is what we're going to do.
      3:58:42
      It's going to go from our background
      3:58:44
      color. Just like that. And it's going to
      3:58:46
      go to transparent. There we go.
      3:58:51
      And we wanted to start this at 15%.
      3:58:54
      And we want to make sure we have an
      3:58:55
      inset of zero. Absolutely position this.
      3:58:59
      And we're going to say pointer events
      3:59:01
      none.
      3:59:02
      Close that off. Just like that. So
      3:59:04
      essentially what I'm doing is I'm
      3:59:05
      creating a div that covers the entire
      3:59:07
      size of my main markdown. And I want to
      3:59:08
      create a background that goes from my
      3:59:10
      background color. So essentially
      3:59:12
      completely black up to transparent. And
      3:59:14
      I want it to stop and be transparent at
      3:59:16
      exactly 15%. So I have a very small
      3:59:18
      gradient at the bottom 15% of my
      3:59:20
      container. That's all that this div is
      3:59:22
      doing. I'll show you by disabling this
      3:59:23
      in a little bit what it looks like.
      3:59:25
      Next, I want to check if we're
      3:59:26
      overflowing, I want to add a button to
      3:59:28
      read more. So, if overflowing is true,
      3:59:31
      well, then we're going to add a dialogue
      3:59:32
      in our container. So, we'll say
      3:59:34
      dialogue, and I need to make sure I
      3:59:35
      import the correct one. So, we can say
      3:59:36
      dialogue, and this is going to be coming
      3:59:38
      specifically from our component library.
      3:59:40
      And it looks like we don't actually have
      3:59:42
      dialogue imported for us. So, let's go
      3:59:44
      ahead and actually do that inside of
      3:59:45
      Shad CN. We can get the dialogue
      3:59:47
      component. Just like that. So, now we
      3:59:49
      have that dialogue. Make sure we force
      3:59:50
      install that. And now we should be able
      3:59:52
      to hopefully import whatever that
      3:59:54
      dialogue is. So now we can come back
      3:59:56
      over here dialogue and we can get that
      3:59:58
      directly from our UI folder which is
      3:59:59
      what we want. We also want to get the
      4:00:01
      dialogue trigger.
      4:00:04
      There we go. Same exact place we want to
      4:00:06
      get that from. This is going to be an as
      4:00:08
      child because we want it to render out a
      4:00:09
      button.
      4:00:11
      The variant for this button is going to
      4:00:12
      be the ghost variant. Make sure I get
      4:00:15
      the button imported properly.
      4:00:18
      And I'm also going to add some class
      4:00:19
      names to this of underline so it kind of
      4:00:20
      looks like a link. I'm going to remove
      4:00:22
      the margin on the left. So by default a
      4:00:24
      button has a three p or padding of three
      4:00:27
      on the inside. But since this is a ghost
      4:00:28
      button I want to remove that cuz it
      4:00:30
      looks kind of weird with that margin on
      4:00:31
      there. And this will just say read more.
      4:00:34
      There we go. Then inside of here we have
      4:00:36
      our dialogue content. And our dialog
      4:00:38
      content will actually have quite a few
      4:00:39
      class names on it just to make it as
      4:00:41
      wide as possible to fit our screen. So
      4:00:42
      on a medium screen we're going to set
      4:00:44
      our max width to 3XL. On our large
      4:00:46
      screen, our max width will be 4XL. Our
      4:00:49
      max height will be essentially set to a
      4:00:51
      calculation of 100% minus 2M, so
      4:00:56
      essentially almost the full screen size
      4:00:57
      minus a little bit of space. Our
      4:00:59
      overflow will be set to hidden, and
      4:01:01
      we're going to make sure that we stack
      4:01:02
      everything in the flex column direction.
      4:01:04
      This is just making sure our dialogue is
      4:01:05
      as large as it needs to be to fit all
      4:01:07
      the different content that we want
      4:01:08
      inside of it. Then we're going to have a
      4:01:11
      dialogue
      4:01:12
      header and inside of that a dialogue
      4:01:15
      title. And as we know the dialogue
      4:01:17
      title, we'll just render out our
      4:01:19
      dialogue title property. Just like that.
      4:01:21
      And finally, inside of here, we can have
      4:01:23
      a div with a class name of flex one.
      4:01:25
      This will just grow to fill the full
      4:01:26
      size. And the overflow in the Y
      4:01:29
      direction is going to be set to auto
      4:01:30
      because we want it to scroll if it
      4:01:31
      overflows. And this is going to be our
      4:01:33
      dialogue markdown. Now, if we give that
      4:01:36
      a quick save and we make sure we import
      4:01:38
      everything, we should hopefully see that
      4:01:39
      we are able to render out the markdown
      4:01:40
      for our component. So, we give that a
      4:01:42
      quick save. Let that refresh over here.
      4:01:45
      And you can see that it's rendering out
      4:01:46
      exactly what that content is. Now, I'm
      4:01:49
      going to create a brand new job listing
      4:01:50
      with a lot more markdown inside of it.
      4:01:52
      So, we can come in here. I'm just going
      4:01:53
      to add a bunch of different text. So, we
      4:01:55
      can see that we have a very large file
      4:01:57
      right there. I'm going to give it a
      4:01:58
      bogus job title. We'll say it's a remote
      4:02:00
      job. And we'll click create this job
      4:02:02
      listing. And now you can see that when I
      4:02:03
      get beyond that 300 pixels of height,
      4:02:05
      which if I'm in a normal zoom level,
      4:02:07
      it's not too much of my page that's
      4:02:09
      being taken up by it. But you can see
      4:02:10
      once I cross that 300 pixel height
      4:02:12
      barrier, you can see I need to click
      4:02:13
      read more and it'll pop it up inside of
      4:02:15
      a dialogue, which is exactly what I
      4:02:17
      want. And you'll also see that we have
      4:02:18
      this nice little fade effect at the
      4:02:20
      bottom where I'm getting that small
      4:02:21
      amount of fading. That is happening
      4:02:22
      because if we go inside of our markdown
      4:02:24
      partial, this particular section right
      4:02:26
      here, if I remove this and I save, you
      4:02:28
      see that fade goes away. So that's the
      4:02:29
      whole reason why I put this little bit
      4:02:30
      of a fade in there. So, now that we've
      4:02:32
      kind of got the bulk of what this page
    </chapter>
    <chapter title="Employer job listing edit page" start_time="4:02:33">
      4:02:33
      should look like, minus all the
      4:02:35
      different buttons, let's work on the
      4:02:36
      edit page because right now we don't
      4:02:37
      have an edit page, which is obviously
      4:02:38
      not great. So, we'll create a new folder
      4:02:40
      called edit inside of here. I'm going to
      4:02:42
      take my new job listing and just kind of
      4:02:44
      paste it into here. This will say edit
      4:02:46
      job listing page. And right now, you can
      4:02:48
      see it's kind of just rendering out this
      4:02:49
      stuff. We want this to say edit job
      4:02:51
      listing. And really, the only difference
      4:02:52
      between this page and the new page is we
      4:02:54
      want to pass in what the current job
      4:02:56
      listing is, just like this. So, we're
      4:02:58
      going to need to modify our form to
      4:03:00
      accept a job listing. And we're also
      4:03:01
      going to need to get a job listing as
      4:03:02
      well. So this is also going to take in
      4:03:04
      some params. So we'll say props is equal
      4:03:06
      to props. We'll create that type
      4:03:10
      is equal to params and it's going to be
      4:03:13
      a promise that returns a job. Whoops.
      4:03:17
      Job listing
      4:03:19
      ID which is a string. There we go. Just
      4:03:21
      like that.
      4:03:23
      Now we have our props. And the reason I
      4:03:25
      need to do that is because we're going
      4:03:26
      to have an asynchronous function which
      4:03:28
      is our suspended page. And that is going
      4:03:30
      to take in
      4:03:32
      our params of type props. There we go.
      4:03:35
      So, a lot of this code can stay the
      4:03:37
      same, but this particular job listing
      4:03:39
      form section needs to go into here. Just
      4:03:42
      like that. And then up here, I can
      4:03:43
      render out my suspended page. So, I can
      4:03:45
      say suspended page just like that. There
      4:03:48
      we go. I can also get rid of this
      4:03:50
      section right here because I don't need
      4:03:51
      to worry about that whole posting thing.
      4:03:52
      It's just for editing a job listing. So,
      4:03:54
      we can remove that. And now inside of
      4:03:56
      here, we can try to get our job listing.
      4:03:58
      So first of all, what I want to do is I
      4:04:00
      want to say that we're going to get our
      4:04:01
      job listing ID by calling await params
      4:04:05
      just like that. And this I need to wrap
      4:04:08
      inside of a suspense. There we go. We
      4:04:10
      could add some fallback state for
      4:04:11
      loading if we want, but in our case we
      4:04:13
      don't really need to. Next thing that I
      4:04:14
      want to do after that is I want to get
      4:04:16
      our org ID.
      4:04:19
      That is just a wait get current
      4:04:20
      organization. There we go. If our org ID
      4:04:24
      is equal to null, this shouldn't happen,
      4:04:26
      but if it is, we can just return not
      4:04:27
      found or null or whatever you want. It
      4:04:29
      doesn't really matter. Then we can get
      4:04:31
      our job listing, that's just going to be
      4:04:33
      wait get job listing with our job
      4:04:37
      listing ID and our org ID. And we've
      4:04:40
      kind of already created this function
      4:04:41
      before. Let me make sure I actually type
      4:04:43
      that properly. There we go. I think if I
      4:04:45
      just do a quick search for that, we
      4:04:46
      should hopefully find a function that's
      4:04:47
      nearly identical to that. Here we go.
      4:04:49
      Get job listing. I'm just going to copy
      4:04:50
      and paste that over because it's
      4:04:52
      essentially the exact same code. So,
      4:04:53
      let's import all the stuff we need and
      4:04:55
      then make sure that this still does
      4:04:56
      exactly what we want it to do. Get that
      4:04:58
      imported.
      4:05:01
      And there we go. So, yeah, it looks like
      4:05:03
      this is taking in an ID, or ID, and it's
      4:05:05
      searching for exactly that. So, that
      4:05:06
      does do exactly what we wanted to do,
      4:05:08
      which is great. Then what we can do, we
      4:05:10
      have our job listing. If our job listing
      4:05:13
      is equal to null, well, then we want to
      4:05:15
      essentially get out of here. So, we'll
      4:05:16
      return not found because we're on a page
      4:05:19
      that doesn't exist. There we go. So, now
      4:05:22
      what we can do inside this suspended
      4:05:23
      page is we can add in our props and we
      4:05:25
      can just say or actually we can just
      4:05:26
      take our props like this. There we go.
      4:05:29
      That'll pass along everything we need
      4:05:31
      inside that suspended page. Now, you can
      4:05:32
      see edit job listing with all the
      4:05:34
      information, but it's not pre-populated
      4:05:35
      because we need to make sure our job
      4:05:37
      listing form accepts in a job listing.
      4:05:39
      So in the job listing form, this is
      4:05:41
      going to take a job listing
      4:05:45
      just like that.
      4:05:47
      And we're going to have a job listing.
      4:05:50
      Whoops. And we need to make sure it is
      4:05:52
      that type of job listing
      4:05:55
      table.infer select. There we go. And I
      4:05:59
      want to make sure I only pick the
      4:06:00
      properties that we actually need from
      4:06:02
      this because I don't need to get every
      4:06:03
      single thing from here. So I believe the
      4:06:05
      things that we need from here are going
      4:06:06
      to be title. We're going to need
      4:06:08
      description.
      4:06:12
      Description. There we go.
      4:06:16
      We're going to need to make sure we get
      4:06:17
      the experience level,
      4:06:22
      the ID.
      4:06:24
      We need the organization. Actually, we
      4:06:26
      don't need the organization ID, but we
      4:06:27
      do need the state abbreviation.
      4:06:30
      We need the type.
      4:06:35
      We need the wage.
      4:06:37
      And we need the wage interval. Hopefully
      4:06:38
      that's everything that we need. And what
      4:06:40
      we can do is we can say, hey, if we have
      4:06:41
      a job listing, we want to use that.
      4:06:43
      Otherwise, fall back to this. And it
      4:06:45
      looks like we are missing some
      4:06:46
      properties. Title, description, state
      4:06:47
      abbreviation. Looks like city is the one
      4:06:48
      we are missing. There we go. City, wage,
      4:06:52
      wage interval, experience level, that is
      4:06:54
      up here as well. Type is up here. And
      4:06:56
      location requirement is not location
      4:06:59
      requirement. There we go. That got rid
      4:07:00
      of our error. So we do have everything
      4:07:02
      properly sent in. So now we have all the
      4:07:04
      different properties we need for our job
      4:07:05
      listing. all the stuff hooked up here.
      4:07:07
      All we need to do is change this one
      4:07:08
      little section right here because you'll
      4:07:09
      notice if we just refresh our page over
      4:07:11
      here, our title pre-populated. You can
      4:07:13
      see it's a remote job full-time, our
      4:07:15
      description populated. So, everything
      4:07:16
      populated inside of here just like we
      4:07:18
      want. Now, we want to make sure we
      4:07:19
      either create or we update our job
      4:07:21
      listing. So, we're going to say action
      4:07:23
      is equal to and if our job listing is
      4:07:26
      existing, then we want to use update job
      4:07:29
      listing. Otherwise, we want to use
      4:07:32
      create job listing just like that. and
      4:07:35
      we'll call action and pass it in
      4:07:36
      whatever our data is. And then do that
      4:07:38
      same thing with our response. This one
      4:07:40
      we're going to bind the joblisting ID
      4:07:42
      just like that. And make sure we pass
      4:07:44
      null at the beginning. There we go.
      4:07:45
      That's just going to make sure the first
      4:07:46
      property that gets passed to this
      4:07:47
      function is our job listing ID. And now
      4:07:50
      we just need to create this simple
      4:07:51
      function. So here export and async
      4:07:55
      function called update job listing takes
      4:07:57
      an ID and then it's going to take in all
      4:07:59
      of our unsafe data just like we did up
      4:08:01
      here. So we can copy that in and bring
      4:08:04
      that down. And actually our code is
      4:08:05
      going to be pretty similar. So I'm going
      4:08:06
      to kind of copy all of this and paste it
      4:08:08
      down because we're going to have a lot
      4:08:09
      of very similar stuff between the two.
      4:08:10
      Kind of the biggest difference between
      4:08:12
      these different things is we need to
      4:08:14
      make sure that we get the actual updated
      4:08:16
      or the correct job listing. So we can
      4:08:17
      create a function called get job listing
      4:08:21
      just like this. It's going to take in an
      4:08:23
      ID which is going to be a string. And
      4:08:25
      it's also going to take in an org ID
      4:08:28
      which is a string. And this is something
      4:08:30
      that we've created multiple times. It's
      4:08:31
      probably about the third time we've
      4:08:32
      created essentially this exact same
      4:08:33
      function. It's okay to duplicate this
      4:08:35
      function in multiple places because
      4:08:37
      sometimes you may want to query only
      4:08:39
      specific things about a job. Sometimes
      4:08:40
      you may not want to query specific
      4:08:42
      things. So it's really not a big deal to
      4:08:44
      have this duplicated in a few different
      4:08:45
      places, which is why I'm okay with just
      4:08:47
      putting this in multiple different
      4:08:48
      places. So now you can see we have our
      4:08:50
      get job listing function. Let's make
      4:08:52
      sure that this is async so we can
      4:08:54
      actually deal with the caching properly.
      4:08:55
      And now we can scroll up to here where
      4:08:57
      we want to get that. So we can say const
      4:09:00
      job listing is equal to calling that
      4:09:02
      with our ID and with our org ID. There
      4:09:05
      we go. And we should call this our
      4:09:07
      updated job listing.
      4:09:10
      There we go. And we'll render that ID
      4:09:11
      just like that. So this is our job
      4:09:13
      listing. We got our ID. We have our org
      4:09:14
      ID. Here's our updated job listing
      4:09:16
      information. And we're passing in some
      4:09:18
      specific things, but we don't need to
      4:09:19
      pass in all of these things. For
      4:09:21
      example, all we actually want to pass in
      4:09:22
      is the data. I don't want to modify the
      4:09:24
      things like the status and so on. Those
      4:09:26
      are not things I want to change. So, I'm
      4:09:27
      going to call update job listing. And
      4:09:30
      this is going to be the database
      4:09:31
      version. Pass in my ID and my data. So,
      4:09:34
      I can scroll all the way up here where I
      4:09:35
      have insert job listing. I'm going to
      4:09:37
      get my update job listing. And I'm going
      4:09:39
      to rename it to update job listing DB.
      4:09:41
      So, now what I can do is go to this
      4:09:42
      function. I'm actually just going to
      4:09:44
      copy this because it's going to be
      4:09:45
      pretty similar. This is going to be
      4:09:46
      called update job listing. There we go.
      4:09:49
      It's going to take in an ID, which is a
      4:09:52
      string, as well as all my job listing
      4:09:54
      information. And this is going to be a
      4:09:56
      partial because we're only doing an
      4:09:57
      update. We're not doing a create. And
      4:09:58
      I'm just going to copy over this code
      4:09:59
      real quick because we've seen this in
      4:10:01
      many, many different places. So we can
      4:10:03
      see inside of here I have updated
      4:10:05
      listing. I'm doing an update on my
      4:10:06
      table, setting all my data to this data
      4:10:08
      where my ID is equal to the ID. I'm
      4:10:10
      returning the ID and the organization
      4:10:12
      ID. That way I can revalidate my cache
      4:10:14
      down here. So that's relatively
      4:10:15
      straightforward. We can make sure we
      4:10:17
      import this directly from our actions.
      4:10:19
      And now we should be able to update our
      4:10:20
      job listing properly. So, if I change
      4:10:22
      this to like a real title and let's
      4:10:24
      change this to be a little bit smaller
      4:10:26
      and we click create job listing, we
      4:10:28
      should see it now says real title and my
      4:10:29
      description is much shorter. Now, from
    </chapter>
    <chapter title="Permission setup" start_time="4:10:31">
      4:10:31
      here, there's a lot of different ways
      4:10:32
      that we can go. We can work on this
      4:10:34
      sidebar. We can work on implementing the
      4:10:36
      actual job board section next. But I
      4:10:38
      think the next place that I want to work
      4:10:39
      on is going to be a little bit more
      4:10:40
      groundwork and that's going to be
      4:10:42
      implementing features as well as
      4:10:44
      permissions so we can handle that for
      4:10:46
      the rest of our application instead of
      4:10:47
      just ignoring it. So the way that we're
      4:10:49
      going to be handling permissions and
      4:10:50
      plans and pricing and features is all
      4:10:52
      going to be built into Clerk. It's going
      4:10:53
      to make it really easy for us to
      4:10:54
      integrate with our application. So if we
      4:10:56
      go into Clerk, we can go over to this
      4:10:58
      configure section and we have the
      4:10:59
      ability to implement roles and
      4:11:01
      permissions for our organization
      4:11:02
      management. And here we have different
      4:11:04
      roles we can customize as well as
      4:11:05
      different permissions that we can
      4:11:06
      create. Now for our application, we're
      4:11:08
      essentially going to have three roles.
      4:11:09
      We're going to have the admin role,
      4:11:10
      which is like the default role that
      4:11:12
      person that creates an organization has.
      4:11:14
      Then we're going to edit this member
      4:11:15
      role. We're going to change this to be
      4:11:16
      an applicant
      4:11:18
      whoops applicant manager role. And we
      4:11:22
      can come in here and we can just say
      4:11:24
      applicant manager
      4:11:28
      a role. We'll just say it's a user
      4:11:31
      who can approve slashdeny
      4:11:35
      applicants and update applicant details
      4:11:39
      for all job listings. There we go. Let
      4:11:42
      me make sure I just spelled that
      4:11:43
      properly. And then we can modify any
      4:11:46
      permissions that we want. We don't
      4:11:47
      really care about most of these
      4:11:48
      permissions, so we'll just kind of leave
      4:11:50
      this as is. And we'll update this role
      4:11:51
      so at least it has a new name and a new
      4:11:53
      description. I'm also going to create a
      4:11:55
      brand new role. And we're just going to
      4:11:57
      mark that message so we don't see it
      4:11:58
      anymore. And this is going to be a job
      4:12:00
      listing
      4:12:02
      manager. Just like that. And this one is
      4:12:04
      going to say job
      4:12:07
      listing
      4:12:09
      manager. Make sure I spell everything
      4:12:11
      properly. And for the description, I'll
      4:12:13
      just copy this over. There we go. It's a
      4:12:15
      user who create, update, delete, and
      4:12:17
      update the status of job listings. And
      4:12:19
      again, we can select different
      4:12:20
      permissions. I'm just going to use the
      4:12:22
      billing and members permissions. That's
      4:12:23
      the same thing our other one had. And
      4:12:25
      then we'll add our own custom
      4:12:26
      permissions from here. So now we have an
      4:12:27
      admin, an applicant manager, and a job
      4:12:29
      listing manager for managing the
      4:12:30
      different things in our application. And
      4:12:32
      this is to emulate what it's like where
      4:12:33
      we have different permissions for
      4:12:34
      different users because some people may
      4:12:36
      only be able to create job listings,
      4:12:37
      some people manage the interview
      4:12:39
      process. So we want to be able to
      4:12:40
      separate those into different roles. Now
      4:12:42
      we can come into permissions and this is
      4:12:43
      where kind of the bulk of our
      4:12:44
      application will go with creating brand
      4:12:46
      new permissions. So I'm going to kind of
      4:12:47
      copy paste over a lot of the text here.
      4:12:49
      This is going to be for changing the
      4:12:50
      rating of an applicant. So the applicant
      4:12:51
      may have one star, two star, so on. This
      4:12:53
      is allowing users to change that. And we
      4:12:55
      got a little description and then I'm
      4:12:57
      also going to copy over the actual
      4:12:58
      description for that. There we go. It's
      4:13:00
      job listing applications colon change
      4:13:02
      rating. So each of these is going to
      4:13:03
      have the object it performs on as well
      4:13:05
      as the function that is being performed
      4:13:07
      on that object. and let's create that as
      4:13:09
      our very first permission. So our
      4:13:10
      applicant manager would be able to do
      4:13:11
      that. The next one is going to be for
      4:13:13
      changing the status. So we'll come in
      4:13:15
      here. We'll just get all of this copied
      4:13:17
      over. Essentially, it's just kind of
      4:13:18
      descriptions and names to make this
      4:13:20
      easier to work with in your UI. But you
      4:13:21
      can, you know, write whatever you want
      4:13:22
      for the names, descriptions, and so on.
      4:13:24
      And then we are going to have
      4:13:25
      permissions for dealing with our job
      4:13:27
      listings. So we want to be able to
      4:13:28
      change the status. For example, making a
      4:13:30
      job listing published or to make a job
      4:13:32
      listing so it's delisted, draft, so on.
      4:13:34
      This allows the user to change the
      4:13:36
      status of those different things. We
      4:13:38
      also want to be able to have a
      4:13:39
      permission for being able to create
      4:13:40
      different job listings. So, we'll come
      4:13:42
      in here with a permission for that.
      4:13:44
      There we go. We also want to be able to
      4:13:46
      delete different job listings. So, we'll
      4:13:48
      create a new permission for that.
      4:13:51
      And then finally, we're going to need a
      4:13:53
      permission for updating a job listing as
      4:13:55
      well. So, we'll come in here and again
      4:13:56
      just create a permission for that. And
      4:13:58
      the only reason I'm copy and pasting
      4:13:59
      this over is cuz this is all just text
      4:14:00
      that's behind the scenes. It doesn't
      4:14:02
      really matter. The only thing that
      4:14:03
      matters is what the actual key for our
      4:14:04
      permissions are because those are what
      4:14:06
      we use inside of our application. But
      4:14:08
      the nice thing is now we can assign
      4:14:09
      these to specific roles and we can
      4:14:10
      easily create new roles based on these
      4:14:12
      different permissions. So for our
      4:14:13
      applicant manager, we're going to edit
      4:14:15
      the roles that they have and we're going
      4:14:16
      to change it so they can do all the
      4:14:17
      applicant related stuff. So we're going
      4:14:19
      to update that role. Then we're going to
      4:14:21
      go down to our job listing manager and
      4:14:22
      we're going to do the exact same thing.
      4:14:24
      We're going to come in here and we're
      4:14:25
      going to change it so they can do all
      4:14:26
      the job listing related stuff. We're
      4:14:27
      going to set that as an updated role.
      4:14:29
      And then finally for our admin, we're
      4:14:31
      going to want to make sure that they
      4:14:32
      have permissions for all the job listing
      4:14:33
      and all the applicant stuff. And then we
      4:14:35
      can update that rule. So they have all
      4:14:37
      the permissions of everyone in our
      4:14:38
      application. So now we have our three
      4:14:40
      different roles set up to be able to use
      4:14:41
      in our application. And more
      4:14:42
      importantly, we have permissions set up,
      4:14:44
      which is something that we can use in
      4:14:45
      our application to make fine grained
      4:14:46
      control over who has access to
    </chapter>
    <chapter title="Billing setup" start_time="4:14:48">
      4:14:48
      everything. Now the next thing that we
      4:14:49
      need to work on is going to be the
      4:14:50
      billing section cuz we're also going to
      4:14:52
      be handling that through Clerk cuz it
      4:14:53
      has a really nice integration with
      4:14:54
      Stripe to make working with it super
      4:14:56
      easy, which is really nice. So we can
      4:14:57
      come into the settings for this. We can
      4:14:58
      make sure that we have everything
      4:14:59
      enabled. We have all of our rules and
      4:15:01
      everything. What we want to do is we
      4:15:02
      want to specifically deal with the
      4:15:03
      billing. So, we'll go to settings for
      4:15:04
      billing. And we want to specifically
      4:15:06
      create plans for our subscriptions. And
      4:15:08
      this is going to be specifically
      4:15:09
      organization billing. So, we'll go
      4:15:10
      subscription plans. We're going to click
      4:15:11
      get started. And we want to add an
      4:15:13
      organization plan cuz we're on an
      4:15:15
      organization. This very first plan is
      4:15:16
      going to be called basic. We'll give it
      4:15:18
      a slug of basic, which is the default.
      4:15:20
      We can add a description if we want, but
      4:15:21
      we'll leave that off. And we're going to
      4:15:22
      say that this is $100 a month. And we
      4:15:25
      can make it so it's $80 a month if you
      4:15:26
      pay annually. and we'll say that this is
      4:15:28
      publicly available. And then we can do
      4:15:30
      anything we want with adding specific
      4:15:32
      features down here. So we can add
      4:15:33
      features. If you want to be able to
      4:15:35
      interact with permissions, you need to
      4:15:36
      make sure that the permissions you
      4:15:38
      created, in our case, job listings and
      4:15:39
      job listing applications, those are
      4:15:41
      permissions we created. We need to
      4:15:42
      enable those to make sure everything's
      4:15:43
      working. We can also add new features if
      4:15:45
      we want. So I'm going to come in here
      4:15:46
      with a brand new feature that just says
      4:15:48
      create job listings. This is going to be
      4:15:51
      a publicly available feature. We're not
      4:15:52
      going to use this behind the scenes, but
      4:15:54
      it'll show up in the actual listing for
      4:15:55
      our job application so they can see what
      4:15:57
      they can do. So, we'll create that quick
      4:15:59
      permission right there. And we'll also
      4:16:01
      come in here. We'll add some more new
      4:16:02
      features inside of here. The next one is
      4:16:04
      going to be manage applicant workflow.
      4:16:08
      Again, not something we're going to use
      4:16:09
      on our application, but it's something
      4:16:10
      that shows up publicly, which is really
      4:16:12
      nice for doing the different things
      4:16:13
      inside of our features. And then
      4:16:15
      finally, we can have post one job
      4:16:18
      listing, just like that. And this is one
      4:16:20
      that will be used behind the scene to
      4:16:21
      limit which job listings they have
      4:16:22
      access to. Finally, we want to add those
      4:16:24
      additional two features to make sure
      4:16:26
      everything's hooked up properly. Give
      4:16:27
      that a quick save. And now you can see
      4:16:28
      these are the three things on our
      4:16:30
      listing that are going to show up.
      4:16:31
      Create job listings, manage applicant
      4:16:32
      workflow, and post one job listing. Now
      4:16:35
      we can go ahead and we can create some
      4:16:36
      other plans. Let's go back. We're going
      4:16:37
      to modify our free plan. Our free plan
      4:16:39
      already has these two on it, but we
      4:16:40
      don't want to make this publicly
      4:16:41
      available because you can't swap to the
      4:16:43
      free plan. You either just don't have an
      4:16:45
      organization or you have a plan. That's
      4:16:46
      really the only options you have.
      4:16:48
      There's really no free tier in this
      4:16:49
      application, but we need a free tier
      4:16:51
      just to make sure when you create an
      4:16:52
      organization, what are the bare minimums
      4:16:53
      you can do? And in our application, you
      4:16:55
      can create job listings. You just can't
      4:16:56
      post them until you pay for something.
      4:16:58
      So, now let's go ahead and we're going
      4:16:59
      to create another plan. This one is
      4:17:01
      going to be called growth. We're going
      4:17:02
      to come down to the fee for this one.
      4:17:04
      It's going to be $250 a month or it's
      4:17:06
      going to be $200 a month if you pay
      4:17:07
      annually. And then we can start adding
      4:17:09
      in all the different features we want.
      4:17:10
      We know that we want these features and
      4:17:12
      we also want these features. We want to
      4:17:13
      be able to post more than one job
      4:17:14
      listing though. So, we'll add these. And
      4:17:16
      then we're going to add our own new
      4:17:17
      features. So we're going to have post
      4:17:19
      three job listings. That allows you to
      4:17:21
      post up to three different job listings.
      4:17:23
      And then we also are going to add a
      4:17:25
      feature for one featured job listing.
      4:17:29
      And that's because some of our job
      4:17:30
      listings can be featured, which actually
      4:17:32
      show up at the top. They're like a
      4:17:33
      sponsored job listing. It adds an extra
      4:17:34
      incentive for people to pay more money
      4:17:36
      for these specific features. So now we
      4:17:38
      have all the features inside of our
      4:17:39
      growth plan. Now we can go ahead and we
      4:17:41
      can create what is going to be our final
      4:17:42
      plan. And this is going to be our
      4:17:44
      enterprise plan. Our enterprise plan is
      4:17:46
      going to be $1,000 a month or we're
      4:17:48
      going to charge $800 a month if you are
      4:17:50
      on the monthly or the annual payment. We
      4:17:52
      want to have all these but we want to
      4:17:54
      have different numbers of job listings
      4:17:55
      and featured jobs. So let's come in
      4:17:57
      here. We're going to add a feature. This
      4:17:58
      first feature is going to be post 15 job
      4:18:01
      listings. Just like that. And then we
      4:18:04
      also want to have a feature that is
      4:18:06
      going to be unlimited featured jobs or
      4:18:10
      job listings. There we go. And we'll
      4:18:12
      create that one as well. And we'll give
      4:18:13
      that a quick save. So now we have all of
      4:18:15
      our different pricing plans set up as
      4:18:17
      well as all of our permissions set up in
      4:18:18
      our application through clerk. All we
      4:18:20
      need to do is implement that into our
      4:18:21
      application. And again, we want to make
      4:18:22
      sure that we use features and
      4:18:24
      permissions and not roles and plans
      4:18:26
      because if we use roles and plans,
      4:18:27
      that's going to be ripe with error
      4:18:29
      because we want to change what
      4:18:30
      permissions roles have and so on. That's
      4:18:31
      impossible to do. So we want to make
      4:18:33
      sure we use the permissions and the
      4:18:34
      features to make things much more
      4:18:35
      flexible. So now back into our code,
    </chapter>
    <chapter title="Permission system" start_time="4:18:36">
      4:18:37
      let's implement this particular section.
      4:18:39
      We'll minimize all this down. We'll go
      4:18:40
      into our services for clerk. I have our
      4:18:42
      lib folder right here. I'm going to
      4:18:43
      create a brand new file called org user
      4:18:46
      permissions.ts
      4:18:48
      and it's going to export a simple async
      4:18:51
      function.
      4:18:53
      And this is going to be used for
      4:18:54
      checking the permissions. So we can say
      4:18:56
      has org user permissions or just
      4:18:59
      permission like that. There we go.
      4:19:04
      We'll get a user permission. This is
      4:19:06
      coming directly from our app. We're
      4:19:07
      going to create a type for that.
      4:19:10
      And this user permission is essentially
      4:19:11
      just a TypeScript type that matches the
      4:19:13
      permissions we typed into clerk. So you
      4:19:15
      can see here org job listing create, org
      4:19:17
      job listing update, or job listing
      4:19:19
      delete and so on. Same with the
      4:19:20
      applicant stuff down here. These are the
      4:19:21
      exact values we typed into clerk. This
      4:19:23
      just makes sure we have a type- safe way
      4:19:24
      of interacting with all these different
      4:19:26
      permissions. So now that we have all of
      4:19:28
      our permissions, we want to get the has
      4:19:30
      function from calling off from clerk.
      4:19:32
      That allows us to check permissions and
      4:19:34
      we can return has and we can pass it in
      4:19:36
      a permission. In our case, we want to
      4:19:37
      pass in whatever this permission is.
      4:19:39
      super straightforward and easy to work
      4:19:40
      with function. I'm now going to copy
      4:19:42
      this because we want to do the same
      4:19:43
      thing but for plan features. So I can
      4:19:45
      come in here plan features just like
      4:19:48
      that. And this plan features is going to
      4:19:50
      work pretty much the same up here. We're
      4:19:51
      going to be using our planned features.
      4:19:53
      Again, the exact same features I typed
      4:19:55
      into clerk one to one exactly what we
      4:19:57
      have. And then I want this to say has
      4:20:00
      plan feature. And this is going to take
      4:20:02
      in a feature and it's going to be of
      4:20:03
      type plan feature. And again clerk is
      4:20:06
      really nice. It just allows you to input
      4:20:07
      the feature and tell you if the user or
      4:20:09
      the organization has that permission or
      4:20:10
      that feature in their plan. So now let's
      4:20:12
      go through our application and actually
      4:20:13
      start working on implementing some of
      4:20:15
      these permission checks into the
      4:20:16
      different places in our application
      4:20:17
      where we're using it. So we can go into
      4:20:19
      our features folder where we have our
      4:20:21
      job listings. Let's go into our actions
      4:20:23
      here cuz we want to check to make sure
      4:20:24
      we have permission to do these different
      4:20:25
      things such as creating a job listing.
      4:20:28
      So anywhere in here, it really doesn't
      4:20:29
      matter. Let's just make it down here.
      4:20:31
      We're going to do a simple check.
      4:20:32
      Actually, we might as well do it up here
      4:20:33
      where we're checking our organization.
      4:20:35
      And we're just going to do a quick check
      4:20:36
      that says await has permission. There we
      4:20:39
      go. And we want to check a specific
      4:20:40
      permission. In our case, we want to
      4:20:41
      check can they create a job listing. And
      4:20:44
      we can just wrap that in some
      4:20:45
      parenthesis so we can make sure it's
      4:20:46
      awaited properly. And then we can put an
      4:20:48
      exclamation point in the front. And
      4:20:49
      that's essentially saying if our org ID
      4:20:51
      equals null or we don't have permission
      4:20:53
      to create a job listing, then make sure
      4:20:54
      we throw an error to let the user know
      4:20:56
      you don't have permission to do this
      4:20:57
      particular thing. We can do the exact
      4:20:59
      same thing down here for update. I'm
      4:21:01
      just going to put it right here, but
      4:21:02
      this one is going to be the update
      4:21:04
      version instead of the create version.
      4:21:06
      Now, again, we're checking permissions
      4:21:07
      properly for this, which is exactly what
      4:21:09
      we want. Now, I did notice as I'm
      4:21:10
      scrolling down, we never actually used
      4:21:12
      this job listing that we got to make
      4:21:13
      sure it existed. So, we can just come in
      4:21:15
      here if job listing is equal to null.
      4:21:19
      We want to return a new error. And we'll
      4:21:22
      just say that there is an error updating
      4:21:25
      your job listing. Same thing here.
      4:21:27
      Updating and you don't have permission
      4:21:28
      to update. There we go.
      4:21:31
      So now if we go back to our application,
      4:21:32
      everything still should work exactly the
      4:21:34
      same. If I try to edit this, we'll
      4:21:35
      change it to real title 2. I'll click
      4:21:37
      create. You can see it still renders out
      4:21:39
      just fine. But if I come in to clerk and
      4:21:41
      I go over to my user permissions and I
      4:21:43
      remove this permission from the admin
      4:21:44
      user, which is what I am. We'll come in
      4:21:46
      here. We're going to edit the role and
      4:21:48
      we're going to actually remove the
      4:21:49
      permission for updating a job listing.
      4:21:50
      There we go. I'm going to update that
      4:21:52
      role. So now I don't have permission to
      4:21:53
      update job listings. I'm going to go
      4:21:55
      into the edit page. So far we still
      4:21:56
      haven't locked this down. I'm going to
      4:21:57
      change it to 22. Click create. And I get
      4:21:59
      an error. you don't have permission to
      4:22:00
      update this job listing. So immediately
      4:22:02
      we can see that our permission system is
      4:22:04
      working just like we want it to. Let me
      4:22:05
      add that permission back because we do
      4:22:07
      want our admin users to be able to
      4:22:08
      update the job listings. And now when I
      4:22:10
      click create, you can see it updates to
      4:22:11
      that particular new title. Now one other
      4:22:13
      thing that I want to do just so we can
      4:22:14
      demonstrate what our icons look like.
      4:22:15
      I'm going to come in here. I'm going to
      4:22:16
      add a city. Doesn't really matter what
      4:22:18
      the city is. And I'm going to add a
      4:22:20
      wage. We'll just say it's going to be
      4:22:22
      sure that much money. And we'll click
      4:22:24
      create the job listing. And now you can
      4:22:25
      see here we have the icon for our
      4:22:27
      location as well as the wage being
      4:22:28
      displayed up here. So, we have those
      4:22:30
      badges working like we would expect them
      4:22:31
      to. Now, we can go ahead and actually
      4:22:32
      make it so that our UI implements these
      4:22:34
      different changes. So, for example, if I
      4:22:35
      don't have permission to edit, it won't
      4:22:37
      show me the edit button. So, I'm going
      4:22:38
      to go back into clerk. I'm going to
      4:22:39
      remove my ability to edit again just so
      4:22:41
      we can test what this looks like. Here
      4:22:43
      we go. I've removed the ability to edit.
      4:22:44
      Update that RO real quick. Come back
      4:22:46
      over here. And you can see the edit
      4:22:47
      button is still showing up. And we
      4:22:49
      obviously don't want that to show up.
      4:22:50
      So, let's go ahead and find where we can
      4:22:51
      change that in our UI. Well, we can go
      4:22:53
      into our app. We can go into the
      4:22:54
      employer section, job listings. We want
      4:22:56
      to go to the individual page where the
      4:22:58
      job listing is viewed. And here is where
      4:22:59
      our edit button is. It's directly inside
      4:23:01
      of this section. We essentially want to
      4:23:02
      do an if check that says if this
      4:23:04
      particular thing is true, render one
      4:23:06
      thing, otherwise don't render anything
      4:23:08
      or sometimes otherwise render some
      4:23:10
      fallback value. So we want to be able to
      4:23:11
      have essentially an if check inside of
      4:23:13
      our JSX code that's also dealing with
      4:23:15
      asynchronous code. This is something
      4:23:16
      that's kind of tricky to do. So we're
      4:23:18
      going to create a custom component to
      4:23:19
      handle this for us. And this custom
      4:23:21
      component we're just going to call async
      4:23:23
      if. And this is going to be a really
      4:23:24
      simple function that takes in a
      4:23:25
      condition that's going to be something
      4:23:27
      that evaluates and it's going to take in
      4:23:29
      some children and it's going to render
      4:23:30
      those children. We also can pass in some
      4:23:32
      loading fallbacks and some like else
      4:23:33
      conditions if we want. But for now, this
      4:23:35
      is the most basic use case for our async
      4:23:37
      if. So let's actually go ahead and
      4:23:38
      create this component. We'll do it
      4:23:40
      inside of our components folder. We'll
      4:23:42
      say async if.tsx.
      4:23:45
      We're going to export that function. And
      4:23:47
      again, like I mentioned, it's going to
      4:23:48
      take in some specific props. We'll just
      4:23:50
      type those up here. and we'll say that
      4:23:53
      our condition is going to be a function
      4:23:55
      that returns a promise.
      4:23:59
      There we go. So, it's going to return a
      4:24:00
      promise that gives us a boolean true or
      4:24:02
      false and it takes in no parameters at
      4:24:04
      all. Also, we're going to need to take
      4:24:05
      in some children.
      4:24:08
      This is a React node. We're also going
      4:24:09
      to take in a loading fallback. This is
      4:24:12
      because we're going to be dealing with
      4:24:13
      asynchronous stuff with suspense. So,
      4:24:14
      we're going to put in a loading fallback
      4:24:16
      option as well as an otherwise option.
      4:24:18
      Essentially an else condition. So like
      4:24:20
      you can say if true do this otherwise do
      4:24:22
      this particular thing. So now we have
      4:24:24
      all the different props that we need
      4:24:25
      inside of here. So we can say children
      4:24:28
      let me make sure I type this as props so
      4:24:29
      we get some nice autocomplete.
      4:24:32
      There we go. Get rid of my settings
      4:24:34
      there. And we have the otherwise prop.
      4:24:37
      So inside of here I want to return
      4:24:39
      suspense. We of course need to wrap
      4:24:40
      everything in suspense. And the fallback
      4:24:42
      for this is going to be our loading
      4:24:43
      fallback state. Then what I want to do
      4:24:45
      is I want to render essentially the
      4:24:47
      suspended component. So we'll say
      4:24:48
      suspended
      4:24:51
      component
      4:24:54
      function suspended component and this is
      4:24:57
      going to be asynchronous. And this is
      4:24:59
      going to take in essentially all the
      4:25:00
      props we had up here
      4:25:03
      minus one particular prop which is the
      4:25:05
      loading state. So we're going to take
      4:25:06
      our props minus our loading state. There
      4:25:08
      we go.
      4:25:11
      And that's going to give us all the
      4:25:12
      props that we have here which are
      4:25:13
      children, the condition, and the
      4:25:15
      otherwise clause. And this code is
      4:25:17
      really simple. All we're going to do is
      4:25:18
      call await on our condition. If the
      4:25:21
      condition is true, we render the
      4:25:23
      children. Otherwise, we render the else
      4:25:25
      condition, the otherwise condition.
      4:25:28
      Then we're just going to take our props
      4:25:29
      and pass them into here. So we have
      4:25:31
      children, which we need to pass in a
      4:25:33
      different way. So we'll say condition,
      4:25:35
      we'll say otherwise.
      4:25:38
      There we go. And then we're going to
      4:25:39
      pass in our children.
      4:25:43
      There we go. So now we have this
      4:25:45
      asynchronous if component. Make sure I
      4:25:47
      pass in my otherwise properly. There we
      4:25:49
      go. So essentially what this is doing is
      4:25:51
      it loads our fallback when we're
      4:25:52
      loading. Then if our condition is true,
      4:25:54
      it returns the children. Otherwise, it
      4:25:56
      returns this otherwise prop. So in our
      4:25:57
      particular case, we can say has user
      4:26:00
      permission to update a job listing. If
      4:26:04
      they have this particular permission,
      4:26:06
      which we're just going to wrap like
      4:26:07
      this, then we want to render the
      4:26:08
      children. Otherwise, we don't render
      4:26:10
      anything at all because we don't have an
      4:26:11
      otherwise condition being passed in. So
      4:26:12
      now you can see immediately the edit
      4:26:14
      button has disappeared because I do not
      4:26:15
      have permission to edit that particular
      4:26:17
      button. Now if I go into here and I add
      4:26:19
      permission back for me to be able to
      4:26:21
      edit that. So we'll come in here, make
      4:26:22
      my screen a little larger so we can
      4:26:24
      actually edit this and we'll go and
      4:26:26
      we'll add that permission back in. We'll
      4:26:27
      update our roll, minimize this back
      4:26:29
      down, and I refresh my page. Now the
      4:26:31
      edit button is back because I now have
      4:26:33
      that permission. Now the next few
    </chapter>
    <chapter title="Finish employer job listing page" start_time="4:26:34">
      4:26:34
      buttons we're going to create are going
      4:26:35
      to be much more complicated. So I'm
      4:26:36
      going to put them in their own separate
      4:26:38
      component. We'll say that we're going to
      4:26:39
      have the status update button just like
      4:26:43
      this. And at a base level, this button
      4:26:45
      is going to share some things in common
      4:26:47
      with this button. So, we'll just copy
      4:26:48
      this over as a baseline starting point,
      4:26:50
      but almost everything is going to be
      4:26:51
      different. We don't really care about
      4:26:53
      this being a link or anything like that.
      4:26:54
      And inside of here, for now, we'll just
      4:26:56
      say toggle. So, this is going to toggle
      4:26:57
      our status. Now, this is going to be
      4:26:59
      quite a bit more complicated because
      4:27:00
      we're going to need to wrap this inside
      4:27:02
      of multiple if checks. So, the very
      4:27:04
      first if check we're going to do is that
      4:27:05
      async if. And this very first async if
      4:27:08
      is just going to check do you have
      4:27:09
      permission to perform this action. So
      4:27:11
      our condition is going to be has
      4:27:15
      has or user permission and this is going
      4:27:18
      to be for changing the status of a job
      4:27:20
      listing for example from dellisted to
      4:27:21
      published or draft to published and so
      4:27:23
      on. So if we have this permission then
      4:27:25
      we want to render out for example our
      4:27:27
      button to toggle things. So now if we
      4:27:29
      have this permission it should actually
      4:27:30
      render that out if we put this on our
      4:27:32
      page. So up here we're going to render
      4:27:34
      out that button just like that. And now
      4:27:36
      we should see a button that says toggle
      4:27:37
      on our screen. If I just give my page a
      4:27:39
      refresh, it should hopefully show up.
      4:27:40
      Looks like it's not showing up though.
      4:27:42
      And that's because I need to get rid of
      4:27:43
      this as child. That makes it show up. So
      4:27:45
      now you can see we have a toggle button
      4:27:46
      showing up because we do have permission
      4:27:47
      to perform this action. But I actually
      4:27:49
      need a second if check here. And this
      4:27:51
      second if check that we're doing is also
      4:27:53
      going to check to make sure that the
      4:27:54
      user plan allows them to publish a job
      4:27:56
      listing in specific scenarios. So first
      4:27:59
      of all, I have to figure out are we
      4:28:00
      publishing this job? Because that's the
      4:28:02
      only time we have a limitation. So, I'm
      4:28:04
      going to come in here with a get next
      4:28:06
      job listing status function, which
      4:28:09
      allows us to pass in a job listing
      4:28:11
      status. So, of course, we need to make
      4:28:13
      sure we get our job listing status
      4:28:14
      passed into here, but allows us to pass
      4:28:16
      in a job listing status, and it'll tell
      4:28:17
      us what the next status is going to be.
      4:28:19
      For example, draft goes to published,
      4:28:21
      published goes to D-listed, and dlisted
      4:28:23
      goes back to published. So, let's
      4:28:25
      actually create a nice little handy
      4:28:26
      function for this, and we're going to do
      4:28:27
      this inside of a utils folder inside of
      4:28:29
      our section for job listings. So, we'll
      4:28:31
      create a brand new file in our lib.
      4:28:34
      Actually, we'll just call this utils.ts.
      4:28:37
      And we want to export a function called
      4:28:40
      get next job listing status. It takes in
      4:28:42
      a job listing status just like that. And
      4:28:46
      we essentially just want to do a
      4:28:47
      switched case. I'm just going to copy it
      4:28:48
      over because it's really basic. You can
      4:28:50
      see here, we'll call this status. If
      4:28:53
      we're in the draft or delisted case, our
      4:28:55
      status goes to published. If we're in
      4:28:56
      the published case, it goes to delisted.
      4:28:58
      So it's kind of almost like a state
      4:29:00
      machine for what our next state is going
      4:29:01
      to be that we can move into. So once we
      4:29:03
      have that done, we can import that from
      4:29:05
      here. And we need to make sure that we
      4:29:06
      actually get our status into this
      4:29:07
      button. So I can say status just like
      4:29:09
      that. And this is going to be status
      4:29:12
      which is a job listing status.
      4:29:15
      There we go. And now all the way up here
      4:29:16
      where we use this button, I can say job
      4:29:19
      listing status.
      4:29:21
      Okay, there we go. So now I'm
      4:29:23
      essentially checking. Okay, let's get
      4:29:24
      the next job listing status. You can see
      4:29:25
      right here it's already printing out
      4:29:27
      published. I know that if the next job
      4:29:29
      listing status is published, then I want
      4:29:31
      to render some particular code. In my
      4:29:33
      case, that's going to be the code that
      4:29:34
      checks to see if we can do this thing.
      4:29:36
      So, I'm going to put a little if check
      4:29:37
      here. There we go. Move this all the way
      4:29:40
      down. Otherwise, we want to render out
      4:29:42
      essentially just our button. So, we're
      4:29:43
      going to take our button and move it
      4:29:44
      down here. And I'm actually going to
      4:29:45
      take our button, we'll put it in its own
      4:29:47
      file or in its own variable. So, we'll
      4:29:49
      say button is equal to this.
      4:29:52
      There we go. And now, in both places
      4:29:54
      where we use this, we can just render
      4:29:56
      out the button. That way we essentially
      4:29:57
      share that logic between the different
      4:29:58
      places we're using it. So now you can
      4:30:00
      see in one case if our next status is
      4:30:03
      going to be published, we want to check
      4:30:04
      to make sure the organization has the
      4:30:05
      ability to do this. Then what we're
      4:30:07
      going to do if it's not going to
      4:30:08
      published, well, we can dellist any job
      4:30:10
      we want whenever we want. So we're just
      4:30:12
      going to render the button just fine.
      4:30:13
      Now this one is going to be checking a
      4:30:15
      plan feature. So we're going to say has
      4:30:17
      plan feature and we need to make sure we
      4:30:18
      pass in the particular plan feature. And
      4:30:20
      you can see this is a little bit
      4:30:21
      confusing because we have a feature for
      4:30:22
      one job listing, three job listings, and
      4:30:24
      15. So, we're going to have a lot of
      4:30:26
      different if checks here. So, I'm going
      4:30:27
      to create a helper function instead.
      4:30:29
      This helper function is going to be
      4:30:30
      called has reached max featured job
      4:30:34
      listings. Just like that, we're going to
      4:30:36
      get a variable from that. Const is maxed
      4:30:40
      equals waiting that. So, we'll put an
      4:30:42
      async here.
      4:30:46
      Make sure that I get all of this in the
      4:30:47
      right location. There we go. And then
      4:30:50
      what I want to do is I just want to
      4:30:51
      return the opposite of is maxed.
      4:30:54
      There we go. So now I need to create
      4:30:56
      this has reached max feature job
      4:30:58
      listings. Now I'm going to create a
      4:31:00
      brand new file for that. So we can go
      4:31:01
      down into our lib folder again here. I
      4:31:03
      want to create a plan feature helpers.ts
      4:31:06
      and we're going to export a function
      4:31:08
      with that exact name. And I'm going to
      4:31:09
      make sure that this is asynchronous. So
      4:31:12
      the first thing that I want to do inside
      4:31:13
      of here is to figure out what
      4:31:14
      organization you're in. So we can get
      4:31:16
      our org ID which is equal to a way to
      4:31:18
      get current organization. And then if
      4:31:21
      the org ID is equal to null,
      4:31:25
      well then we just want to return true
      4:31:26
      because obviously if you don't have an
      4:31:27
      organization, you can't post anything.
      4:31:29
      It doesn't make any sense. Then we want
      4:31:31
      to get the count, which we're going to
      4:31:32
      create a function for called get
      4:31:33
      published job listings count for our org
      4:31:37
      ID. Now, this function I'm just going to
      4:31:38
      paste down because it's relatively
      4:31:40
      straightforward. I'll explain it. Don't
      4:31:41
      worry, not going to be jumping past it.
      4:31:43
      Let me just get all my imports in place,
      4:31:44
      though. Get our job listing table and
      4:31:47
      get all of our different wear clauses
      4:31:49
      inside of here. So essentially what this
      4:31:51
      little bit of code is doing and it looks
      4:31:52
      like actually I imported the wrong count
      4:31:53
      variable. So let me make sure here I
      4:31:55
      import the count from drizzle. There we
      4:31:56
      go. So what this code is doing is we're
      4:31:58
      just selecting the count of the job
      4:32:00
      listing table for only the job listings
      4:32:02
      for a specific organization ID and if
      4:32:04
      specifically published. So it's just
      4:32:05
      going to add up all the job listings
      4:32:07
      that are published inside of this
      4:32:08
      organization and it's going to return
      4:32:10
      the count or if there's no job listings
      4:32:11
      it'll return zero as the count. So it'll
      4:32:13
      always either be the number of job
      4:32:15
      listings in the row or zero. Then once
      4:32:16
      we have that we can essentially create a
      4:32:18
      check which is const can post and we'll
      4:32:20
      call await promise.all and we just need
      4:32:23
      to check which one of these permissions
      4:32:24
      the plan has. So we can say has plan
      4:32:26
      feature for post one job listing and
      4:32:29
      then we can just extend upon that by
      4:32:31
      saying
      4:32:33
      this is the has property and we'll say
      4:32:35
      and count is less than one. So if they
      4:32:37
      have permission to do this and the count
      4:32:39
      is less than one which is how many they
      4:32:40
      can post we say that they are able to do
      4:32:42
      this. So it returns true. I then need to
      4:32:45
      copy this down for three job listings
      4:32:46
      must be less than three. And then we
      4:32:48
      also have the ability for 15 job
      4:32:50
      listings and this must be less than 15.
      4:32:52
      So all of these are going to return true
      4:32:54
      if they have the permission for it and
      4:32:56
      if they have less than that number of
      4:32:58
      job listings. Then what we can do is we
      4:33:00
      can just return can post dot sum and we
      4:33:03
      can pass in a boolean here. What that's
      4:33:05
      going to do is it's going to say does
      4:33:06
      any value in this array equate to true?
      4:33:08
      That means are any of these true? If so,
      4:33:10
      this is going to return true. And then
      4:33:12
      it negates it to return false because
      4:33:14
      this is for have we reached the max
      4:33:15
      number of job listings. So if we've
      4:33:17
      reached the max number of job listings,
      4:33:18
      this is going to return true. So now
      4:33:20
      that we have that set up, we can
      4:33:21
      actually use that inside of here by just
      4:33:23
      saying has reached the max number of job
      4:33:25
      listings. If we've not reached the max
      4:33:26
      number of job listings, then render out
      4:33:28
      our button in this particular section
      4:33:30
      right here. In our case, you'll notice
      4:33:32
      that our button has actually
      4:33:33
      disappeared. And that's because we have
      4:33:34
      reached the max number of job listings
      4:33:36
      because we don't have a plan. We're on
      4:33:37
      the free plan. So, this button has
      4:33:39
      completely disappeared. Now, this isn't
      4:33:41
      quite what I want, though, because if we
      4:33:43
      are trying to publish the job and we're
      4:33:44
      not able to, I want to still show the
      4:33:46
      button, but I want them when they click
      4:33:48
      on the button to be told, hey, you can't
      4:33:49
      do this. You need to upgrade your plan.
      4:33:51
      This allows me to essentially try to
      4:33:53
      sell them on upgrading their plan when
      4:33:54
      they try to do something instead of them
      4:33:56
      just not knowing they can't do this
      4:33:57
      thing. So, we're going to put an
      4:33:59
      otherwise clause in here, and this is
      4:34:00
      what renders whenever we fail the check.
      4:34:02
      So, for example, if I just put some
      4:34:04
      random text in here, you can see that
      4:34:05
      that text shows up because we are
      4:34:06
      failing this particular check. And here
      4:34:08
      is where I want to add some even more
      4:34:10
      complicated code for adding a popover.
      4:34:12
      And I believe we're going to need to add
      4:34:14
      this directly from shad CN. So, we'll
      4:34:15
      say pop over. We're going to make sure
      4:34:17
      that we force install this. So, it's
      4:34:19
      going to work with our version of Nex.js
      4:34:20
      since we're on the Canary version. And
      4:34:22
      now inside the popover, we're going to
      4:34:24
      use a popover trigger just like that.
      4:34:26
      This is going to be set to as child
      4:34:27
      because it's essentially just going to
      4:34:28
      render a button. Let me make sure I
      4:34:30
      import this properly. There we go. And
      4:34:33
      then inside of here, we want a button
      4:34:35
      with a variant of outline.
      4:34:39
      There we go. Close off our button. And
      4:34:41
      inside of here, we want the status
      4:34:43
      toggle button text, which is a function
      4:34:45
      we're going to create that allows us to
      4:34:47
      just get whatever the text and icon is
      4:34:49
      for this. So, we're going to take in our
      4:34:50
      job listing. Whoops. Job listing.
      4:34:53
      Actually, we already have our status.
      4:34:55
      It's just the status right there. So,
      4:34:57
      let's go ahead and create this function
      4:34:59
      all the way down here. here. It doesn't
      4:35:00
      really matter where.
      4:35:02
      And it's going to take in a status which
      4:35:04
      is a job listing status. Now, this is
      4:35:06
      again code I'm fine with just copying
      4:35:08
      and pasting over because essentially
      4:35:09
      it's just a switch statement. If we are
      4:35:11
      in the D-listed state or the draft
      4:35:13
      state, it's going to say publish while
      4:35:15
      if we're in the publish state, it'll say
      4:35:16
      D-list. So, we can swap between whatever
      4:35:18
      state we want to be in. So, now you can
      4:35:20
      see it says publish right here, but
      4:35:21
      we're inside of a popover. So, what
      4:35:23
      should our popover content look like?
      4:35:25
      Well, we can come over here. We can say
      4:35:26
      popover content. And the very first
      4:35:28
      thing that I want to do inside my
      4:35:29
      popover content is have some text
      4:35:31
      essentially telling them you must
      4:35:32
      upgrade. So we're going to copy some
      4:35:33
      text you must upgrade your plan to
      4:35:35
      publish more job listings. Then I want
      4:35:37
      to create a button that brings them to
      4:35:38
      the page to upgrade their plan. So we
      4:35:40
      can say as child is a link with an href.
      4:35:43
      And this href is going to be
      4:35:45
      employer/pricing.
      4:35:48
      And this is going to say upgrade plan
      4:35:50
      just like that. And then inside of our
      4:35:52
      popover trigger, we're going to add a
      4:35:53
      class name to this, which is going to be
      4:35:55
      flex
      4:35:58
      flex column and a gap of two just to
      4:36:00
      give us a little bit of space between
      4:36:01
      those. So now when we click on this, you
      4:36:03
      can see we must upgrade our plan. And of
      4:36:05
      course, it looks like I imported
      4:36:06
      something from the wrong location. So
      4:36:07
      let me make sure I fix that. Here we go.
      4:36:09
      Popover content was imported from the
      4:36:11
      wrong location. Get that from the right
      4:36:14
      location. And now hopefully when I click
      4:36:15
      on that, you can see you must upgrade
      4:36:17
      your plan to publish more job listings.
      4:36:18
      Click on this and it'll bring me to the
      4:36:20
      pricing page which we have yet to
      4:36:21
      implement. Now, this seems like just as
    </chapter>
    <chapter title="Pricing page" start_time="4:36:22">
      4:36:23
      good a place as any to implement the
      4:36:24
      pricing page. And luckily, the pricing
      4:36:26
      page is actually incredibly easy to
      4:36:27
      implement. So, we're going to go over
      4:36:29
      and we're going to create a pricing page
      4:36:30
      inside of employer. So, we'll create a
      4:36:32
      new folder called pricing. And inside of
      4:36:34
      here, we'll create a page called
      4:36:35
      page.tsx.
      4:36:36
      And I'm just going to copy the code
      4:36:38
      because it's actually dead simple. We
      4:36:39
      essentially are just importing one
      4:36:41
      single thing, which is our pricing table
      4:36:42
      directly from Clerk. Now, instead of
      4:36:44
      directly importing this from Clerk, I'm
      4:36:46
      actually going to change this slightly.
      4:36:47
      I'm going to create my own custom
      4:36:49
      pricing table component that we import
      4:36:51
      from just because it's going to allow me
      4:36:53
      to configure specific things that I
      4:36:54
      want. So, inside my components, we're
      4:36:56
      going to come in here with our pricing
      4:36:57
      table. Export a function with that exact
      4:37:00
      name. And we need to make sure we import
      4:37:03
      pricing table as clerk pricing table
      4:37:06
      from. And that's at clerk/next.js. There
      4:37:09
      we go. And then we can just return
      4:37:12
      our clerk pricing table. And
      4:37:14
      specifically, I want to make sure that
      4:37:15
      we're only doing this for organizations.
      4:37:17
      And our new subscription
      4:37:19
      redirect URL is going to redirect us
      4:37:21
      back to the page we're currently on.
      4:37:24
      So employer/pricing.
      4:37:26
      So when they upgrade or change their
      4:37:27
      plan, instead of redirecting them to a
      4:37:29
      new page, it just keeps them on the same
      4:37:30
      page so they can easily see what they
      4:37:32
      swapped between. So now let's import
      4:37:34
      pricing table from our own custom
      4:37:36
      component. And now we should see that
      4:37:37
      our pricing table shows up. But of
      4:37:39
      course, it can't be rendered when
      4:37:40
      billing is disabled. We need to make
      4:37:41
      sure we enable billing on our
      4:37:42
      application. So, we can come over to our
      4:37:44
      application. We can go to the settings
      4:37:46
      for billing. And we want to make sure
      4:37:47
      it's enabled. I just clicked on the
      4:37:49
      button for enable billing. I can disable
      4:37:50
      it again if you want. And then we can
      4:37:52
      click enable billing right here. And
      4:37:53
      then we're just going to use the clerk
      4:37:54
      payment gateway to handle everything for
      4:37:56
      us. No configuration, nothing like that.
      4:37:57
      So, now we have billing enabled. And we
      4:37:59
      have our subscription plan set up for
      4:38:01
      our user. So, all of that is ready to
      4:38:02
      go. So, now we should see if we refresh
      4:38:04
      our page, you can see we get our pricing
      4:38:06
      plans on the right hand side of our
      4:38:07
      page. And depending on what screen size
      4:38:09
      we have, you can see it's super mobile
      4:38:10
      responsive, which is really great. It's
      4:38:11
      kind of big cuz I'm super zoomed in, but
      4:38:13
      that's just so it's easier for you to
      4:38:14
      see. But now, we can subscribe to any of
      4:38:16
      these plans we want. So, we can toggle
      4:38:17
      between annual and non- annual. Let's
      4:38:19
      say that we wanted to describe to just
      4:38:20
      the basic plan that allows us to post
      4:38:22
      one job. Come in here. We'll click pay
      4:38:23
      with test card because we're in
      4:38:25
      development mode. And there we go.
      4:38:26
      Payment successful. We can click
      4:38:27
      continue. And now we're on this plan.
      4:38:29
      You can see it's active. All that fun
      4:38:30
      stuff. And we can go back to the job
      4:38:31
      listing we're on. I'm just going to use
      4:38:32
      the back button to get here. But now you
      4:38:34
      can see we have the ability to toggle
      4:38:36
      this, which means that we have passed
      4:38:37
      both of those different checks that we
      4:38:39
      were trying to pass. So let's go back to
      4:38:40
      the page that we were just working on.
      4:38:43
      There we go. We're on that page.
      4:38:45
      Actually, no, this is the wrong page. So
      4:38:46
      let's make sure we're on the correct
      4:38:47
      page. Here we go. And I want to kind of
    </chapter>
    <chapter title="Finish employer job listing page (continued)" start_time="4:38:48">
      4:38:49
      extract this popover into its own
      4:38:51
      function. So we'll just say upgrade
      4:38:54
      popover.
      4:38:57
      There we go. We're going to return this
      4:38:59
      popover content. And I specifically want
      4:39:01
      to be able to put whatever text is going
      4:39:03
      to be on the button. So we'll say button
      4:39:04
      text. And we're going to say popover
      4:39:06
      text.
      4:39:09
      And these are just going to be different
      4:39:10
      things. So we're going to say button
      4:39:11
      text is a React node. And we have our
      4:39:14
      popover text, which is also going to be
      4:39:17
      a React node. There we go. So now in
      4:39:19
      this section, I can essentially just put
      4:39:21
      whatever my button text is. And then
      4:39:24
      inside of this section, I can put my
      4:39:27
      popover text. This will just make it
      4:39:29
      easier for me to repeat this because I'm
      4:39:30
      going to use this in multiple places. So
      4:39:32
      now up here where I want my upgrade
      4:39:33
      popover, it's also going to clean up the
      4:39:35
      code in here because it's going to look
      4:39:36
      a little bit better. So we're going to
      4:39:38
      have our button text which is equal to
      4:39:40
      this.
      4:39:42
      And then we're going to have our popover
      4:39:44
      text which is going to be equal to this
      4:39:46
      right here.
      4:39:48
      There we go. Now I get rid of all this
      4:39:50
      and just makes my code a little bit
      4:39:51
      cleaner and easier to work with. And it
      4:39:52
      still does the exact same thing. Now,
      4:39:54
      the next thing that we're going to do is
      4:39:55
      we're going to create another helper
      4:39:56
      component because this button when we
      4:39:57
      click on it, we want it to toggle the
      4:39:59
      state of published versus unpublished.
      4:40:01
      And we don't want it to move pages or
      4:40:02
      anything like that. It's just going to
      4:40:03
      stay on the current page, show us a
      4:40:04
      loading spinner, and if it's successful,
      4:40:06
      pop up a toast, or if there's an error,
      4:40:07
      it'll pop up a toast as well, just to
      4:40:09
      let us know, hey, what's going on with
      4:40:10
      this particular thing? So, we can create
      4:40:12
      a nice little helper component for this
      4:40:13
      in our components folder. We're going to
      4:40:15
      call this action button because it's
      4:40:16
      going to be a button that when you click
      4:40:18
      performs a server action for us. Let's
      4:40:20
      minimize all this down so we have a
      4:40:21
      little bit more room to work with. We'll
      4:40:23
      export a function called action button.
      4:40:27
      This is going to take in an action that
      4:40:28
      we want to perform. We're going to have
      4:40:30
      an option for require are you sure which
      4:40:32
      is really great for when we have things
      4:40:33
      that we want the user to perform
      4:40:35
      additional validation by clicking an are
      4:40:37
      you sure button. We're also going to
      4:40:38
      have an are you sure description
      4:40:41
      which by default just says this action
      4:40:44
      cannot be undone. Sometimes you may want
      4:40:46
      to customize what this specifically
      4:40:48
      says. And then finally, we're just going
      4:40:49
      to have all of our additional props for
      4:40:51
      our essentially our button that we're
      4:40:52
      going to be using. Now, what we're going
      4:40:54
      to do is we're going to take in our
      4:40:55
      component props for our button, and
      4:40:58
      we're going to make sure it's with a
      4:40:59
      ref. So, we're going to say component
      4:41:00
      props with a ref type of button. Just
      4:41:03
      like that. And this is the button coming
      4:41:04
      from shad CN. Make sure we import that
      4:41:06
      properly. And we're going to get rid of
      4:41:08
      the onclick property because we're going
      4:41:09
      to override that ourselves. Then we're
      4:41:11
      going to take whatever these omit
      4:41:13
      properties are and we're going to add on
      4:41:15
      to them by just using an amperand here
      4:41:17
      to give us our extra props for action.
      4:41:19
      Require are you sure
      4:41:22
      which we can just say that's a boolean.
      4:41:24
      And then finally an are you sure
      4:41:27
      description
      4:41:30
      and this is just a string. And this one
      4:41:32
      is going to be optional. This one is
      4:41:34
      going to be optional. And finally for
      4:41:36
      our action this is going to be a
      4:41:37
      function that returns a promise. And
      4:41:39
      this promise is going to have an error
      4:41:41
      which is a boolean and a message which
      4:41:44
      is optional and is a string. There we
      4:41:46
      go. Now also we're going to mark this as
      4:41:48
      a client component. So we're going to
      4:41:49
      come up here use client and then we can
      4:41:53
      actually define what this function is
      4:41:54
      going to look like on the inside. So the
      4:41:56
      first thing I want to do is I want to be
      4:41:57
      able to handle a loading state. And on
      4:41:58
      the client side the best way to do that
      4:42:00
      is with a transition. So we'll say const
      4:42:03
      is loading and start transition
      4:42:07
      is going to be equal to use transition
      4:42:09
      just like that. And then we want a
      4:42:10
      function that's going to be for
      4:42:12
      performing our action. So we're going to
      4:42:13
      call this perform action cuz we're going
      4:42:14
      to use this in a few different places.
      4:42:16
      We're going to call start transition
      4:42:18
      which is going to be an asynchronous
      4:42:19
      function. And this asynchronous function
      4:42:21
      essentially is just going to call our
      4:42:22
      action. So our data is equal to
      4:42:24
      await.action.
      4:42:26
      And then we're going to say if our data
      4:42:28
      has an error,
      4:42:30
      make sure I await this properly. There
      4:42:31
      we go. If our data has an error, then
      4:42:33
      what we want to do is we want to render
      4:42:34
      out a toast. That is an error toast that
      4:42:36
      says data. And if we have no message,
      4:42:39
      it'll just say error. There we go. So
      4:42:41
      that's what we do to perform our action.
      4:42:42
      Start up a transition, run the code.
      4:42:44
      It's going to give us all of our loading
      4:42:45
      states and everything for us
      4:42:46
      automatically, which is great. The next
      4:42:48
      thing we need to do is first of all if
      4:42:50
      we require
      4:42:52
      an are you sure dialogue we need to put
      4:42:53
      that inside of an alert dialogue which I
      4:42:55
      believe we need to import from shad cen.
      4:42:57
      So let's go ahead and do that.
      4:43:00
      There we go. Get that. And I'm going to
      4:43:01
      have to force install that. I'm almost
      4:43:03
      certain. There we go. Otherwise, if we
      4:43:05
      don't require this, we can just return a
      4:43:07
      simple button. So we're going to come in
      4:43:08
      here with our button code. It's going to
      4:43:10
      take in all of our different props. Just
      4:43:12
      like that. There we go. And inside of
      4:43:15
      here, we want to make sure our disabled
      4:43:16
      is equal to is loading. And we want to
      4:43:18
      make sure our on click is handled
      4:43:20
      properly by the perform action. There we
      4:43:22
      go. Then what we can do inside of our
      4:43:24
      button is we can use that nice loading
      4:43:26
      swap component that we already created
      4:43:28
      earlier to be able to swap between our
      4:43:30
      is loading state and so on. So is
      4:43:32
      loading is just equal to is loading. And
      4:43:35
      then we can say that we want to have
      4:43:36
      some class names of inline, flex, items,
      4:43:39
      center, and gap 2 just to make sure
      4:43:41
      everything looks like we want it to. And
      4:43:43
      in here we can put our props. There we
      4:43:45
      go. That's all we need to do to render
      4:43:47
      out everything in this section. In the
      4:43:49
      require are you sure section we just
      4:43:50
      need to essentially do that same thing
      4:43:52
      but put it inside of an alert dialogue.
      4:43:54
      So we have an alert dialogue. The open
      4:43:56
      state of this is specifically tied to is
      4:43:58
      loading. So if is loading is true. Then
      4:44:00
      we want to make sure that this is open.
      4:44:02
      Otherwise we're going to set this to
      4:44:03
      undefined. By setting to undefined we
      4:44:05
      essentially say hey shad CN you handle
      4:44:07
      what the open state is. Otherwise I'm
      4:44:09
      going to say only force it to be open
      4:44:10
      when we're loading. The reason for this
      4:44:11
      is normally when you click on the submit
      4:44:13
      button for an alert dialogue, it
      4:44:14
      automatically closes and we don't get
      4:44:16
      that loading feedback. So that's why I'm
      4:44:17
      making sure it's forced to be open. Now
      4:44:19
      here we have our alert dialogue trigger.
      4:44:21
      I'm going to set this as a child and
      4:44:23
      that's because it's going to render out
      4:44:24
      our button and our button is just going
      4:44:26
      to take in all of our different props.
      4:44:28
      So either our button is going to render
      4:44:29
      on its own down here or it's going to
      4:44:31
      render up here inside of our alert
      4:44:33
      dialogue trigger. Just like that. And it
      4:44:35
      looks like I maybe imported the wrong
      4:44:37
      one or I just didn't import it at all.
      4:44:38
      There we go. Now we have our alert
      4:44:40
      dialogue content. And inside of our
      4:44:43
      alert dialogue content, we need a
      4:44:44
      header.
      4:44:47
      Oops. Dialogue header. There we go.
      4:44:49
      Inside of that
      4:44:52
      dialogue title. This is just going to
      4:44:54
      say, "Are you sure?" And then we also
      4:44:57
      need a description. Alert dialogue
      4:44:59
      description. And this is going to be
      4:45:01
      where we put in that are you sure
      4:45:03
      description. There we go.
      4:45:06
      Make sure I copy this over. Finally,
      4:45:08
      after our header, we're just going to
      4:45:09
      jump straight to the footer. Alert
      4:45:10
      dialogue footer because all we really
      4:45:12
      want to do is put in our buttons. So,
      4:45:14
      we're going to have alert dialogue
      4:45:15
      cancel button.
      4:45:17
      There we go. This is just going to say
      4:45:19
      cancel. And then below that, we're going
      4:45:21
      to have our alert dialogue action. And
      4:45:23
      this is the thing that allows us to
      4:45:24
      actually perform whatever action we
      4:45:26
      want. So, this is going to say yes. And
      4:45:29
      then inside of here, we can essentially
      4:45:30
      put a disabled state. That's going to be
      4:45:33
      equal to is loading. We can also come in
      4:45:35
      here with an on click.
      4:45:39
      There we go. The on click is going to be
      4:45:40
      equal to perform action. Make sure I
      4:45:43
      spell everything properly. And then
      4:45:44
      instead of just being the text, yes, of
      4:45:46
      course, we want to put that inside of
      4:45:48
      our loading swap animation.
      4:45:50
      And is loading is equal to is loading.
      4:45:53
      There we go. Close that off. Move that
      4:45:55
      down. And now we have our dialogue
      4:45:57
      version as well. We can return that
      4:45:58
      right here. So if we ask for a dialogue,
      4:46:00
      we get this big dialogue. Otherwise, we
      4:46:02
      just get the button on its own. And
      4:46:03
      really all this code is for is just to
      4:46:05
      make it so when we click a button, it
      4:46:06
      does something and sometimes it asks us
      4:46:08
      permission before we actually do that
      4:46:09
      thing. So now inside of the code for our
      4:46:12
      job listing up here where we have our
      4:46:13
      button, we can use that brand new alert
      4:46:15
      button that we just created, which is
      4:46:17
      alert button. Actually, it's not alert,
      4:46:19
      I'm sorry, it's action button. There we
      4:46:22
      go. And inside of here, we can put
      4:46:24
      whatever text we want. We already know
      4:46:25
      what that text is. It's just this text
      4:46:27
      right here. That's why we created a
      4:46:28
      function for this to make it easier to
      4:46:29
      work with. And now we have our alert
      4:46:31
      button or action button. And we can
      4:46:33
      specify what our action is going to be.
      4:46:34
      This is going to be for toggling the
      4:46:36
      status of our job listing. We'll get to
      4:46:37
      that in a little bit. We can also
      4:46:38
      specify that we want to require are you
      4:46:40
      sure? And we only require are you sure
      4:46:42
      if it's going to be publishing a job. So
      4:46:45
      we can say require are you sure is get
      4:46:47
      next job listing status. Pass in our
      4:46:49
      current status. If that is equal to
      4:46:51
      published, well that means that we're
      4:46:53
      going to be publishing this job. So we
      4:46:54
      probably want to make sure that they're
      4:46:55
      sure they want to publish the job. Also,
      4:46:58
      our are you sure description will just
      4:46:59
      say this will immediately show this job
      4:47:03
      listing to all users. There we go. Just
      4:47:05
      so they're aware of what's going to
      4:47:06
      happen if they click the button. Lastly,
      4:47:08
      I'm going to add in a variant. This is
      4:47:11
      going to be an outline variant. And then
      4:47:12
      we can finally manage our action, which
      4:47:15
      is going to be toggle job listing
      4:47:17
      status. And we're just going to bind
      4:47:20
      null and ID. So, it's essentially going
      4:47:22
      to call this function with null. And the
      4:47:24
      ID is going to be the very first
      4:47:25
      property. Another way that we could do
      4:47:26
      this is writing the code like this. And
      4:47:28
      then we could just pass in ID. Both of
      4:47:31
      these are going to work just fine. We
      4:47:32
      just need to create this function now.
      4:47:33
      And actually, we can't do this by
      4:47:35
      passing a function because we're in a
      4:47:36
      server component. So instead, we're
      4:47:37
      going to change it back to the bind
      4:47:38
      version because that does allow us to
      4:47:40
      pass it around. So now let's actually go
      4:47:41
      ahead and implement this. It's going to
      4:47:43
      be an action. So we're going to go into
      4:47:45
      our job listing features and we're going
      4:47:47
      to go into the actions and we're going
      4:47:48
      to create a brand new action for that.
      4:47:51
      It's going to be asynchronous. We're
      4:47:52
      going to export it. There we go. Inside
      4:47:55
      this function, we're going to do a lot
      4:47:56
      of the same stuff we did up here. So,
      4:47:58
      I'm going to kind of copy this. We'll
      4:47:59
      obviously change some of it, but it's
      4:48:00
      going to take in an ID that is a string.
      4:48:02
      And then we need to make some checks.
      4:48:04
      First of all, we're going to check, hey,
      4:48:05
      do we have an organization? So, first of
      4:48:07
      all, check, do we have an organization?
      4:48:08
      Then, we need to make sure that we check
      4:48:10
      to see if they can actually do this
      4:48:11
      particular thing. And to make this a
      4:48:12
      little bit easier, I'm going to come up
      4:48:14
      here. I'm going to say error is equal
      4:48:15
      to, and I'm essentially just going to
      4:48:16
      copy this object. So, we're going to
      4:48:18
      copy this up into here, and we'll just
      4:48:20
      say you don't have permission to update
      4:48:21
      this job listing status. There we go.
      4:48:25
      Now we have an error that we can use and
      4:48:26
      like here for example we can return an
      4:48:28
      error whenever the organization is equal
      4:48:30
      to null and we'll just get it like that.
      4:48:33
      Next thing I'm going to check is going
      4:48:34
      to be my job listing. So we'll move that
      4:48:35
      up just like that. So we're going to
      4:48:37
      check to see if we have a job listing
      4:48:39
      and the rest of the section we don't
      4:48:40
      even need. And here we'll return an
      4:48:42
      error if we don't have a job listing.
      4:48:43
      And again we'll just put it on one line
      4:48:45
      for a little bit of ease of use to look
      4:48:46
      at. Next we're going to figure out what
      4:48:48
      the new status is going to be by calling
      4:48:50
      that get next job listing status. And of
      4:48:53
      course, we need to pass in our job
      4:48:55
      listing status. There we go. So, this is
      4:48:58
      going to get whatever the new status is
      4:48:59
      from our job listing. And it looks like
      4:49:01
      we aren't getting a status being
      4:49:03
      returned from this or something is
      4:49:05
      happening that's not quite right. Let's
      4:49:06
      look at get job listing. Looks like that
      4:49:08
      should be returning our status for us.
      4:49:10
      And the reason it's not working is cuz I
      4:49:11
      didn't await the get job listing. And I
      4:49:13
      believe I need to make sure I wait it up
      4:49:14
      here. Otherwise, again, we'll have some
      4:49:16
      errors. So, let me make sure I wait that
      4:49:17
      up there. So, that bolt is working just
      4:49:19
      fine. Now what we can do is we can kind
      4:49:20
      of do our big if check. First of all we
      4:49:22
      can check to see has org user permission
      4:49:25
      and we want to check did they have the
      4:49:26
      ability to change the status of a job
      4:49:28
      listing. We'll await that and then we'll
      4:49:30
      negate that as well. So we'll check
      4:49:32
      essentially hey do you have the ability
      4:49:34
      to perform this particular action and
      4:49:36
      we're going to come in here with an
      4:49:37
      error. So if you don't have the ability
      4:49:39
      to perform this action we're going to
      4:49:40
      return an error. Next, we're going to be
      4:49:42
      checking to see if the new status
      4:49:46
      is equal to published. And we want to
      4:49:50
      check to see have we reached the max
      4:49:51
      amount has reached max job listings.
      4:49:54
      Just like that. And we're going to make
      4:49:56
      sure we await that. There we go. So now
      4:49:58
      what this little bit of code essentially
      4:49:59
      is saying is first of all, do you have
      4:50:00
      permission? And then we're checking,
      4:50:02
      hey, are we at the correct status or are
      4:50:04
      we have we reached the max that we can
      4:50:06
      for that status? So, if we're not
      4:50:07
      publishing a job, this returns false and
      4:50:09
      it doesn't throw an error, but it will
      4:50:11
      return true if we're publishing. And if
      4:50:12
      we've reached the max amount of job
      4:50:13
      listings that we can, we run into an
      4:50:15
      error. Now, this function, I believe I
      4:50:17
      called the wrong thing. This says has
      4:50:18
      reached max featured job listings. This
      4:50:20
      should just say has reached max
      4:50:22
      published job listings. So, I'm going to
      4:50:24
      actually rename that because that was an
      4:50:25
      incorrect naming on my part. So, we'll
      4:50:27
      come down into this lib for the plan
      4:50:29
      features helpers. And this should be
      4:50:30
      right here. We'll rename it to published
      4:50:32
      job listings instead. There we go. Now
      4:50:35
      what we can do is come all the way up to
      4:50:37
      here. We can import this function and at
      4:50:38
      least the function itself will import.
      4:50:40
      Now we just need to make sure we have
      4:50:41
      the function functioning properly
      4:50:43
      because right now it doesn't actually do
      4:50:44
      anything in the case that everything is
      4:50:46
      successful. So we want to call the
      4:50:47
      update function for our job listing in
      4:50:49
      the database version. We want to pass in
      4:50:51
      our ID. We want to pass in our status
      4:50:53
      which is our new status. The is featured
      4:50:55
      property. If the new status is equal to
      4:50:58
      published, well then we don't want to
      4:50:59
      modify this. So we'll just leave this as
      4:51:01
      undefined. That'll just not change it.
      4:51:03
      Otherwise, we're going to change it to
      4:51:04
      false because essentially if you're
      4:51:06
      unpublishing a job, you no longer want
      4:51:07
      it to be featured. Also, we're going to
      4:51:09
      set the posted at. So, if the new status
      4:51:11
      is equal to published
      4:51:14
      and we have not ever posted before. So,
      4:51:17
      our job listing
      4:51:20
      status is equal to draft. Then what I
      4:51:23
      want to do is I want to change my new
      4:51:24
      date right here by putting a new date.
      4:51:26
      Otherwise, just don't change it. So,
      4:51:27
      essentially, if it's the first time
      4:51:28
      we've published this job listing, then
      4:51:30
      set a date. Otherwise, don't. We can
      4:51:32
      also do this a different way which is
      4:51:34
      probably better and we can just check
      4:51:35
      the posted at. So the posted at is equal
      4:51:37
      to null. So essentially if we don't have
      4:51:39
      a posted at yet and we're posting this
      4:51:40
      for the first time set the posted at
      4:51:42
      otherwise don't mess with it. Now we
      4:51:44
      should hopefully have all of that done
      4:51:46
      and we can work on finishing out what we
      4:51:48
      need to do on this page because it looks
      4:51:49
      like we have an error where ID is equal
      4:51:50
      to null. And that's cuz I just didn't
      4:51:52
      pass in the ID here.
      4:51:55
      There we go. And then I need to make
      4:51:58
      sure wherever I use this, I pass in our
      4:52:01
      ID, which is our joblisting id. There we
      4:52:04
      go. Now it looks like we have an error
      4:52:05
      right here with this action. And that's
      4:52:07
      because we need to make sure this
      4:52:08
      function always returns to us an object
      4:52:10
      that has an error property. So we can
      4:52:11
      say error false to let them know that
      4:52:13
      this was successfully performed. Now,
      4:52:15
      that should be everything we need to do
      4:52:16
      to actually be able to change the status
      4:52:17
      of our job listing. So if I click this
      4:52:19
      publish button, you can see, are you
      4:52:21
      sure? This will immediately show this
      4:52:22
      job listing to users. I'll click yes.
      4:52:24
      And you can see we got a small loading
      4:52:25
      state. And now it says we can delist the
      4:52:27
      job cuz it's currently an active job. If
      4:52:29
      I click delist, you get the loading
      4:52:30
      state back to delisted. And now if I
      4:52:32
      want to publish again, are you sure you
      4:52:33
      want to publish? Yes. And it'll show it
      4:52:34
      as published. Now the next few buttons
      4:52:36
      that we add are likely going to be much
      4:52:37
      simpler cuz we can kind of piggyback on
      4:52:38
      all the work we did to make this
      4:52:40
      particular button work as well as it
      4:52:42
      actually is. So let's go back onto that
      4:52:44
      page. We want to scroll to the section
      4:52:45
      that we're going to be working on, which
      4:52:46
      is right here. We have our status update
      4:52:48
      button. I'm going to add a brand new
      4:52:50
      button. And this one is going to be for
      4:52:52
      our feature
      4:52:54
      is featured update button. And we'll
      4:52:57
      actually call this featured toggle
      4:52:59
      button. I think that's a little bit of a
      4:53:00
      better name. And it'll take in if it is
      4:53:02
      featured or not. So we'll come in here
      4:53:04
      with an is featured. And this is just
      4:53:06
      going to be a boolean. So first of all,
      4:53:08
      we can kind of not worry about this
      4:53:09
      action button. We'll come back to that.
      4:53:10
      I want to focus on this particular
      4:53:12
      section here. So we're going to be using
      4:53:13
      the same exact change status because
      4:53:15
      this is both for changing the status as
      4:53:17
      well as changing the status of the
      4:53:18
      featured flag. That's going to be the
      4:53:19
      same exact thing that we're checking.
      4:53:21
      So, we'll leave that the same. We don't
      4:53:22
      need to worry about getting the next job
      4:53:24
      listing status. We don't have that at
      4:53:25
      all to worry about. But, we do need to
      4:53:26
      check to see if this is a featured job.
      4:53:28
      So, we'll say is featured. If it's
      4:53:30
      featured, we want to render out just the
      4:53:33
      button as is because we're essentially
      4:53:34
      unfeaturing the job, which doesn't
      4:53:35
      require anything fancy. Otherwise, we
      4:53:38
      are featuring the job, which means that
      4:53:40
      we need to check to make sure they have
      4:53:41
      the ability to feature a job. So we can
      4:53:43
      make sure that in this particular
      4:53:45
      section, we're going to check the max
      4:53:47
      featured job listings, which is a new
      4:53:49
      function that we need to create. So
      4:53:50
      let's go ahead and do that. It's going
      4:53:52
      to be very similar to the function that
      4:53:53
      we've already created. So I'm
      4:53:54
      essentially just going to copy this,
      4:53:56
      paste it down. This is going to be max
      4:53:58
      featured job listings. There we go.
      4:54:01
      We're going to be getting the featured
      4:54:03
      job listings count. So let's copy this
      4:54:05
      function because again, very similar.
      4:54:07
      This one is going to be featured
      4:54:10
      job listings. And down here, instead of
      4:54:13
      checking this, we're going to check is
      4:54:14
      featured is equal to true.
      4:54:17
      There we go. This is going to give us
      4:54:18
      all the featured job listing counts. So
      4:54:19
      now we can check all of our featured.
      4:54:21
      And here we can check for the
      4:54:23
      onefeatured as well as the unlimited
      4:54:25
      featured. There we go. So the one
      4:54:27
      featured means that they have to be less
      4:54:29
      than or equal to one. And for the
      4:54:30
      unlimited, we don't even need to do any
      4:54:31
      other checks because if they have the
      4:54:32
      ability to post unlimited, it doesn't
      4:54:34
      matter what the count is. We only care
      4:54:35
      about the count when it's limited. So
      4:54:37
      now here we can say can feature is might
      4:54:39
      as well be what we call this. And we're
      4:54:40
      going to do the same exact negation to
      4:54:42
      make it so that if we have reached the
      4:54:43
      maximum or not. So now inside of here we
      4:54:46
      can import this particular function.
      4:54:48
      This will return true if we've reached
      4:54:49
      the max number of feature jobs.
      4:54:51
      Otherwise it's going to return to us
      4:54:52
      false. Then what we can do is we can add
      4:54:55
      our upgrade popover. For our upgrade
      4:54:57
      popover we need our featured
      4:55:00
      toggle button text.
      4:55:03
      And that's just going to be is featured.
      4:55:05
      And again that's something that we can
      4:55:07
      create down here. Very similar to what
      4:55:08
      we did with our status. I'm just going
      4:55:10
      to copy it over because again, if you
      4:55:11
      look at it, it's very simple code. If
      4:55:13
      featured is true, we return this star
      4:55:15
      off icon that text unfeature. Otherwise,
      4:55:17
      we return the text of feature with the
      4:55:19
      star icon. Essentially flipping between
      4:55:20
      the different icons and text based on if
      4:55:22
      we want to feature this job listing or
      4:55:24
      not. Now, we have that particular
      4:55:26
      section done. This text should say you
      4:55:28
      must upgrade your plan to feature more
      4:55:30
      job listings. There we go. So, that's
      4:55:31
      all good. That looks like everything we
      4:55:33
      wanted to do. We can come all the way up
      4:55:35
      here and now we just need to make our
      4:55:36
      action button work fine which isn't
      4:55:38
      going to be too much work. So inside
      4:55:40
      this action button we don't really need
      4:55:41
      to worry about require are you sure. So
      4:55:43
      we can completely get rid of that. And
      4:55:44
      then we have here our variant for
      4:55:45
      outline as well as we want to for this
      4:55:47
      one to toggle the job listing featured.
      4:55:51
      And we want to bind that just like we
      4:55:52
      did before. And this should be our
      4:55:54
      featured button text is featured. There
      4:55:57
      we go. So essentially all we need to do
      4:55:58
      is create this one single function and
      4:56:00
      all of the rest of the code is
      4:56:02
      essentially taken care of for us. So,
      4:56:03
      let's go ahead and we'll create this
      4:56:05
      function inside the action for our job
      4:56:07
      listings. So, we'll come into our
      4:56:08
      actions and we'll create one. Might as
      4:56:10
      well actually just copy this function
      4:56:12
      because it's going to be very similar to
      4:56:13
      what we did up here. This is going to be
      4:56:15
      toggle job listing featured. So, first
      4:56:17
      of all, you don't have permission to
      4:56:18
      update this job listing featured status.
      4:56:23
      There we go. And I might as well make
      4:56:25
      sure I put an apostrophe s in front of
      4:56:26
      this one just so it looks a little
      4:56:28
      better. Job listings status. There we
      4:56:30
      go. And then we can first check to see
      4:56:32
      do we have the organization. Same as
      4:56:33
      before. Check to see if we have the job
      4:56:35
      listing. Same as before. This is going
      4:56:37
      to be our new featured
      4:56:40
      status which essentially is just
      4:56:42
      negating the current status we have. So
      4:56:44
      job listing.isfeatured. We're just
      4:56:46
      negating that. Then what we're going to
      4:56:48
      do is we're going to do all the rest of
      4:56:49
      our checks down here for if we have
      4:56:50
      permission for doing it. So do we have
      4:56:52
      permission? Okay. Then is our new
      4:56:54
      featured status equal to true? So is it
      4:56:57
      true? If it's true, then we want to
      4:56:59
      reach have check to see if we have
      4:57:01
      reached the max featured jobs. So if we
      4:57:04
      have permission and we've not reached
      4:57:05
      the max featured jobs, then we want to
      4:57:07
      update this down here. And this one's
      4:57:09
      super simple. All we need to do is take
      4:57:10
      is featured and return the new featured
      4:57:13
      status. Super straightforward. So since
      4:57:15
      we did all that extra leg work before,
      4:57:17
      this was actually relatively easy for us
      4:57:18
      to implement. And now we can actually
      4:57:20
      render that on our page. So let's make
      4:57:22
      sure we import this and we can go up and
      4:57:24
      we can render this right next to where
      4:57:25
      we had our status button. So, here's our
      4:57:27
      status button. We can add our feature
      4:57:29
      toggle button. It's going to take in is
      4:57:31
      featured, which is
      4:57:32
      joblisting.isfeatured.
      4:57:35
      And it's going to take in an ID, which
      4:57:36
      is joblisting id. There we go. And now
      4:57:39
      you can see we have a button that allows
      4:57:41
      us to toggle between featured and
      4:57:42
      notfeatured. Also, I only want to render
      4:57:45
      this if our job listing is published
      4:57:46
      because we can't feature a non-published
      4:57:48
      job listing. So if joblisting status is
      4:57:52
      equal to published, then I want to
      4:57:54
      render the text directly inside of here.
      4:57:56
      So we'll move that down. And of course,
      4:57:58
      since this job listing is published, you
      4:58:00
      can see the button shows up. Now, right
      4:58:01
      now, our featured button right here is
      4:58:03
      showing up and our featured button here
      4:58:04
      is showing up. So we have a little bit
      4:58:05
      of a mix going on. My guess is that
      4:58:07
      inside of our component for our job
      4:58:09
      listing badges, we just have something
      4:58:11
      not quite like we want. Yeah, of course,
      4:58:12
      we negated it right here for testing
      4:58:14
      purposes. We need to make sure this only
      4:58:15
      shows up when it is featured. Now I can
      4:58:17
      click on this feature button. And of
      4:58:18
      course, you must upgrade your plan to
      4:58:20
      feature more job listings. And that's
      4:58:21
      because we're on the basic plan, which
      4:58:23
      does not have any featured job listings.
      4:58:24
      So, let's upgrade to the growth plan
      4:58:26
      where we can add one actual featured job
      4:58:28
      listing. So, now we can come back over
      4:58:30
      to here, go to our job. We'll just use
      4:58:31
      the back button to get there for now.
      4:58:33
      And you can see I can click feature. And
      4:58:34
      you can now see my job has been
      4:58:36
      featured. And now I can click
      4:58:37
      unfeatured. And it has been unfeatured.
      4:58:38
      So, I have the ability to toggle between
      4:58:40
      these. We'll make this one featured for
      4:58:41
      now. Now, the last button I want to add
      4:58:42
      is going to be the simplest one of them
      4:58:44
      all. And that's just going to be the
      4:58:45
      button for deleting. And you may think
      4:58:46
      that would be more complicated, but
      4:58:48
      honestly deleting is actually pretty
      4:58:49
      simple. So what we want to do is we're
      4:58:50
      just going to copy this async if because
      4:58:52
      this button is much simpler. It's just
      4:58:53
      one if statement instead of multiple. We
      4:58:55
      check for the delete status. Then we
      4:58:57
      have our variant on this one. It's going
      4:58:58
      to be destructive.
      4:59:01
      Whoops. Destructive. There we go. And
      4:59:03
      this one is not going to have a link. So
      4:59:05
      it's not going to be an ash child or
      4:59:06
      anything like that. It's actually going
      4:59:07
      to be an action button. So let me make
      4:59:09
      sure we get our action button. There we
      4:59:11
      go. This one is going to be the trash
      4:59:13
      two icon. There we go. size is going to
      4:59:15
      be four. It'll say delete. And then we
      4:59:17
      just need to specify what we want our
      4:59:19
      action to be. So our action for this one
      4:59:21
      is going to be delete job listing.bind
      4:59:24
      null and our job listing ID. And then
      4:59:27
      we're going to require are you sure? Cuz
      4:59:29
      obviously deleting a job listing is kind
      4:59:30
      of a big deal. So let's go ahead and
      4:59:32
      create an action for this job listing.
      4:59:35
      We'll just come in here async function
      4:59:38
      delete job listing
      4:59:40
      and it takes in an ID which is a string.
      4:59:42
      Now, this one is going to be pretty
      4:59:44
      straightforward. Kind of similar to what
      4:59:45
      we've done before. I'll copy up this
      4:59:47
      code right here. So, first of all, our
      4:59:48
      error will say you don't have permission
      4:59:49
      to delete
      4:59:52
      this job listing. There we go. We first
      4:59:54
      check, do we have an organization? Then
      4:59:56
      we check, do we have a job listing that
      4:59:57
      we want to delete? And then finally,
      4:59:59
      we're going to check if we have
      5:00:00
      permission. So, we can say await has
      5:00:02
      permission. And we want to check do they
      5:00:04
      have the or userdee job listings
      5:00:07
      permission. We're going to make sure we
      5:00:09
      negate that. So, right there. There we
      5:00:12
      go. So we're checking okay do they have
      5:00:13
      the permission if they don't then we're
      5:00:15
      going to return the error again and then
      5:00:19
      finally we can come down here await
      5:00:21
      delete job listing ID make sure this is
      5:00:24
      the database version and then if we
      5:00:26
      delete something we just want to
      5:00:27
      redirect them back to the employer page.
      5:00:32
      There we go. So now let's go ahead and
      5:00:34
      implement this delete job listing DB and
      5:00:36
      we also want to make sure we export this
      5:00:38
      so we can use it in our application. So
      5:00:40
      this is going to go inside of our
      5:00:41
      database folder right here. Export
      5:00:46
      function. We want to do that an ID.
      5:00:49
      That's a string. And deleting is going
      5:00:50
      to be rather straightforward. It's kind
      5:00:51
      of going to look like this. So I'll copy
      5:00:53
      this over. You can see here we're going
      5:00:55
      to call this is an async function. We're
      5:00:57
      going to call delete. We're going to get
      5:00:59
      it where our job ID is that. And we can
      5:01:01
      return these things. Revalidate. And
      5:01:03
      then this is called our deleted job
      5:01:06
      listing. Just like that. There we go.
      5:01:08
      That's all we need to do to delete a job
      5:01:09
      listing. And here we can make sure we
      5:01:11
      can import that properly. So we'll
      5:01:13
      scroll all the way to the top to
      5:01:14
      manually import that. Looks like it's
      5:01:16
      right here.
      5:01:18
      There we go. So now we've imported that
      5:01:19
      file. And the last place we need to
      5:01:21
      import is going to be here where we
      5:01:22
      actually created that action. So let's
      5:01:24
      make sure that we actually get the
      5:01:25
      correct one imported. So let me maximize
      5:01:28
      my screen size just so I know which one
      5:01:29
      I'm importing. There we go. That's the
      5:01:31
      actions one right there. And now
      5:01:33
      hopefully everything is going to work.
      5:01:34
      And you can now see we have our delete
      5:01:35
      button right here. And when I click on
      5:01:37
      this, it will delete the job listing if
      5:01:38
      I wanted to. So, let's click on delete.
      5:01:40
      And you can see it has deleted that. And
      5:01:42
      it's redirected back to this page. And
      5:01:43
      we've been redirected back to our very
      5:01:45
      first job listing. And that's because if
      5:01:47
      we look at the page for our base layout,
      5:01:49
      you can see here it redirects us to
      5:01:50
      whatever the most recently created job
      5:01:52
      listing is, which is this one. Or if
      5:01:53
      there are none, it's going to redirect
      5:01:55
      us back to the page that essentially is
      5:01:57
      for no job listing, which is for
      5:01:58
      creating a new job listing. So now,
    </chapter>
    <chapter title="Employer sidebar updates" start_time="5:02:00">
      5:02:00
      let's go ahead and actually work on the
      5:02:01
      sidebar portion over here for our job
      5:02:03
      listings. First of all, this plus button
      5:02:05
      should only show up if we have
      5:02:06
      permission to actually interact with it.
      5:02:07
      So, let's go over to our layout for
      5:02:09
      this. Make this so quite big so we can
      5:02:11
      see it. And here is our sidebar group
      5:02:12
      action. We want to wrap that inside of
      5:02:14
      an async if. So, we'll say async if just
      5:02:17
      like that. Wrap that entire section in
      5:02:19
      it. And we'll add in our condition,
      5:02:21
      which is has or user permission. And
      5:02:24
      this is going to be the one for creating
      5:02:25
      a job listing. So, we want to just make
      5:02:27
      sure we check that. If they have that
      5:02:29
      particular permission, then we're fine
      5:02:31
      with running the rest of our code. There
      5:02:32
      we go. Then inside of this sidebar
      5:02:34
      group, I want to render out all of the
      5:02:36
      job listings that we have. So inside
      5:02:38
      this sidebar group, we're going to have
      5:02:39
      our sidebar group content. Just like
      5:02:41
      that. And inside this sidebar group
      5:02:43
      content, I want to create a job listing
      5:02:45
      menu. And I'm going to pass it in the
      5:02:47
      org ID so we can get all the job
      5:02:48
      listings for a particular organization.
      5:02:50
      Now this content I want to be collapsed
      5:02:53
      or hidden whenever I collapse my screen
      5:02:55
      or collapse my sidebar. So we'll say
      5:02:57
      group
      5:02:59
      whoops group data. And then we have
      5:03:03
      state equals collapsed.
      5:03:05
      And I want this to be hidden whenever in
      5:03:07
      the collapsed state. There we go. And
      5:03:11
      let's make sure that we close off
      5:03:13
      everything that we have. For example,
      5:03:14
      this needs to be closed off. And we need
      5:03:16
      to create this job listing menu.
      5:03:20
      And this is going to take in that org
      5:03:22
      ID. And for now, let's just return null.
      5:03:24
      So we can at least see that everything
      5:03:25
      is working properly. And this entire
      5:03:27
      section when we collapse down to the
      5:03:28
      icon size. So at full screen like this,
      5:03:30
      when we collapse down, all of that
      5:03:31
      entire section right there is going to
      5:03:33
      completely disappear just like we want
      5:03:34
      it to. So now let's go ahead and make
      5:03:36
      this sidebar menu. First of all, we need
      5:03:38
      to get our job listings. So we'll say
      5:03:40
      await get job
      5:03:44
      listings. This is going to take in
      5:03:47
      an org ID. And this is actually going to
      5:03:49
      be a much more complicated function than
      5:03:51
      it looks like. So we're going to come
      5:03:52
      down here and first of all, wherever I
      5:03:54
      have my job listing menu, I want to wrap
      5:03:56
      that in a suspense. There we go.
      5:04:01
      Perfect. Since we are doing asynchronous
      5:04:03
      code inside of here, I don't really care
      5:04:04
      about a fallback for it, but we're going
      5:04:05
      to just wrap it inside of a suspense.
      5:04:07
      Now, let's create our async function for
      5:04:09
      get job listings. Pass it in an org ID,
      5:04:13
      which is a string. And you may think
      5:04:15
      this is a simple function, but not only
      5:04:16
      do I want to get my job listings, I also
      5:04:18
      want to get the number of applications
      5:04:20
      for my job listing. And I also want to
      5:04:22
      group these by the actual organiza or by
      5:04:24
      the status for the different job
      5:04:26
      listings. So there's quite a lot of
      5:04:27
      stuff going on inside this function.
      5:04:29
      First of all, we can do our caching just
      5:04:30
      like we were before. So we'll say get
      5:04:32
      job listing and this is going to be our
      5:04:34
      organization ID. There we go. Then I
      5:04:37
      want to get my data which is await db
      5:04:41
      select because we're going to be doing a
      5:04:42
      manual select with manual joins and so
      5:04:44
      on. So I want to get my job listing
      5:04:47
      table do ID. I want to get my title.
      5:04:51
      Whoops. Table.title.
      5:04:53
      I want to get my status which is job
      5:04:55
      listing table. Let me unimport menu
      5:04:58
      because I definitely don't need that
      5:05:00
      imported. Looks like it. Oh, of course
      5:05:02
      it's not imported. It's this exact file
      5:05:04
      right here. Okay. So, we can get our
      5:05:05
      status. Then the next thing we can get
      5:05:08
      is our application count. And this is
      5:05:10
      going to be a count of our job listing.
      5:05:14
      Application table dot user ID because
      5:05:17
      essentially I want to get the unique
      5:05:18
      users that have applied for this
      5:05:20
      particular job. And we'll make sure that
      5:05:21
      we import that from Driscoll properly.
      5:05:23
      Then we want to do this from our job
      5:05:26
      listing table. There we go. We want to
      5:05:29
      get this where we have the organization
      5:05:31
      ID. So we can say equals
      5:05:34
      job listing table do.org organization ID
      5:05:37
      is equal to our org ID. So now we're
      5:05:39
      checking okay only the job listings for
      5:05:41
      our organization. I want to do a left
      5:05:43
      join because even if there are no
      5:05:45
      applications I still want to make this
      5:05:46
      join and just count to zero. So my job
      5:05:49
      listing application table where my job
      5:05:52
      listing table do ID is equal to my job
      5:05:56
      listing application table dot joblisting
      5:05:58
      ID. So I'm just matching on that foreign
      5:05:59
      key. Then I'm doing a group by
      5:06:03
      and I want to group by each individual
      5:06:05
      job listing ID and I also want to group
      5:06:08
      by the job listing ID itself just so I
      5:06:11
      can actually get that information. So
      5:06:12
      we're going to put both of those in our
      5:06:13
      group by clause. The reason I have both
      5:06:15
      is because that way I can access like my
      5:06:17
      ID, my title, my status, and so on up
      5:06:19
      above. Finally, I have an order by and
      5:06:22
      we're going to do this in descending
      5:06:23
      order by by when they were created. So,
      5:06:25
      we're going to do created at. So,
      5:06:27
      whichever one is most recently created
      5:06:28
      will show up at the top of our list.
      5:06:29
      Now, down here, we can return our data,
      5:06:31
      but before we do that, you'll notice
      5:06:33
      that not only do I rely on my job
      5:06:35
      listing data for each organization, but
      5:06:37
      I also rely on my job listing
      5:06:38
      application table. So, I need to make
      5:06:40
      sure I cache based off of that as well.
      5:06:42
      The really nice thing about the way
      5:06:43
      NextJS does caching with this cache tag
      5:06:45
      system is I can loop through each one of
      5:06:47
      my job listings just like this. And I
      5:06:50
      can specifically say I want to get a
      5:06:52
      cache tag for my job listing application
      5:06:56
      job listing tag. Super long name, but
      5:06:58
      essentially I just want to cache my
      5:07:00
      applications by the job listing ID. But
      5:07:03
      I don't have that function created. So
      5:07:04
      we're going to go ahead and create that
      5:07:05
      function since now we're diving into our
      5:07:07
      job listing applications. So, we'll come
      5:07:09
      over into our page. Inside of our
      5:07:11
      features folder, we need to create a
      5:07:12
      brand new folder for job listing
      5:07:15
      applications. We need a DB folder and we
      5:07:17
      need a cache folder. And inside of that
      5:07:19
      folder, we'll just create a brand new
      5:07:21
      file called joblisting
      5:07:24
      applications.ts.
      5:07:26
      And we're going to export a function
      5:07:28
      with that exact name.
      5:07:31
      Now, this is going to take in our job
      5:07:33
      listing
      5:07:35
      ID, which is a string, and it's going to
      5:07:38
      return the get job listing
      5:07:43
      tag. We're going to pass it in job
      5:07:46
      listing
      5:07:49
      applications and our job listing ID. And
      5:07:52
      this is again a function we need to
      5:07:54
      create because we don't have any setup
      5:07:55
      for this for our caching. So in our data
      5:07:57
      cache, you notice we can cache by ID,
      5:07:59
      organization, and global. We need to
      5:08:01
      create another one for being able to
      5:08:02
      cache by a job listing ID instead. So
      5:08:05
      our tag is our cache tag, and then our
      5:08:08
      job listing ID is going to be a string.
      5:08:11
      Finally, I'm just going to essentially
      5:08:13
      take what I have here. I'm going to
      5:08:14
      return the same thing. So our job
      5:08:16
      listing ID goes there, and this just
      5:08:18
      says job listing. So now inside of this
      5:08:20
      file, we can make sure we import that,
      5:08:22
      and that should work just fine. Now, I
      5:08:24
      also want to get the global tag version.
      5:08:25
      I'll just copy that over. You can see
      5:08:27
      now here's the global tag version. And I
      5:08:29
      also want to get an ID tag version. But
      5:08:31
      this is going to be a little bit
      5:08:32
      difficult compared to the other ones
      5:08:34
      because we actually have a joint ID as
      5:08:36
      opposed to an individual ID. You can see
      5:08:37
      our ID is both a job listing ID and a
      5:08:39
      user ID. Our primary key is a joint
      5:08:41
      primary key. So we need to make sure we
      5:08:43
      pass in both parts of our primary key to
      5:08:45
      use with this particular tag. Finally,
      5:08:47
      we just need to do the exact same thing
      5:08:49
      by revalidating these tags. Make sure I
      5:08:51
      import this. So you can see here again
      5:08:53
      we're passing in our joint tag just like
      5:08:55
      this and we're making sure we're
      5:08:56
      revalidating all the different caches
      5:08:58
      that we possibly have. Same thing that
      5:08:59
      we did for everything else just slightly
      5:09:01
      more complicated because we have a joint
      5:09:02
      primary key. Now here we can make sure
      5:09:05
      we get that tag and what this is doing
      5:09:06
      is it's essentially saying okay every
      5:09:08
      single application for every job listing
      5:09:10
      we're looking for is going to be cached.
      5:09:11
      Now with that out of the way we actually
      5:09:13
      have our job listings and we can use
      5:09:14
      them up here. So first if our job
      5:09:16
      listings whoops job listings.length
      5:09:20
      length is equal to zero and we have the
      5:09:23
      ability to create things. So I'm going
      5:09:25
      to say await has or user permission to
      5:09:28
      create a job listing. Then we want to
      5:09:30
      render a button to create a job listing
      5:09:31
      because we don't have any job listing
      5:09:33
      yet. So we're going to return a sidebar
      5:09:35
      menu. Inside of here we're going to
      5:09:37
      return a sidebar menu item. Inside of
      5:09:40
      that we're going to have a sidebar menu
      5:09:42
      button.
      5:09:44
      And then finally we're going to have a
      5:09:46
      link inside of this.
      5:09:49
      if I can spell properly. There we go. A
      5:09:52
      link that has an href that points to
      5:09:54
      employer
      5:09:56
      job listings new. Just like that. Going
      5:10:01
      to put a plus icon in there.
      5:10:04
      And we'll also put a span
      5:10:07
      that says create your first job listing.
      5:10:10
      There we go. So now if we have no job
      5:10:11
      listings, that would show up right here.
      5:10:12
      And to emulate what that would look
      5:10:14
      like, we can just put a little not
      5:10:15
      equals on there. And now we can come
      5:10:17
      over here. And of course, looks like
      5:10:18
      we're getting some kind of error. Cannot
      5:10:19
      read property length of undefined. So
      5:10:21
      this job listings thing is not returning
      5:10:23
      our data properly. Most likely that's
      5:10:25
      because of the way that we set up our
      5:10:26
      caching. It's currently probably cached
      5:10:27
      when it shouldn't be. Actually, it looks
      5:10:29
      like it worked. I just need to refresh
      5:10:30
      the page. Or maybe not. My guess is it
      5:10:32
      cached the value when it was empty
      5:10:33
      before we actually added anything. So
      5:10:35
      the easiest way to fix this is just to
      5:10:36
      stop your server. Then what we do is we
      5:10:38
      go over here where we have our next
      5:10:39
      folder. Delete this. It'll get rid of
      5:10:41
      your entire cache. And then restart your
      5:10:43
      server. This should hopefully fix the
      5:10:45
      problem. We completely nuked our cache
      5:10:46
      for literally everything. And if we
      5:10:47
      still have the problem, then it's
      5:10:48
      definitely a problem with our code and
      5:10:50
      not with Next.js caching. But it looks
      5:10:52
      like it worked fine. And you can see
      5:10:53
      here it says create your first job
      5:10:54
      listing. Even the styling is a little
      5:10:56
      bit messed up on it. I believe the
      5:10:58
      reason for that is because this should
      5:10:59
      be an as child button. And there we go.
      5:11:00
      That fixed all of our stylings. Now we
      5:11:02
      have create your first job listing just
      5:11:03
      like we wanted it to be. Now the next
      5:11:05
      thing that we need to return down here
      5:11:06
      is going to be essentially grouping our
      5:11:08
      job listings because we obviously have
      5:11:10
      job listings. So this will be null. We
      5:11:12
      want to group them by status and then
      5:11:13
      render out all the job listings for each
      5:11:15
      individual status. So what we're going
      5:11:17
      to do is we're going to say object.ent
      5:11:18
      entries. That's going to give us our
      5:11:20
      objects and we first want to group them.
      5:11:21
      So we're going to group our objects job
      5:11:23
      listings. And what this is going to do
      5:11:25
      is it's going to take our job listing
      5:11:26
      and we want to group by status. So we're
      5:11:28
      going to group them by status and then
      5:11:29
      convert them to an array. And this array
      5:11:31
      is essentially going to have some values
      5:11:33
      where the key is going to be the actual
      5:11:35
      status and the value is going to be the
      5:11:37
      array of job listings grouped by that
      5:11:39
      status. And I want to sort them because
      5:11:41
      I specifically want the active status
      5:11:43
      for example to be above the dellisted
      5:11:45
      status. And if we did it purely
      5:11:46
      alphabetical published comes after
      5:11:48
      dlisted which is not ideal. So we're
      5:11:50
      going to create a sort function here.
      5:11:51
      And this is going to take a and b just
      5:11:54
      like this. And the reason I have to wrap
      5:11:55
      these in arrays is because like I said
      5:11:57
      this object entries returns to us an
      5:11:58
      array where the first value is my actual
      5:12:00
      key while the second value is the value.
      5:12:02
      So I want to get the keys for both of
      5:12:04
      these and then I want to sort them. And
      5:12:06
      to sort them I'm just going to call a
      5:12:07
      simple function. And this function is
      5:12:10
      called sort job listings by status. I'm
      5:12:15
      going to pass in a and b. And this is a
      5:12:17
      function we're going to create inside of
      5:12:18
      our utility helpers. So if we go into
      5:12:20
      our features for our job listings in our
      5:12:22
      lib, we have this utils. And I want to
      5:12:24
      export a function that is going to sort
      5:12:26
      them. A is going to be a job listing
      5:12:28
      status. B is going to be a job listing
      5:12:31
      status. And inside this function, all I
      5:12:33
      want to do is return the sort order. So
      5:12:35
      I'm going to create a simple little
      5:12:36
      helper function right here. job listing
      5:12:38
      status sort order and what this is going
      5:12:39
      to do is return to me a number that
      5:12:41
      determines the sort sort order. So for
      5:12:43
      example published is first draft is
      5:12:45
      second dlisted is third and then inside
      5:12:47
      of here I can just return getting my a
      5:12:49
      value from here minus getting my b value
      5:12:52
      from here and since the sort function
      5:12:53
      expects you to return a value of either
      5:12:55
      less than one or less than 0, greater
      5:12:57
      than zero or zero. This exactly does
      5:12:59
      that for us perfectly. So this is kind
      5:13:01
      of that sort function and this is just a
      5:13:02
      map to get the sort order for us. So
      5:13:04
      instead of sorting alphabetically, we're
      5:13:06
      sorting exactly in this order. Now we
      5:13:08
      can make sure we import that into our
      5:13:10
      layout here.
      5:13:12
      There we go. And we should hopefully at
      5:13:13
      least have them sorted, but we're trying
      5:13:15
      to render out objects, which is not
      5:13:16
      ideal. So what we need to do is we need
      5:13:18
      to map this and convert it to JavaScript
      5:13:20
      objects. So again, when we map this,
      5:13:21
      we're going to get a key and we're going
      5:13:23
      to get a value just like this. And also,
      5:13:25
      this essentially thinks it's a string
      5:13:26
      because object.entries is not smart. It
      5:13:28
      doesn't know what the types are. So it
      5:13:30
      says A is a string and B is a string. We
      5:13:33
      know that these are job listing
      5:13:34
      statuses. So we can tell TypeScript,
      5:13:36
      hey, these are job listing statuses.
      5:13:38
      Don't try to do anything funky. So now
      5:13:40
      we have our key and our value down here.
      5:13:42
      Wrap those inside of parenthesis. So we
      5:13:44
      can use a function version of this. And
      5:13:45
      essentially what I want to do is I just
      5:13:47
      want to return a new object. We're going
      5:13:49
      to call job listing menu group. Our key
      5:13:53
      is going to be our key. Make sure I
      5:13:55
      don't capitalize this. And this key is
      5:13:57
      really just our status. So I might as
      5:13:59
      well call it status so it's a little bit
      5:14:00
      more clear what's going on. Then we're
      5:14:02
      going to set our status and we're going
      5:14:04
      to again have to cast this because
      5:14:05
      TypeScript's not smart enough to know.
      5:14:07
      And then our job listings is equal to
      5:14:09
      our value. And we might as well call
      5:14:11
      this job listings as well.
      5:14:15
      There we go.
      5:14:18
      And now all we need to do is create this
      5:14:20
      job listing menu group. So I'm going to
      5:14:21
      come over here. I'm going to create a
      5:14:23
      brand new file essentially directly
      5:14:24
      where our layout is at. So in this
      5:14:26
      folder right here, we're going to create
      5:14:27
      a brand new file. I'm going to call it
      5:14:28
      underscore joblisting
      5:14:31
      menu group.tsx. Make sure I spell
      5:14:34
      everything properly. And again, the
      5:14:35
      underscore is just for me to denote that
      5:14:37
      this is specifically a file that is only
      5:14:39
      used in this particular section. And of
      5:14:41
      course, it's going to be a client
      5:14:42
      component, which is why we have to break
      5:14:43
      it out into its own individual file. And
      5:14:45
      that's just so we can have different
      5:14:46
      styling for things proper. So, let's
      5:14:48
      export a function job listing menu
      5:14:50
      group. Just like that. It's going to
      5:14:53
      take in an object that contains a status
      5:14:55
      which is our job listing status and our
      5:14:57
      job listings which is going to be an
      5:15:00
      array of job listing which is type that
      5:15:02
      I'm going to create up here.
      5:15:06
      There we go. Now this job listing type
      5:15:08
      is a type that just contains our title
      5:15:10
      and our ID from our job listing table as
      5:15:12
      well as this application count which is
      5:15:14
      a thing that we're getting specifically
      5:15:16
      when we're doing our query. If I just
      5:15:17
      import this real quick so we can get rid
      5:15:19
      of all of our errors. If we get on here,
      5:15:20
      you can see we're getting our
      5:15:21
      application count, our title, our
      5:15:22
      status, and our ID. Those are all the
      5:15:24
      different things that we're expecting
      5:15:25
      inside this function here. Now, also,
      5:15:27
      I'm going to be using this right here,
      5:15:29
      job listing ID equal to use params. This
      5:15:33
      allows me to determine what page we're
      5:15:34
      on to highlight the page we are
      5:15:36
      currently on. Then we can return a
      5:15:39
      sidebar menu
      5:15:42
      just like that. And this is going to be
      5:15:43
      a collapsible sidebar menu. And again,
      5:15:46
      it looks like we need to get this from
      5:15:48
      shad CN. So, let's come all the way down
      5:15:49
      here and we want to get collapsible.
      5:15:53
      Just like that. And of course, we'll
      5:15:54
      probably have to force install this.
      5:15:56
      There we go. So, now I can actually use
      5:15:58
      this collapsible component. There we go.
      5:16:00
      Get it from shad CN. And this allows us
      5:16:02
      to essentially collapse these different
      5:16:03
      sidebars. So, the default open status.
      5:16:07
      There we go. Default open. That is going
      5:16:09
      to be set to status is not equal to
      5:16:12
      delisted. So, essentially my D-listed
      5:16:14
      ones, I want to by default collapse
      5:16:16
      them. And this status right here for
      5:16:18
      some reason is saying it's not
      5:16:19
      available. That's because up here I need
      5:16:21
      to make sure that I get my properties.
      5:16:23
      There we go. We have status and job
      5:16:24
      listing. Also I want to default this to
      5:16:26
      open if it's the currently selected job
      5:16:29
      listing. So if my job listingsfind
      5:16:34
      job listingsfind
      5:16:37
      a job
      5:16:39
      where the job ID is equal to joblisting
      5:16:41
      ID. If that's not equal to null, then I
      5:16:44
      also want to default it into the open
      5:16:46
      state. So essentially I leave it open if
      5:16:48
      it's not delisted or if it's the
      5:16:50
      currently selected one that we're inside
      5:16:51
      of. Then we can have some class names
      5:16:54
      inside of here. And our class name is
      5:16:56
      just going to be group slash
      5:16:58
      collapsible. So at least we have a group
      5:16:59
      that we can use for our styling later
      5:17:01
      on. Then I want to render out our
      5:17:03
      sidebar menu item. So we can say sidebar
      5:17:06
      menu item just like that. This is going
      5:17:08
      to have our collapsible trigger. So we
      5:17:10
      can say collapsible trigger. We want to
      5:17:13
      use as child for this because we're
      5:17:14
      going to be using essentially a sidebar
      5:17:16
      menu button. And inside of here, we want
      5:17:19
      to have, like I said, a sidebar
      5:17:22
      menu button.
      5:17:24
      There we go. And inside this sidebar
      5:17:26
      menu button, we're going to format the
      5:17:28
      job listing status. Pass in our status
      5:17:30
      just like that. And we're going to have
      5:17:32
      a chevron to the right icon. Make sure I
      5:17:36
      import that. There we go. The class name
      5:17:38
      on this is margin left auto just so it
      5:17:40
      pushes itself all the way to the right.
      5:17:41
      We're going to transition
      5:17:45
      on the transform. We're going to group
      5:17:47
      this. So, group data for when the state
      5:17:50
      is equal to open. There we go. Then we
      5:17:53
      want to get the collapsible.
      5:17:56
      And we want to rotate this 90°. Let me
      5:17:58
      make sure I spell that properly. So,
      5:18:00
      essentially what this little bit of code
      5:18:02
      does right here, let me just close this
      5:18:03
      off, is we're saying, hey, when we're in
      5:18:06
      our collapsible group, that's what this
      5:18:07
      /apsible does, and the state is open. I
      5:18:10
      want this to be slightly rotated. So,
      5:18:11
      it'll essentially rotate based on if
      5:18:13
      we're open or if we are closed. Now, if
      5:18:15
      we open up our sidebar, we should see we
      5:18:17
      now have the draft status. And I can
      5:18:18
      toggle it open and closed, but we're not
      5:18:20
      rendering anything inside of it. So,
      5:18:22
      let's create some collapsible content.
      5:18:24
      This collapsible content is going to be
      5:18:26
      a sidebar menu sub. Essentially, we're
      5:18:28
      creating a submen inside of here. So,
      5:18:30
      this is a nested menu. And inside this
      5:18:33
      nested menu, what I want to do is I want
      5:18:34
      to loop through all my job listings. So,
      5:18:36
      job listings map. For each job listing,
      5:18:41
      I want to render a job listing menu
      5:18:43
      item. So for each one, we'll just say
      5:18:45
      job listing menu item, which is a
      5:18:47
      component we're just going to create in
      5:18:48
      a second. And this is going to take in a
      5:18:50
      job listing
      5:18:52
      ID and all of our job listing props.
      5:18:56
      There we go.
      5:18:58
      That's all of our stuff. So let's create
      5:19:00
      that component. And the main reason I'm
      5:19:01
      putting this in its own component is so
      5:19:03
      I can use a custom hook directly inside
      5:19:04
      of it.
      5:19:07
      Item. There we go.
      5:19:12
      And of course, I spelled this
      5:19:13
      incorrectly up here. That should
      5:19:14
      hopefully be spelled correctly in both
      5:19:16
      instances. And down here, we take in an
      5:19:18
      ID, a title,
      5:19:21
      an application count, and this is just
      5:19:23
      our job listing type that we already
      5:19:25
      created. Now, down here, the reason I
      5:19:26
      brought this into its own component is
      5:19:28
      so I can essentially get the current
      5:19:29
      param. So we can just say that we're
      5:19:31
      going to be param or actually job
      5:19:33
      listing ID
      5:19:36
      is equal to
      5:19:38
      use params just like that. That gives us
      5:19:40
      whatever the current job listing ID is.
      5:19:42
      We can compare it to our job listing ID
      5:19:44
      to figure out if we're on the same page.
      5:19:46
      Then we can return a sidebar
      5:19:49
      menu sub item because we're inside of a
      5:19:52
      sublist. Make sure that's an item. There
      5:19:54
      we go. And inside of here we want a
      5:19:55
      sidebar menu subut. And this sub button
      5:19:59
      is going to be is active if our job
      5:20:01
      listing
      5:20:03
      ID is equal to our current ID. Also, we
      5:20:06
      want to make sure this is an as child
      5:20:08
      because we're going to be rendering a
      5:20:09
      link inside here to navigate around. So,
      5:20:11
      this is going to be an href to our job
      5:20:13
      listing page. And in our case, we want
      5:20:15
      to make sure that this is going to be
      5:20:16
      slash employer slashjobistings
      5:20:20
      slash ID.
      5:20:24
      Close that off. and we'll put a span
      5:20:26
      inside of here with a class name of
      5:20:28
      truncate so that it doesn't overflow our
      5:20:30
      container if our job listing name is
      5:20:32
      really long. And then we'll put the
      5:20:33
      title for our job. Now, we need to make
      5:20:35
      sure we import this link component. So,
      5:20:37
      that at least is going to give us our
      5:20:38
      buttons on the side. So, you can see we
      5:20:40
      can click on these different items, but
      5:20:41
      we need to take this a step further by
      5:20:43
      also adding a badge with the count next
      5:20:45
      to it. So, we can do that relatively
      5:20:46
      easily with an application count. If it
      5:20:49
      is greater than zero, then we want to
      5:20:51
      render out a component that shows that.
      5:20:52
      So we'll create a div with a class name
      5:20:54
      of absolute
      5:20:56
      right of two top of 1/2 so that it's in
      5:20:59
      the center negative translate of 1/2 as
      5:21:02
      well. So that's going to be y 1/2 again
      5:21:04
      perfectly making it centered. Our text
      5:21:06
      will be small and it'll be muted
      5:21:08
      foreground. So it's essentially a light
      5:21:10
      gray text that we're going to show with
      5:21:11
      our application count. There we go.
      5:21:14
      Right now there's no applications but if
      5:21:16
      we were to change this to a different
      5:21:17
      value. So we just say like if one is
      5:21:19
      greater than zero we make this one. You
      5:21:21
      can see it shows the text one. So,
      5:21:22
      whatever our application count is, it'll
      5:21:23
      show right there. Now, to show you how
      5:21:25
      this really works and how cool it is, if
      5:21:26
      we go ahead and we publish this job
      5:21:28
      listing and we just say yes, we want to
      5:21:29
      publish it. You can now see it's under
      5:21:30
      the active category. If we create a
      5:21:32
      brand new job listing, we'll just give
      5:21:34
      it a bunch of bogus data. It doesn't
      5:21:35
      really matter what it is. And we can
      5:21:37
      click create job listing, you can now
      5:21:38
      see that that's in the draft category.
      5:21:40
      And if I wanted to dellist this job, you
      5:21:42
      can see it's now in the D-listed
      5:21:44
      category. And when I refresh my page,
      5:21:46
      dlisted by default is going to be closed
      5:21:48
      unless the current job I'm in is inside
      5:21:50
      that D-listed category. Then you can see
      5:21:52
      it's going to start as open. Now, one
      5:21:53
      thing I just realized when I was going
      5:21:54
      through our code is that inside of our
      5:21:56
      toast, if we go ahead and we open up the
      5:21:58
      UI component for sauner, you're going to
      5:22:00
      notice that this uses next themes, but
      5:22:02
      we don't really care about next theme.
      5:22:03
      We're not implementing or using next
      5:22:04
      theme at all. So, instead of doing that,
      5:22:06
      we're going to use our own custom is
      5:22:08
      dark mode hook that we've already
      5:22:10
      created. Use is dark mode, just like
      5:22:12
      that. And then here for our theme
      5:22:13
      section, we're just going to say if
      5:22:15
      we're in the dark mode, use dark.
      5:22:17
      Otherwise, use light. Just like that.
      5:22:19
      So, we're not going to be hooking into
      5:22:20
      this library that we're not actually
      5:22:22
      using because that's one thing that they
      5:22:23
      kind of require you to do. Now, the next
      5:22:24
      thing I want to move on towards is going
    </chapter>
    <chapter title="Main job board page" start_time="5:22:25">
      5:22:26
      to be working on our actual job board
      5:22:28
      page, but I do want to test one thing
      5:22:29
      real quick to make sure everything's
      5:22:30
      working. If I come in here and I log
      5:22:32
      out, you can see, okay, we do still have
      5:22:34
      our sign-in button here, which is
      5:22:35
      exactly what I wanted. So, let's go
      5:22:36
      ahead and make sure we sign in. We'll
      5:22:37
      just sign in with GitHub. Doesn't really
      5:22:39
      matter what we sign in with. But now,
      5:22:40
      what I would want to do is I want to
      5:22:41
      show all these different job boards that
      5:22:43
      we have. So, on our employer dashboard,
      5:22:45
      we have two job listings. One is a
      5:22:46
      draft, one is delisted. Let's go ahead
      5:22:48
      and publish this one. So, at least we
      5:22:50
      have one job listing that's published.
      5:22:51
      So, we can use that as a test to be able
      5:22:53
      to view. Actually, we might as well just
      5:22:54
      publish both of them so we can see both
      5:22:55
      of them when we're working. There we go.
      5:22:57
      So, now over on the job board, let's
      5:22:58
      actually render out something besides
      5:22:59
      the text of hi. So, what we're going to
      5:23:00
      do is we're going to go over, we're
      5:23:02
      going to minimize all this different
      5:23:03
      stuff cuz that's kind of all the old
      5:23:04
      stuff we worked on. We're going to go
      5:23:05
      into our app into the jobseker section
      5:23:07
      and we're going to go into our page. And
      5:23:09
      here, all I'm going to do is I'm going
      5:23:10
      to render a div with a class name
      5:23:13
      of M4 just to give us some spacing so at
      5:23:15
      least our text is low spaced out. And
      5:23:17
      then we're going to render a job listing
      5:23:19
      items component. And this is going to
      5:23:21
      take in our search params because this
      5:23:22
      is essentially going to be a page that
      5:23:24
      we can search with search params. So
      5:23:26
      search params.
      5:23:29
      There we go. Make sure I spell all that
      5:23:30
      properly. And up here we're going to
      5:23:32
      take in search params. So we'll say
      5:23:33
      search params and search params is going
      5:23:36
      to be a promise.
      5:23:39
      And this promise is going to return to
      5:23:41
      us a record of string string because we
      5:23:44
      really don't know what is in the search
      5:23:45
      params. It could be literally anything.
      5:23:47
      And this job listing items is something
      5:23:48
      that I'm going to share between multiple
      5:23:50
      pages because we're going to be showing
      5:23:52
      kind of things side by side. The same
      5:23:53
      list of things on our job listing page
      5:23:55
      as well as the page to show all the
      5:23:57
      listings. So I want to create a brand
      5:23:58
      new folder called shared where we can
      5:24:00
      put things like our job listing
      5:24:04
      items just like this. And we can share
      5:24:06
      these between those different pages
      5:24:08
      without having to put it like in a
      5:24:09
      global folder that's everywhere. So now
      5:24:11
      let's export a function called job
      5:24:14
      listing
      5:24:15
      items. And one thing I want to modify
      5:24:18
      slightly is this should actually be
      5:24:19
      string or string array because
      5:24:21
      technically our search params could be
      5:24:24
      an array as well as we pass a lot of the
      5:24:26
      same thing. So we have our search pram
      5:24:28
      type. I want to essentially get that
      5:24:29
      type inside of here. So we could say
      5:24:31
      search params. And of course we want to
      5:24:34
      have our normal params as well. And
      5:24:36
      we're going to come in here with our
      5:24:37
      search params as well as our normal
      5:24:40
      params which is optional and it's a
      5:24:41
      promise that returns
      5:24:44
      a job listing ID which is a string. And
      5:24:47
      again the reason why we have this is
      5:24:48
      because like I said we are sharing this
      5:24:50
      component between a page that renders
      5:24:51
      one job listing versus one that renders
      5:24:53
      all job listings. So sometimes it'll
      5:24:55
      have a pram, sometimes it won't. And
      5:24:56
      then we have our search params here just
      5:24:58
      like I mentioned. Now we can just give
      5:25:00
      this a quick save. We'll just return
      5:25:02
      null over here. We'll import this. So at
      5:25:04
      least our page will now render on the
      5:25:05
      side. It just doesn't have any content.
      5:25:07
      Now before we get anywhere, the first
      5:25:08
      thing we need to do is get a list of all
      5:25:10
      the job listings that we're searching
      5:25:11
      for. So we're going to return db.query
      5:25:14
      or actually sorry, we should put this in
      5:25:15
      a function first. We'll call this get
      5:25:17
      job listings. Make this an async
      5:25:20
      function. And we'll add caching in a
      5:25:21
      little bit. I'll just put use cache. And
      5:25:23
      I'll comment it out so that way it
      5:25:25
      doesn't accidentally get cached while
      5:25:26
      we're in the middle of writing our
      5:25:27
      function. And then we're going to say
      5:25:29
      that we want to return db.query
      5:25:32
      the job listing table. We want to find
      5:25:34
      many and we want to find many based on a
      5:25:37
      lot of different criteria. So obviously
      5:25:38
      we have all of our different search
      5:25:40
      param queries that we want to run and
      5:25:42
      we're going to put those inside of an
      5:25:43
      array which we're going to call wear
      5:25:45
      conditions.
      5:25:47
      That's going to give us an array of
      5:25:48
      values and we're going to pass that down
      5:25:50
      as some of our conditions down here. Now
      5:25:52
      to make sure we type everything
      5:25:53
      properly, we can come into here and
      5:25:55
      actually give this a specific type just
      5:25:57
      like this which essentially says that
      5:25:59
      we're going to be either getting SQL or
      5:26:00
      undefined. And it's fine to pass in
      5:26:02
      undefined. If you do, it just means
      5:26:03
      don't do anything with that wear clause.
      5:26:05
      So now we have a bunch of wear clauses
      5:26:06
      and we just want to and these together.
      5:26:08
      So we're going to throw in a quick and
      5:26:09
      just like that. And now we're anding
      5:26:11
      together all these different wear
      5:26:12
      conditions. And we need to make sure we
      5:26:13
      spread them. And that'll just run
      5:26:15
      whatever our wear conditions are. Now
      5:26:16
      that's something we need to do. So I'm
      5:26:18
      just going to put a little to-do right
      5:26:20
      here.
      5:26:23
      Wear conditions. So we remember to come
      5:26:25
      back and actually implement these wear
      5:26:26
      conditions in a little bit. But we also
      5:26:28
      have other wear conditions that we need
      5:26:29
      to worry about. For example, we have a
      5:26:31
      job listing ID that we sometimes get
      5:26:33
      passed in. So, we can come up here and
      5:26:34
      we can say we have a job listing ID that
      5:26:37
      we know is going to be a string or
      5:26:39
      undefined if we don't have one yet. And
      5:26:41
      we also know for a fact that we're
      5:26:43
      getting our search params. And we're not
      5:26:45
      going to really worry about the type for
      5:26:47
      that. We'll come back for that in a
      5:26:48
      little bit when we actually deal with
      5:26:49
      our searching related information. But
      5:26:51
      in the case that we have a job listing
      5:26:52
      ID, we want to make sure we include that
      5:26:54
      in our list even if it's not one of our
      5:26:56
      things that are returned by our wear
      5:26:58
      clause. So we actually need to have a
      5:26:59
      pretty complicated wear clause here.
      5:27:01
      First of all, we're going to have our
      5:27:02
      job listing ID. If we have a job listing
      5:27:04
      ID, then what I want to do is I want to
      5:27:06
      return an and that first checks to see
      5:27:08
      if we have a job listing that is
      5:27:10
      published.
      5:27:12
      So job listing table status
      5:27:17
      is published. There we go. And I want to
      5:27:20
      make sure it is equal to that job
      5:27:21
      listing ID.
      5:27:24
      Job listing table ID is equal to my job
      5:27:26
      listing ID. So there's my first query
      5:27:28
      that I want to do. Otherwise, I want to
      5:27:30
      do undefined. Just like that. And what I
      5:27:32
      want to do is I want to wrap this entire
      5:27:34
      thing inside of an ore. So we're going
      5:27:35
      to come in here with an ore.
      5:27:39
      There we go. From drizzle, wrap that
      5:27:41
      entire thing inside of an ore. And the
      5:27:43
      second parameter of our ore is just
      5:27:44
      going to be all of our wear clauses
      5:27:46
      right here. Let me make sure I put that
      5:27:48
      on the correct place. Get rid of that
      5:27:49
      parenthesy. And there we go. So
      5:27:51
      essentially, if we have a job listing
      5:27:52
      ID, I'm adding an extra wear clause that
      5:27:54
      just says, hey, check to see if we have
      5:27:56
      a job listing for that particular ID and
      5:27:59
      always make sure it's returned in the
      5:28:00
      list because even if it doesn't match
      5:28:02
      this wear query, if we have it selected,
      5:28:04
      we want it to show up in the list. Then
      5:28:06
      we're doing this wear query for all of
      5:28:08
      our different things. And we also want
      5:28:09
      to of course make sure we only get ones
      5:28:11
      that are published. So in both cases, we
      5:28:12
      only get job listings that are
      5:28:14
      published. In this first wear clause
      5:28:15
      right here, we're checking the ones that
      5:28:17
      match our job listing ID. Second one is
      5:28:19
      matching our search params. Then what we
      5:28:21
      can do is we can specify we want to get
      5:28:22
      organization information from them. So
      5:28:24
      we'll say that we want to get the
      5:28:26
      columns of name and we want to get the
      5:28:28
      image URL which is going to be true.
      5:28:32
      Just like that. This will be true as
      5:28:33
      well. And I think I imported something
      5:28:35
      up here. Yeah, I don't need that. And
      5:28:36
      then finally after this we want to do a
      5:28:38
      simple order by. So we're going to order
      5:28:40
      by descending the is featured. So job
      5:28:42
      listing table isisfeatured. And then we
      5:28:46
      want to search by the posted at date. So
      5:28:48
      descending job listing table.posted at.
      5:28:51
      So of course we're going to put the
      5:28:52
      featured ones first and then the ones
      5:28:54
      that are posted most recently second. So
      5:28:56
      now that we have this function defined,
      5:28:57
      we can actually use that inside of our
      5:28:59
      job listing items. And of course since
      5:29:01
      we're going to be using asynchronous
      5:29:02
      code, we need to put this inside of a
      5:29:04
      suspended boundary. So we'll say
      5:29:05
      suspended component
      5:29:07
      just like that. And then up here we can
      5:29:09
      return suspended
      5:29:12
      or suspense and wrap. Whoops.
      5:29:17
      Our suspended component inside of here.
      5:29:20
      Just like that. And we can of course
      5:29:22
      pass along all of our props. So we'll
      5:29:23
      say type props is equal to and it's just
      5:29:27
      going to be equal to this.
      5:29:30
      There we go. And then I can copy all of
      5:29:33
      this over.
      5:29:36
      Paste that into here. And now we have
      5:29:37
      the exact same props for both of these.
      5:29:43
      And we can just call this props. There
      5:29:46
      we go. So now we have all of our props
      5:29:48
      being passed into our suspended
      5:29:49
      component. And here is where we want to
      5:29:50
      actually use our code to do something
      5:29:52
      with it. So we'll return null for now.
      5:29:54
      And then at the top we need to do a
      5:29:55
      bunch of different checks. So the first
      5:29:57
      thing I want to do is I want to
      5:29:57
      determine do we have a job listing ID.
      5:29:59
      So my job listing ID is params and it's
      5:30:02
      going to be equal to await params if we
      5:30:05
      have it. Joblisting ID otherwise
      5:30:08
      undefined. There we go. I just need to
      5:30:10
      wrap this in parenthesis. There we go.
      5:30:13
      And that's params. And this is an async
      5:30:16
      function. There we go. So now we're
      5:30:17
      getting our job listing ID. And one
      5:30:19
      thing you could do is you could add in
      5:30:20
      like a skeleton loader in this suspense
      5:30:22
      section, but I didn't bother doing that
      5:30:24
      because since we're so heavily caching
      5:30:25
      things, there's not a lot of time that
      5:30:27
      we need to worry about that skeleton
      5:30:28
      loader. So it's not a huge deal. Next, I
      5:30:30
      want to get our job listings. So we can
      5:30:32
      say job listings
      5:30:34
      is equal to get job listings. That takes
      5:30:36
      in our job listing ID as well as our
      5:30:39
      search params.
      5:30:42
      There we go. And of course, we have our
      5:30:44
      search params just there. Now, again,
      5:30:46
      we're going to want to make sure we
      5:30:47
      handle this with ZOD. So, I'm just going
      5:30:48
      to add a simple to-do
      5:30:50
      that says Zod validate. So, we make sure
      5:30:53
      we validate our search params before we
      5:30:54
      throw them directly into our database.
      5:30:56
      Then, if our job listings
      5:31:00
      is equal to zero, and I'll make sure I
      5:31:02
      await this here. There we go.
      5:31:06
      So if our job listings length is equal
      5:31:08
      to zero, we'll just return something
      5:31:10
      that says, "Hey, there's no matches." So
      5:31:11
      we'll return a div with a class name
      5:31:13
      that says text muted foreground padding
      5:31:16
      of four and it'll say no job listings
      5:31:21
      found. There we go. Then otherwise we
      5:31:23
      can go down and we can return what our
      5:31:26
      actual list of job listings is going to
      5:31:27
      look like. So, this is going to be a div
      5:31:29
      with a class of space y4.
      5:31:34
      And then inside of here, we just want to
      5:31:35
      loop through all of our different job
      5:31:37
      listings.
      5:31:39
      So, for each job listing, we'll
      5:31:40
      essentially return a link that's going
      5:31:42
      to render out to that job listing.
      5:31:45
      Here we go. Class name for this is going
      5:31:47
      to be block. Our key is going to be our
      5:31:51
      job listing id.
      5:31:59
      Then we have an href which essentially
      5:32:01
      points to that page which is slashjob
      5:32:03
      listings
      5:32:05
      slash
      5:32:08
      job listing ID.
      5:32:12
      And we want to add our search prams onto
      5:32:14
      the end of this as well. So we'll put a
      5:32:15
      question mark followed by a function
      5:32:17
      called convert
      5:32:20
      search params to string.
      5:32:23
      And we'll pass in what our search params
      5:32:25
      are. And we'll call this search just
      5:32:26
      like that. And up here we'll just say
      5:32:29
      const search is equal to await search
      5:32:33
      params. That way we can use that down
      5:32:35
      here as well. And we just need to make
      5:32:36
      sure we zod validate that particular
      5:32:38
      section. So now we're converting them to
      5:32:40
      a string that we can use. And we'll
      5:32:41
      create a function for that in just a
      5:32:43
      second. Now we can close off our link.
      5:32:45
      And inside of our link, we want to just
      5:32:48
      put our job listing item.
      5:32:51
      Listing list item.
      5:32:56
      There we go. And inside of here, we pass
      5:32:59
      in our job listing
      5:33:03
      and we're going to pass in our
      5:33:04
      organization,
      5:33:07
      which is our organiz job listing.org
      5:33:09
      organization. There we go. So let's go
      5:33:11
      ahead and create this function for
      5:33:12
      converting our search params to a
      5:33:14
      string. We can do that inside of our lib
      5:33:16
      folder. We're just going to do it inside
      5:33:17
      of a function which we'll call convert
      5:33:22
      search params to string.ts.
      5:33:26
      I'm going to paste in what the code for
      5:33:27
      this function looks like. It's
      5:33:28
      relatively straightforward. We take our
      5:33:30
      search params. We're getting our URL
      5:33:32
      params from that and we're just doing
      5:33:33
      object entries on our search prams. If
      5:33:35
      the search params are an array, we loop
      5:33:37
      through each one and add them to the
      5:33:38
      thing. Otherwise, we just set it as an
      5:33:40
      individual value. That's only because
      5:33:42
      you have to do slightly different code
      5:33:43
      for arrays versus non-arrays. And then
      5:33:45
      we convert that to a string, which gives
      5:33:46
      us a URL encoded string that we can use
      5:33:48
      directly inside of our code here. So,
      5:33:50
      we'll import that just like that. And
      5:33:52
      now all we need to do is create this job
      5:33:54
      listing list item. So, we can scroll all
      5:33:56
      the way down here. We might as well just
      5:33:57
      create it as a brand new function in
      5:33:59
      here cuz it's the only place that it's
      5:34:00
      used. Job listing list
      5:34:04
      item. taking in a job listing and an
      5:34:08
      organization just like that. Now, I'm
      5:34:10
      going to copy over the TypeScript type
      5:34:12
      for this because it's kind of
      5:34:13
      complicated. Essentially, we're just
      5:34:14
      picking all the fields that we need from
      5:34:15
      the job listing table. Same thing for
      5:34:17
      the organization table, and we're making
      5:34:19
      sure we get just those particular
      5:34:20
      values. Then, what I want to do is I
      5:34:22
      want to render out all my code. First of
      5:34:24
      all, I want to get the name initials for
      5:34:25
      my organization. This is something
      5:34:26
      that's just like when we did the user
      5:34:28
      and organization buttons. We're just
      5:34:30
      getting the first four letters instead
      5:34:31
      of the first two letters of the
      5:34:33
      organization name split on characters.
      5:34:35
      So the organization name is like what is
      5:34:38
      the name? It would give us the first
      5:34:39
      four letters of the first four or the
      5:34:41
      first letter of the first four words. In
      5:34:43
      this case we have more space which is
      5:34:45
      why we're doing four instead of two.
      5:34:47
      Then what we can do is we can return a
      5:34:48
      card for each one of these. So we'll say
      5:34:50
      that we want to do a card. Make sure we
      5:34:52
      import that from the correct location.
      5:34:54
      We want to get the class name for this.
      5:34:56
      It's going to be from CN.
      5:34:59
      We're going to pass in at container
      5:35:01
      because we're going to be using
      5:35:01
      container queries for this. And then if
      5:35:04
      our job listing is featured, we want to
      5:35:06
      render out a special border and
      5:35:07
      background. So we're going to say
      5:35:09
      amperand right here. Border featured.
      5:35:12
      And we're going to say bg featured /20
      5:35:16
      just to give it a nice little background
      5:35:17
      of that purpley color. Now already we
      5:35:19
      have the card showing up. And since we
      5:35:21
      don't have anything that's featured, I'm
      5:35:22
      going to change one of these job
      5:35:23
      listings to featured. Now I'm not really
      5:35:24
      sure why we're getting an error here. It
      5:35:26
      might be something with caching and
      5:35:27
      nex.js. We're just going to refresh our
      5:35:28
      page. Looks like it may have just been a
      5:35:30
      weird caching thing. I'm going to click
      5:35:31
      feature. So, this job is going to be
      5:35:32
      featured while the other one is not. So,
      5:35:34
      now back to our job board. You can see
      5:35:35
      the featured one has this nice purple
      5:35:37
      color being assigned to it. And when I
      5:35:38
      click on one of these, it will redirect
      5:35:39
      me to that page. So, at least that's
      5:35:40
      working. But I want to finish out
      5:35:42
      styling what this is going to look like
      5:35:43
      before we jump into the rest of it. So,
      5:35:45
      inside of our card, we're going to want
      5:35:47
      to specify a card header.
      5:35:50
      There we go. And inside of our card
      5:35:52
      header, we're going to have a div with a
      5:35:53
      class name of flex and a gap of four to
      5:35:55
      space these content out from each other
      5:35:57
      because we're essentially going to have
      5:35:58
      some icons on one side and we're going
      5:35:59
      to have some other content on the other.
      5:36:01
      So, we're going to have an avatar.
      5:36:04
      There we go. We're going to have a class
      5:36:06
      name with a size of 14 cuz we want this
      5:36:08
      to be rather large and a max small to
      5:36:11
      make it hidden. So, essentially on
      5:36:12
      smaller screen sizes, we actually hide
      5:36:13
      this.
      5:36:15
      Next, we're going to do our avatar
      5:36:17
      image. Make sure I import that from the
      5:36:19
      right location.
      5:36:21
      The source is going to be equal to our
      5:36:23
      organization image URL or undefined. And
      5:36:27
      then finally, our alt is going to be
      5:36:28
      that name. So, organization, whoops,
      5:36:31
      organization.name.
      5:36:34
      We also want to have our avatar
      5:36:36
      fallback. And this one is going to be
      5:36:38
      where we put our name initials.
      5:36:40
      There we go. And this one's going to
      5:36:42
      have quite a few classes applied to it.
      5:36:44
      So, we're going to have an uppercase
      5:36:45
      applied to that background primary. And
      5:36:48
      the text is going to be primary
      5:36:51
      foreground. Just like that. So now we
      5:36:52
      have all of our avatars. You can see
      5:36:54
      that they're showing up quite large,
      5:36:55
      which is exactly what we want. Next,
      5:36:57
      after that, this is where we need to put
      5:36:58
      a div for all the rest of our content.
      5:37:00
      This is going to be a flex in the column
      5:37:01
      direction.
      5:37:04
      And we're going to have a gap of one on
      5:37:06
      these items. And this is where we're
      5:37:07
      going to have things like our card
      5:37:08
      title, which are going to show up right
      5:37:09
      next to the thing that we just created.
      5:37:10
      So our card title, and inside of here,
      5:37:13
      we want to put our job listing.title.
      5:37:16
      And let's have a class of extra-large
      5:37:18
      text on that. So now you can see we have
      5:37:20
      our job title. Next thing we want to do
      5:37:21
      is the card description
      5:37:24
      just like that. And this is going to be
      5:37:26
      a class name
      5:37:28
      of text base. And inside of here we're
      5:37:31
      going to put the name of the
      5:37:31
      organization.
      5:37:33
      So now you can see the two organizations
      5:37:35
      are both the same. But if there was
      5:37:36
      different organizations they would show
      5:37:38
      up there differently. Finally, if the
      5:37:40
      job listing.posted posted at is not
      5:37:43
      equal to null, which it should be if
      5:37:44
      it's showing up on the list, but we
      5:37:46
      still have to check it just because of
      5:37:47
      our TypeScript stuff. Then we want to
      5:37:49
      actually render out what that's going to
      5:37:50
      look like. So we'll say text small font
      5:37:53
      medium text primary whoops primary. And
      5:37:57
      we want to have a min of medium to make
      5:37:59
      this hidden. So on the larger screen
      5:38:01
      sizes, this is going to be hidden. And
      5:38:02
      essentially, this is just going to
      5:38:03
      render out what our days is since this
      5:38:05
      thing was posted. So we're actually
      5:38:07
      going to create a special component for
      5:38:08
      that. days since posting.
      5:38:12
      There we go. We pass in our posted at
      5:38:14
      which is our job listing.posted at and
      5:38:17
      then we can close that off. And we have
      5:38:18
      to wrap this in a suspense because this
      5:38:20
      actually requires whatever the most
      5:38:21
      recent day is. It requires random
      5:38:23
      dynamic data. So that's why we're doing
      5:38:25
      that. And for the fallback for this, we
      5:38:28
      can just say the fallback is going to be
      5:38:29
      our job listing.
      5:38:32
      local date string. There we go. So at
      5:38:34
      least we have a loading fallback for
      5:38:35
      this. Now let's create this async
      5:38:38
      function.
      5:38:39
      days since posting. This again takes in
      5:38:43
      posted at
      5:38:46
      posted at which is a string
      5:38:50
      and this is specifically going to use
      5:38:51
      the date FNS library. So I'm going to
      5:38:53
      npmi date FNS and we're going to force
      5:38:56
      install that just so we have a nice
      5:38:58
      little helper function that we're going
      5:38:59
      to use inside of here. So we can say
      5:39:01
      const days since posted is equal to
      5:39:04
      difference in days with our posted at
      5:39:07
      and the date.now. And this is the reason
      5:39:09
      why we needed to put this in a suspense
      5:39:11
      because this relies on dynamic data in
      5:39:13
      the case of date.now. Now let's import
      5:39:15
      that difference in days. So we'll say
      5:39:18
      import difference
      5:39:20
      in days
      5:39:23
      from date FNS. Scroll all the way back
      5:39:26
      down. So we have that working. And I
      5:39:28
      need to make sure I await calling the
      5:39:30
      connection function. This is how you
      5:39:31
      note in Nex.js that you're using dynamic
      5:39:33
      data even though it doesn't know that.
      5:39:35
      So now we're saying, hey, we're using
      5:39:36
      dynamic data. If the days since posted
      5:39:39
      is equal to zero, that means it was
      5:39:41
      posted within the last 24 hours. So
      5:39:43
      we'll turn a badge
      5:39:46
      that says new just like that. Otherwise,
      5:39:49
      we're going to return essentially what
      5:39:50
      the date would look like. So a new
      5:39:52
      intlative
      5:39:54
      time format. Whatever the user's local
      5:39:56
      is is what we're going to render it in.
      5:39:58
      And we're going to put the style as
      5:39:59
      narrow.
      5:40:01
      And we're going to put it as numeric
      5:40:02
      always. Just like that. And we're going
      5:40:05
      to make sure we format this to be the
      5:40:07
      number of days. So we're going to say
      5:40:09
      days since posting and days. There we
      5:40:11
      go. So it's essentially going to tell us
      5:40:13
      how many days since this job was posted
      5:40:14
      or new in the case of the job being
      5:40:16
      posted recently. I can fake this by
      5:40:18
      saying it was posted, for example, 4
      5:40:20
      days ago. And now you can see if I make
      5:40:22
      sure this is negative, it'll say 4 days
      5:40:24
      ago, which is exactly what we want. Now,
      5:40:26
      if we scroll up a ways, we can kind of
      5:40:27
      copy this because we're going to need
      5:40:28
      this in a separate section. So, outside
      5:40:30
      of this entire flex section right here,
      5:40:32
      we can kind of minimize that down.
      5:40:34
      Actually, not the entire thing. We can
      5:40:36
      just minimize this section down because
      5:40:37
      we want this to show up on the far right
      5:40:39
      side of our screen on the larger screen
      5:40:41
      sizes. So, here we have our job posting
      5:40:43
      existed. All of this stuff is going to
      5:40:45
      be fine. What we want to do is we want
      5:40:46
      our text to be small, font, medium, text
      5:40:48
      primary. Essentially, all this is the
      5:40:49
      same. We want the margin on the left to
      5:40:51
      be auto to push it to the far right. And
      5:40:53
      we only want this to show up on the max
      5:40:55
      screen size. So that should have an
      5:40:56
      amperand in front of it. And that should
      5:40:58
      have an amperand in front of it here as
      5:41:00
      well. There we go. And it looks like
      5:41:02
      we're getting an error with our posted
      5:41:03
      ad. And that's because I made this a
      5:41:05
      string instead of a date. There we go.
      5:41:06
      That fixes that particular problem. And
      5:41:08
      then finally after our header where we
      5:41:10
      can put our content card content we can
      5:41:13
      come in here and we can say we want to
      5:41:15
      have our job listing details
      5:41:19
      detail badges
      5:41:22
      just like that. Make sure I import this.
      5:41:25
      I think I actually just called it job
      5:41:26
      listing badges. There we go. And we can
      5:41:28
      pass in our job listing just like that.
      5:41:32
      And then finally for our content, we're
      5:41:33
      going to come in here with a class name
      5:41:35
      flex flex wrap and a gap of two. There
      5:41:38
      we go. So now you can see our cards are
      5:41:40
      showing up down at the bottom here. And
      5:41:41
      if we're on a larger screen size, you'll
      5:41:43
      notice that this new item will move over
      5:41:45
      to the size. You can see new moves all
      5:41:46
      the way over here on a larger screen
      5:41:48
      size while it's all the way down here on
      5:41:50
      a smaller screen size. Now you'll notice
      5:41:52
      over here these cards are kind of hard
      5:41:53
      to see these badges, sorry. And that's
      5:41:55
      because of the fact that we're on a
      5:41:56
      featured one. So I want to have a class
      5:41:58
      name here. And this class name is only
      5:42:00
      going to take effect if the job listing
      5:42:01
      is featured. Essentially, what I want to
      5:42:03
      do is I want to change what my
      5:42:05
      background for those is going to look
      5:42:07
      like. So, I'm going to just slightly
      5:42:08
      modify the border of those. So, we can
      5:42:10
      come in here and say the primary border
      5:42:11
      of 35 is what we want to use instead.
      5:42:13
      And that's just going to make these
      5:42:14
      borders stand out a little bit more. So,
      5:42:16
      it's easier to see on the featured job
      5:42:17
      listings. That already looks way better.
      5:42:19
      Now, if we change around our screen size
      5:42:20
      on this, you'll notice that we have nice
      5:42:22
      responsiveness for everything. You can
      5:42:23
      see our icons disappear on really small
      5:42:25
      screen sizes. They come back. things are
      5:42:27
      perfectly moving around to be as
      5:42:28
      responsive as it can possibly be on all
      5:42:30
      different screen sizes. So that is all
      5:42:32
      of the stuff for rendering our job
      5:42:33
      listings. The next thing I want to work
      5:42:34
      on is going to be making it so that this
      5:42:36
      get job listing actually works properly
      5:42:38
      with all of our caching and also with
      5:42:39
      all of our search parameters. So at the
      5:42:41
      very top of our page up here, we can
      5:42:43
      specify what our search parameters are
      5:42:44
      going to look like. So we can come in
      5:42:46
      here and we can say search params
      5:42:50
      schema is equal to a new zod object. And
      5:42:54
      this Zod object is going to contain
      5:42:55
      everything we can search for. So for
      5:42:57
      example, the title, we can come in here.
      5:42:59
      We can say that this is optional because
      5:43:00
      everything is optional. And also
      5:43:02
      importantly, we're going to put a catch
      5:43:03
      of undefined on here. What that means is
      5:43:06
      if for some reason the title fails our
      5:43:08
      check, someone passes in a number
      5:43:09
      instead of a string or something like
      5:43:11
      that. It fails our check, it'll just
      5:43:13
      return undefined instead of failing
      5:43:14
      completely. This is really useful
      5:43:16
      because, for example, if we type in a
      5:43:18
      bad search param, we don't want to fail
      5:43:19
      our website by crashing it. We just want
      5:43:21
      to return undefined and not search for
      5:43:22
      that particular value. I want to do the
      5:43:25
      same thing with a city. Again, it's an
      5:43:26
      optional string. Make sure I put my
      5:43:28
      commas in place here. Same exact thing
      5:43:30
      for a state. It's an optional string.
      5:43:32
      Our experience is going to be our
      5:43:34
      experience level. So, this is going to
      5:43:35
      be an enum. And this is going to be
      5:43:38
      experience levels. And this is going to
      5:43:40
      be optional.
      5:43:44
      There we go. And again, if we have
      5:43:45
      something that's not one of those
      5:43:46
      experience levels, we just default to
      5:43:48
      undefined. I'm going to do the exact
      5:43:50
      same thing here with location
      5:43:52
      requirements.
      5:43:55
      There we go. This is location
      5:43:57
      requirements.
      5:44:00
      Make sure I spell that properly. There
      5:44:01
      we go. Then we want to go on a little
      5:44:03
      bit further and we want to work on the
      5:44:04
      type, which again, pretty much the same
      5:44:06
      thing as what we've done before, but
      5:44:07
      this is going to be our job listing type
      5:44:11
      or yeah, job listing
      5:44:14
      type. There we go. Job listing types.
      5:44:17
      Then we finally are going to have
      5:44:18
      something called job ids. This is
      5:44:20
      specifically for when we start to
      5:44:21
      integrate our AI search capabilities.
      5:44:23
      It'll just pass a list of job IDs to
      5:44:25
      this page. So we're going to make sure
      5:44:26
      we handle that as well. And this is
      5:44:28
      going to be a union type right here. And
      5:44:30
      this is going to be a Z.string
      5:44:33
      or it's going to be an array of strings.
      5:44:35
      Zarray of Z.string. Now the reason I'm
      5:44:38
      doing it this way is because search
      5:44:40
      params are kind of dumb. They don't know
      5:44:41
      like if you pass it one value that's
      5:44:43
      supposed to be an array, it's going to
      5:44:44
      return it as a single value. While if
      5:44:46
      you pass it two values, then it'll
      5:44:47
      return it as array. So essentially, this
      5:44:50
      is taking into account if we pass one or
      5:44:52
      many job ids. No matter what I want to
      5:44:54
      transform this to be an array. So we can
      5:44:56
      just say if array is array v, then we
      5:45:00
      return v as is. Otherwise, we return it
      5:45:02
      wrapped inside of an array just like
      5:45:04
      that. So essentially, we're going to be
      5:45:06
      accepting either a string or an array of
      5:45:07
      strings and then I'm converting it to an
      5:45:09
      array no matter what. Also, it should be
      5:45:11
      optional just like everything else
      5:45:13
      inside of our properties. And in the
      5:45:15
      case of a catch, we want to make sure we
      5:45:16
      return an empty array. So this is what
      5:45:18
      our search parameter schema should look
      5:45:20
      like. And now we can actually use that
      5:45:21
      down here for our search params. So we
      5:45:23
      can do a really quick search here by
      5:45:25
      saying that we want to actually get that
      5:45:26
      data. So we can come up here. We can say
      5:45:28
      search param schemasafe
      5:45:30
      parse. We want to safe parse our search
      5:45:32
      params right here. And this is going to
      5:45:34
      return to us success as well as data.
      5:45:39
      And for the most part, success should
      5:45:41
      pretty much always be true because we're
      5:45:42
      catching on everything to make sure it
      5:45:44
      works no matter what. But for some
      5:45:45
      reason, if it doesn't actually work,
      5:45:47
      maybe we don't get an object or
      5:45:48
      something weird happens, then we're just
      5:45:50
      going to make sure we check for that.
      5:45:51
      So, we can say if we have success, then
      5:45:53
      we return our data. Otherwise, we return
      5:45:55
      an empty array, pretending that we're
      5:45:57
      not searching for anything at all.
      5:45:59
      Otherwise, we're just going through and
      5:46:00
      we're getting all of our different job
      5:46:01
      listings, checking the length and
      5:46:02
      everything. So, now we can actually use
      5:46:04
      this search inside of our get job
      5:46:06
      listings. So, we already know the type
      5:46:07
      of this. It's going to be Z.infer type
      5:46:10
      of search params schema because we know
      5:46:12
      that we verified it is that type before
      5:46:14
      we get to this point. And now we
      5:46:15
      essentially just need to do a bunch of
      5:46:17
      wear clauses. So we can get rid of this
      5:46:18
      section right here. And I can say if
      5:46:21
      search params.title, then I want to do
      5:46:23
      something. So if we have a title, then I
      5:46:25
      want to add a wear condition. And this
      5:46:27
      is a wear condition that's going to be
      5:46:28
      an I like. I like essentially is going
      5:46:30
      to be like a regular expression that
      5:46:32
      says does this match anything in the
      5:46:34
      string on either side. So I'll show you
      5:46:35
      a little bit what I'm talking about.
      5:46:36
      It's a lot easier to see if I write it
      5:46:38
      out. So, we'll say job listing
      5:46:40
      table.title
      5:46:42
      and we're going to pass in our search
      5:46:44
      params.title with two percentage signs
      5:46:47
      on each side. These percentage signs act
      5:46:49
      as like an anything or like it'd be like
      5:46:51
      a dot in a regular expression.
      5:46:52
      Essentially, it's saying this can be
      5:46:53
      anything at all, doesn't matter what it
      5:46:55
      is, all the way to the end of the
      5:46:56
      string. And this is saying anything at
      5:46:57
      all all the way to the beginning of the
      5:46:59
      string. So, what this code says is do I
      5:47:01
      have a title that matches this anywhere
      5:47:03
      in my string at all? Doesn't matter if
      5:47:04
      it's at the beginning, end, middle,
      5:47:06
      doesn't matter if it's uppercase,
      5:47:07
      lowerase, doesn't matter at all. Just
      5:47:09
      says, is this in the string somewhere?
      5:47:10
      Then we need to do the exact same thing
      5:47:12
      with our location requirement. I'll copy
      5:47:14
      it over because it's very simple. If we
      5:47:15
      have a location requirement, add a wear
      5:47:17
      clause for it. Same exact thing for city
      5:47:19
      and state. So, here we go. If we have a
      5:47:21
      city, do the same thing with that I like
      5:47:23
      for our city. Otherwise, do an equal
      5:47:25
      clause for our state. Then, we want to
      5:47:27
      do the exact same thing for our type and
      5:47:28
      our experience. I'll copy them over.
      5:47:30
      Exactly the same. Equal on our
      5:47:31
      experience. This is equal on our type.
      5:47:33
      And then finally, our little bit more
      5:47:35
      complicated one is going to be our job
      5:47:36
      ids. So I'll kind of go through what
      5:47:38
      this does. First of all, we're making
      5:47:39
      sure that our job ids is an array, which
      5:47:41
      actually it already should be. So we
      5:47:42
      actually don't even need that line right
      5:47:44
      there. And instead, we can just use
      5:47:45
      search params job ids like this because
      5:47:47
      we already know that it's going to be an
      5:47:48
      array. And we can just push in an
      5:47:50
      individual wear clause for each of them.
      5:47:51
      So if we have like six different job IDs
      5:47:54
      inside of our query, we're going to put
      5:47:55
      an or clause for all of those. So it
      5:47:57
      could be any of those six job IDs. Then
      5:47:59
      finally, we're actually going to use
      5:48:01
      those down here inside of our wear
      5:48:02
      clause. So we can actually kind of
      5:48:04
      simply test this by putting a question
      5:48:06
      mark up here. And we're going to say
      5:48:07
      that we want to specifically look for
      5:48:09
      when we have a job title that has front
      5:48:12
      end in it. So we'll say front
      5:48:15
      end just like that. And if I search, you
      5:48:17
      can see only the one with front end end
      5:48:19
      in it was actually returned to us. Well,
      5:48:20
      if I remove that, you can see it returns
      5:48:22
      all the job listings. So now it's making
      5:48:24
      sure that we're actually caching this.
      5:48:25
      We'll throw in a use cache and a cache
      5:48:27
      tag here is going to be get job listings
      5:48:30
      global tag.
      5:48:32
      Just like that. So, make sure that we
      5:48:33
      get that imported.
      5:48:36
      There we go. Job listings global tag.
      5:48:39
      Looks like I don't have this function
      5:48:40
      created yet. Actually, it's probably
      5:48:41
      because it's job listing global tag.
      5:48:43
      There we go. And now we're at least
      5:48:44
      caching this data. And if we search for
      5:48:46
      to-do, I think, yeah, we already did our
      5:48:47
      ZOD validation. So, that cleaned up all
      5:48:49
      the to-dos that we had in this
      5:48:50
      particular file, and we've listed out
      5:48:51
      all of our different things. Really, all
      5:48:53
      we need to do is make sure when we click
      5:48:54
      on one of these, we actually have a page
      5:48:56
      to render here. And also that we have
      5:48:57
      the filtering on our sidebar. I think
    </chapter>
    <chapter title="Main job board sidebar filter form" start_time="5:48:58">
      5:48:59
      the best place for us to start is going
      5:49:00
      to be the sidebar filtering cuz this is
      5:49:02
      going to set us up for the future with a
      5:49:04
      lot of different things we're going to
      5:49:05
      be doing on the sidebar. That's because
      5:49:07
      this sidebar is going to render
      5:49:08
      different content on different pages. On
      5:49:10
      this page, it's going to render a filter
      5:49:12
      list. If we're on our AI search page, it
      5:49:14
      probably won't have anything in it. And
      5:49:15
      if we're on like our user settings page
      5:49:17
      right here, it's going to have different
      5:49:19
      things for like our resume,
      5:49:20
      notifications, and so on. So, the
      5:49:22
      content on this sidebar changes based on
      5:49:24
      what page we're on. And to do that
      5:49:25
      inside of Nex.js, we're going to be
      5:49:26
      using parallel routes. If you're
      5:49:28
      unfamiliar with them, I'll link a video
      5:49:29
      in the description and in the cards for
      5:49:31
      you so you can kind of check out what
      5:49:32
      that's going to look like, but we'll be
      5:49:33
      going over what it does in this
      5:49:34
      particular application. So, what we want
      5:49:36
      to do inside of this job seeker section
      5:49:38
      is we're going to create a brand new
      5:49:39
      folder called at sidebar. And the naming
      5:49:41
      is very important. This at name in front
      5:49:43
      of here essentially says that we're
      5:49:45
      going to be creating a new section in
      5:49:47
      our application called sidebar. So,
      5:49:48
      inside of our layout, we actually get a
      5:49:50
      brand new component passed into here
      5:49:52
      called sidebar. And we'll actually make
      5:49:53
      this quite a bit bigger so it's easier
      5:49:55
      to work with. So we get our sidebar
      5:49:56
      passed into here. And this sidebar is
      5:50:00
      going to be a React node. And this gets
      5:50:02
      directly passed in from that sidebar
      5:50:04
      section that we just created. So let's
      5:50:06
      just get rid of some of these imports we
      5:50:07
      don't need. And now we have this
      5:50:09
      sidebar. And I essentially want to
      5:50:10
      render this inside my content section
      5:50:12
      here. So we want to just move all of
      5:50:14
      this down. And we want to put inside of
      5:50:17
      here our sidebar.
      5:50:19
      There we go. So whatever we pass as our
      5:50:20
      sidebar is going to render in this
      5:50:22
      particular section. And the routes
      5:50:23
      inside of here are directly tied to the
      5:50:25
      routes associated with it. So if we
      5:50:26
      create just a page.tsx, this is what
      5:50:28
      renders when we're on just our root
      5:50:30
      page, which is the page we're on right
      5:50:31
      now. So let's export a function. Make
      5:50:33
      sure this is default. And this is going
      5:50:35
      to work just like any other page. So
      5:50:36
      this is our job board sidebar page. And
      5:50:40
      inside of we can just return the text of
      5:50:42
      hi.
      5:50:45
      There we go. We give that a quick save.
      5:50:46
      Hopefully if we refresh over here, you
      5:50:48
      can see it works. And you'll now see we
      5:50:49
      get the text high just being printed out
      5:50:50
      inside of our sidebar. So, it's
      5:50:52
      rendering whatever is inside this
      5:50:53
      content over here. Now, for us, we're
      5:50:55
      going to create a job board sidebar. And
      5:50:58
      I'm going to render that out as a
      5:51:00
      component in the shared section. Job
      5:51:03
      board sidebar.tsx.
      5:51:05
      And the reason I'm doing that is because
      5:51:07
      essentially we're going to share this
      5:51:08
      between multiple different pages. So,
      5:51:09
      we're going to say export function job
      5:51:12
      board sidebar.
      5:51:15
      We'll just return null for now. And
      5:51:16
      we'll make sure that we import that
      5:51:18
      right here. So, now at least it'll
      5:51:19
      return nothing for now in our section.
      5:51:21
      Now, the content in this page is
      5:51:22
      relatively straightforward. We have a
      5:51:24
      sidebar group, and essentially I want to
      5:51:26
      make sure that when we have our menu
      5:51:27
      collapsed down to the icon size that
      5:51:29
      this entire group is hidden. Then I just
      5:51:31
      add a little bit of spacing on our
      5:51:32
      content. And finally, we're going to
      5:51:33
      render out a form that we're going to
      5:51:35
      create. So, we'll give this file a quick
      5:51:36
      save. We'll come all the way over to
      5:51:38
      here where we want to create our job
      5:51:39
      sideboard page. So, we go to features,
      5:51:41
      job listings, components. We're going to
      5:51:42
      create a brand new file called a job
      5:51:44
      listing
      5:51:46
      filter form.tsx.
      5:51:49
      There we go. And that is going to be an
      5:51:51
      export function job listing filter form
      5:51:55
      return null. And then we can import it
      5:51:57
      in here to at least get rid of the error
      5:51:59
      that's on our page. Now this is going to
      5:52:01
      be a client component. And we also want
      5:52:04
      to get our search params. So we'll say
      5:52:05
      search params is equal to use search
      5:52:08
      params. Also we're going to create a
      5:52:10
      special value called the any value
      5:52:12
      because often times we might have a drop
      5:52:14
      down that's like what state do you want
      5:52:15
      to select from? You can select a
      5:52:16
      specific state or you can select any
      5:52:18
      state. So this is going to be our any
      5:52:20
      value to represent any state that we
      5:52:21
      want or any job listing or any
      5:52:23
      experience level just anything in our
      5:52:24
      select boxes. Now the next thing we need
      5:52:26
      to do is we need to create our form. So
      5:52:28
      we'll say use form just like this. We're
      5:52:30
      going to pass it in a resolver and
      5:52:33
      that's going to be a zod resolver which
      5:52:35
      is going to take in a job listing filter
      5:52:38
      schema and we'll just define that up
      5:52:39
      here because it's only used in one
      5:52:41
      place. So job listing filter schema zod
      5:52:44
      object
      5:52:48
      and we have a title which is a string
      5:52:50
      from zod. There we go. Dot optional.
      5:52:56
      Make sure I don't import that. Don't
      5:52:58
      need that anymore. There we go. I'm
      5:52:59
      going to do the same exact thing with a
      5:53:01
      city.
      5:53:03
      There we go. We also need our state
      5:53:05
      abbreviation.
      5:53:09
      Exactly the same thing. It's a string.
      5:53:11
      And it can also have the Z.literal value
      5:53:14
      of our any value. So any value. There we
      5:53:18
      go. And we of course want this to be
      5:53:20
      optional. Then the next thing that we
      5:53:22
      need to do is we need to have our
      5:53:23
      experience level. Our experience level
      5:53:25
      is going to be an enum
      5:53:28
      which is going to be experience levels
      5:53:31
      and it's also going to have the ability
      5:53:32
      to have that same literal value. So I'm
      5:53:34
      just going to copy over this code and
      5:53:35
      I'm going to paste that down because
      5:53:36
      again this is also optional.
      5:53:40
      There we go. I'm going to copy this down
      5:53:41
      for a few more because we have our type
      5:53:43
      which is going to be our job listing
      5:53:46
      types.
      5:53:50
      There we go. And then finally we have
      5:53:51
      our location requirement
      5:53:55
      which is our location requirements. And
      5:53:57
      again it can also be the any value. So
      5:53:59
      this is essentially all of our different
      5:54:01
      things that we can filter based on. And
      5:54:02
      now we just need to use a form for
      5:54:04
      those. And we also need to specify some
      5:54:06
      default values. So the default values
      5:54:07
      are going to be coming from our search
      5:54:09
      grams. So we can say title is
      5:54:10
      searchprams.get
      5:54:12
      title
      5:54:14
      or if we don't have a title, it's going
      5:54:16
      to be an empty string. And essentially
      5:54:18
      that's how all of these are going to
      5:54:19
      work. So my city is going to be the
      5:54:20
      exact same thing. City or an empty
      5:54:22
      string. My location requirement is going
      5:54:24
      to be a little bit different because
      5:54:25
      we're going to get our location
      5:54:27
      requirement here.
      5:54:30
      Whoops. Requirement.
      5:54:33
      And I specifically need to cast this to
      5:54:36
      the type of location requirement. so
      5:54:38
      that TypeScript knows that this is going
      5:54:40
      to be a location requirement or I'm
      5:54:42
      going to default it. So there we go.
      5:54:43
      Requirement. I'm going to do the exact
      5:54:45
      same thing with my state abbreviation.
      5:54:47
      This one is going to get my state.
      5:54:48
      Otherwise, it's going to default to any
      5:54:50
      value. I'm going to do the exact same
      5:54:53
      thing up here. So location requirement
      5:54:54
      will default to any value if I don't
      5:54:56
      have a specific value for it. My
      5:54:58
      experience level, same exact thing.
      5:55:00
      Going to default to that. And it's going
      5:55:02
      to work just the same as the one up
      5:55:03
      here. So I'm going to copy this over.
      5:55:06
      Experience level. I think I just called
      5:55:08
      it experience. There we go. And this is
      5:55:10
      going to be an experience level type.
      5:55:12
      And then finally, we have our type,
      5:55:14
      which is just the same as these ones.
      5:55:16
      This one is going to be called type. And
      5:55:18
      this is a job listing type. Now, we can
      5:55:20
      actually do our form down here. And
      5:55:21
      luckily, this form is a rather simple
      5:55:23
      form compared to some of the other ones
      5:55:24
      we've worked with. Close that off. Make
      5:55:27
      sure that I import this from the correct
      5:55:28
      location. We want to do a form. Onsubmit
      5:55:32
      is going to be equal to form.andsubmit.
      5:55:35
      and it's going to take in on submit.
      5:55:38
      Class name here is going to be space Y6.
      5:55:44
      And then we can render out each one of
      5:55:45
      our individual form fields. Let's go
      5:55:47
      ahead and create our onsubmit function
      5:55:48
      real quick. Data, which is Z.infer,
      5:55:52
      which is our filter schema.
      5:55:54
      Job listing
      5:55:58
      filter schema. What did I call it? Oh, I
      5:56:00
      have to put typo in front of it. That's
      5:56:01
      why it's not working. There we go.
      5:56:04
      And we can close that off
      5:56:08
      and we can just console log our data for
      5:56:10
      now. So now let's go ahead and create
      5:56:12
      each one of our individual form fields.
      5:56:13
      I'll copy over this first one because
      5:56:14
      it's going to be pretty similar to what
      5:56:16
      we've created before. First of all, this
      5:56:17
      is a field of title. You can see we
      5:56:19
      wrapped it inside of an item
      5:56:22
      with a label which we just called job
      5:56:24
      title followed by that form control our
      5:56:27
      input and then finally the form message
      5:56:29
      if we have any errors even though we
      5:56:31
      shouldn't have errors on this particular
      5:56:32
      form. So now hopefully if we open up our
      5:56:34
      sidebar, you can see we have our job
      5:56:36
      title as our very first form that we can
      5:56:38
      fill in some information inside of and
      5:56:39
      we can do a search, but right now it's
      5:56:41
      not hooked up to anything. So let's copy
      5:56:43
      this down because we're going to do this
      5:56:44
      for pretty much all of our fields. We
      5:56:45
      have our location
      5:56:48
      requirement and this one is going to be
      5:56:49
      a select. So I'm just going to kind of
      5:56:51
      copy over what we had before because
      5:56:52
      this is the same as the select that we
      5:56:53
      used in the previous form. So it's going
      5:56:55
      to be a select. We're going to get our
      5:56:57
      select trigger which I need to make sure
      5:56:59
      I import from the correct location.
      5:57:01
      Select value, select content, select
      5:57:05
      item, and then finally here, format our
      5:57:08
      job location requirement, which I
      5:57:10
      believe we have a function for. Format
      5:57:13
      location requirement. There we go. Now,
      5:57:14
      I believe I may have imported something
      5:57:15
      incorrectly. So, let me do a quick
      5:57:17
      double check to make sure. Yes, it looks
      5:57:18
      like I imported the wrong select
      5:57:20
      element. Let me make sure I import that
      5:57:22
      from my components. There we go. That
      5:57:23
      works fine. So, as you can see, for our
      5:57:25
      select element, we just have our select
      5:57:26
      value. And then down here is the
      5:57:28
      important part. We're looping through
      5:57:29
      all our location requirements and we're
      5:57:30
      also adding this any option. So if I
      5:57:32
      give this a save and we open this up,
      5:57:34
      you can see that we have any or any of
      5:57:36
      these other options that aren't any. So
      5:57:37
      you can see in office or we can just say
      5:57:39
      give me anything. Now I'm going to copy
      5:57:40
      over the next few that we have to do
      5:57:42
      because they're all pretty much exactly
      5:57:44
      the same. So st city is exactly the same
      5:57:46
      as title. I just changed the word from
      5:57:47
      title to city. State abbreviation is
      5:57:50
      exactly the same. It's just we're
      5:57:51
      looping over our states instead of our
      5:57:53
      locations. If I go a little further,
      5:57:55
      experience level or job type, I'm sorry,
      5:57:57
      is what this one is. exactly the same,
      5:57:58
      but I loop over my job types instead of
      5:58:00
      my location requirements. And experience
      5:58:02
      level is the same thing, but looping
      5:58:03
      over experience levels instead. So, that
      5:58:05
      gives us all of our different fields
      5:58:06
      that we need to work with. We'll give
      5:58:08
      this a quick refresh, and we'll open up
      5:58:10
      our page here, and you can see now we
      5:58:11
      have everything inside here. Job title,
      5:58:13
      location, city, state, job type,
      5:58:14
      experience level, and then all of our
      5:58:16
      filters down below. Now, we just need to
      5:58:18
      be able to add a button. So, we can come
      5:58:19
      in here with a button. Make sure we get
      5:58:21
      it from the correct location. Make sure
      5:58:23
      that we disabled this in the case of our
      5:58:25
      form submitting. So we can say form
      5:58:27
      state issubmitting.
      5:58:30
      And then we can make sure that the type
      5:58:32
      is submit and the class name on this one
      5:58:35
      is w full. So it fills the full width
      5:58:37
      since it's kind of a small sidebar. And
      5:58:39
      then we can use our loading swap to
      5:58:41
      render out our text of either filter or
      5:58:43
      the loading indicator. And we'll get is
      5:58:45
      loading which is form.state
      5:58:48
      issubmitting. There we go. So now I
      5:58:51
      actually have an ability to submit this
      5:58:52
      form. Click filter. And right now it
      5:58:54
      doesn't do anything, but it will
      5:58:55
      actually filter our form as soon as we
      5:58:56
      implement the onsubmit function. So
      5:58:58
      we'll come all the way to the top of our
      5:58:59
      page up here and we'll work on making
      5:59:01
      this onsubmit work because this is
      5:59:03
      essentially just going to redirect us to
      5:59:04
      a new route. So what I want to do is I
      5:59:06
      want to convert this form to search par
      5:59:08
      prams. So I can say const new params is
      5:59:10
      equal to new URL search params and then
      5:59:13
      I can just say hey if my data city
      5:59:16
      then what I want to do is I want to take
      5:59:18
      my new params and I want to set city
      5:59:21
      equal to my data.c city. Then I can do
      5:59:25
      the same thing with everything else that
      5:59:26
      I have. But the caveat is many of these
      5:59:28
      have an any option. So I want to make
      5:59:29
      sure if the any option selected I don't
      5:59:31
      actually put it in there. So for example
      5:59:33
      data.state state abbreviation. If we
      5:59:35
      have one of those and the state
      5:59:36
      abbreviation is not equal to any, then
      5:59:39
      what I want to do is I want to be able
      5:59:41
      to put it in there. So, new params
      5:59:44
      set state and that is data.state
      5:59:47
      abbreviation. There we go. And
      5:59:49
      essentially I want to do that exact same
      5:59:50
      thing for all of my different things. So
      5:59:52
      down here we can do title.
      5:59:55
      There we go. The next one I want to do
      5:59:56
      is experience level
      6:00:00
      and this is called experience.
      6:00:05
      I can do the exact same thing with type
      6:00:08
      and make sure I spell experience
      6:00:09
      correctly. There we go. This one is
      6:00:12
      going to be type and type.
      6:00:16
      And of course, I have my location
      6:00:17
      requirement as well.
      6:00:20
      And finally, once we're done creating
      6:00:22
      all of our new prams, I want to redirect
      6:00:23
      to that route. So we can use the router
      6:00:25
      which is from the use router hook and I
      6:00:28
      can come down here and I can say
      6:00:30
      router.push.
      6:00:32
      I can push in my path name. I can get my
      6:00:36
      search params and I can say new params.2
      6:00:40
      string just like that. And to get our
      6:00:42
      path name we can just come in here and
      6:00:43
      we can say path name
      6:00:47
      is equal to use path name. There we go.
      6:00:49
      So now we're just essentially taking our
      6:00:51
      current path and we're appending down
      6:00:52
      these new prams to our search. So let's
      6:00:54
      say that I want to do a location
      6:00:56
      requirement of in office and I click
      6:00:58
      filter. You'll notice up here location
      6:01:00
      requirement is set to in office and
      6:01:02
      there's no results that are in office
      6:01:03
      only. So let's change that back to any
      6:01:05
      and let's go ahead and say that we want
      6:01:07
      our job type to be full-time. We'll
      6:01:08
      click filter. You can see we have our
      6:01:10
      full-time jobs showing up. Let's go
      6:01:12
      ahead and actually try to make one of
      6:01:13
      these filters a little bit better. So
      6:01:14
      we'll change the title to front. That
      6:01:16
      should show us just those front-end
      6:01:17
      jobs, which you can see it does, which
      6:01:18
      is perfect. So, you can see that this is
      6:01:20
      working pretty much just like we
      6:01:21
      expected to. If I try to set a state,
      6:01:23
      for example, to Arizona, we'll notice
      6:01:25
      that nothing actually shows up over on
      6:01:26
      the side here. Now, one problem is
      6:01:27
      you'll notice that this stays open when
      6:01:29
      we do our filter. I probably want to
      6:01:30
      close this when we do that. So, we can
      6:01:32
      say const set open mobile or whatever it
      6:01:34
      is from use sidebar.
      6:01:37
      Let's see. It's called set open mobile.
      6:01:39
      Inside of here, when we submit, I just
      6:01:41
      want to set open mobile to false. There
      6:01:43
      we go. So now when we click filter, you
      6:01:45
      can see it closes that out, which is
      6:01:46
      exactly what we want. And if we change
      6:01:47
      this back to any, click filter, you can
      6:01:49
      see we have our job right there. So now
    </chapter>
    <chapter title="Job listing page" start_time="6:01:50">
      6:01:50
      that we finished up with this full
      6:01:52
      sidebar working exactly as we wanted it
      6:01:53
      to, we can go ahead and work on what the
      6:01:55
      page looks like when we actually click
      6:01:56
      on a specific job listing. And the nice
      6:01:58
      thing is you can see our filter prams
      6:02:00
      are still saved in here, which is really
      6:02:01
      good for making sure we have consistency
      6:02:02
      between these different pages. So let's
      6:02:04
      go ahead. We're going to minimize down a
      6:02:06
      lot of stuff. We're going to close out
      6:02:07
      of all of these. And I want to open up
      6:02:08
      the source folder. I specifically want
      6:02:10
      to go into the components or not the
      6:02:12
      components, the app section. In our job
      6:02:14
      seeker section, we're going to create a
      6:02:15
      brand new folder which is going to be
      6:02:16
      called job listings. And we want to
      6:02:20
      specifically get the job listing ID
      6:02:25
      ID. Just like that, we're going to
      6:02:27
      create a brand new page.
      6:02:30
      And inside of here, we're essentially
      6:02:31
      going to create this function that takes
      6:02:32
      in our params as well as our search
      6:02:34
      params. We also need to make sure that
      6:02:36
      we have an export for our sidebar as
      6:02:38
      well. So here we'll just return null.
      6:02:40
      And you'll notice that things aren't
      6:02:42
      quite going to work as we expect because
      6:02:43
      it's giving us a 404 because our sidebar
      6:02:45
      doesn't have a page for that as well. So
      6:02:47
      I will go ahead and I will copy this in.
      6:02:50
      So let me just delete this cuz I
      6:02:51
      accidentally copied it. There we go.
      6:02:53
      I'll copy this. Paste it into here. And
      6:02:55
      inside of our page, we want it to look
      6:02:57
      identical to the page that we have here.
      6:02:58
      So there we go. Let's just make sure our
      6:03:00
      import comes from the correct location.
      6:03:02
      And now we have the correct sidebar. If
      6:03:03
      I refresh, we should see it actually
      6:03:05
      shows up. Looks like I need to restart
      6:03:07
      my dev server. We'll just do that real
      6:03:09
      quick. Might as well do a quick restart.
      6:03:11
      Most likely because of the way my
      6:03:12
      imports changed around different things.
      6:03:14
      And now if we refresh, looks like it
      6:03:16
      says it still can't find this module for
      6:03:18
      app sidebar. Most likely this is just
      6:03:20
      caching some weird stuff. So we're going
      6:03:21
      to come in here, delete our next.js
      6:03:23
      folder, rerun our application. That
      6:03:25
      often will happen if you have weird
      6:03:27
      caching related issues. Just try to
      6:03:29
      delete your folder. But it looks like
      6:03:30
      that's still not quite fixing our
      6:03:31
      problem. Looks like it says it can't
      6:03:32
      find our module for ingest, which is
      6:03:34
      kind of weird. So, we can go ahead and
      6:03:35
      we can check to see there are errors
      6:03:37
      inside of here, which is very weird. Did
      6:03:39
      I accidentally delete the wrong folder?
      6:03:41
      Possibly. Ingest functions. Yeah, that
      6:03:44
      all looks like it's correct. Okay, I
      6:03:46
      figured out what the issue was. Sorry,
      6:03:47
      that was a little bit of a pause and a
      6:03:48
      little disjointedness. For some reason,
      6:03:50
      I accidentally deleted my tsconfig.json
      6:03:52
      and then it automatically created one
      6:03:54
      that didn't have this path section set
      6:03:56
      inside of it. So, now we have that
      6:03:57
      fixed. All of our imports are working
      6:03:58
      properly. We're still getting this 404
      6:04:00
      error though, so we need to figure out
      6:04:02
      exactly what's going on in there. If I
      6:04:03
      look at everything, you can see we have
      6:04:04
      job listings, job listing ID. Here it's
      6:04:06
      job listing ID. So I'm missing the job
      6:04:08
      listing folder. So we can say job
      6:04:11
      listings. Just like that. Put this
      6:04:13
      inside of there. And now we have
      6:04:15
      everything set at the right level. I
      6:04:16
      most likely probably need to reimpport
      6:04:18
      some things. Give it a quick save. And
      6:04:19
      there we go. You can now see we still
      6:04:21
      have our sidebar showing up. And we're
      6:04:23
      rendering currently this page, which is
      6:04:24
      just rendering null. But if we give it
      6:04:26
      some text, you can see the text show up.
      6:04:27
      Now for this particular section, we're
      6:04:28
      going to be rendering out resizable
      6:04:30
      panels. So, I'm going to be getting
      6:04:31
      those from Shad CN. It's called
      6:04:33
      resizable.
      6:04:36
      Just like that. Of course, we're
      6:04:37
      probably going to have to force install
      6:04:38
      this. There we go. That's going to work
      6:04:40
      fine. So, now we can use those resizable
      6:04:42
      panels. So, I'm going to put this inside
      6:04:44
      of a fragment. And then we'll say
      6:04:46
      resizable panel. And in this case, we
      6:04:48
      want to get a resize group. So, we'll
      6:04:50
      say resizable panel group. That's going
      6:04:52
      to be a group that contains our panels.
      6:04:55
      And then we want to have an autosave ID.
      6:04:57
      So we can say autosave ID is going to be
      6:04:59
      equal job board panel. What this does is
      6:05:02
      it'll save what our size of our panels
      6:05:04
      are inside of our local storage. So that
      6:05:06
      way when we come back to our page, it
      6:05:07
      saves the same panel size. Also, our
      6:05:10
      direction is going to be horizontal. And
      6:05:12
      now we can close this off and we can put
      6:05:13
      our resizable panels directly inside of
      6:05:15
      here inside of here. So we have a
      6:05:16
      resizable panel. The ID on this one is
      6:05:19
      going to be left. That way we make sure
      6:05:20
      we keep our panels in the correct
      6:05:22
      orientation and order. And same thing
      6:05:23
      here, we're going to put an order of
      6:05:25
      one. So this one always shows up first.
      6:05:27
      Next, we're going to have a default size
      6:05:29
      of 60. And we're going to have a min
      6:05:31
      size of 30. And this is percentages. So
      6:05:33
      the minimum this can be is 30% of the
      6:05:35
      screen. And the large the default of
      6:05:37
      this is 60% of the screen. And this is
      6:05:39
      the lefth hand side. This is like the
      6:05:40
      job list side. And inside of here, we're
      6:05:42
      going to have a div class name P4. H is
      6:05:45
      going to be screen. And we're going to
      6:05:47
      have an overflow of Y that's going to be
      6:05:49
      auto. Just like that. So that this will
      6:05:51
      scroll if we need it to. And inside of
      6:05:53
      here is where we're going to put those
      6:05:54
      job listing items. That's a component
      6:05:56
      that we already created. So, we can just
      6:05:58
      do that. And we can pass in all of our
      6:05:59
      different search prams that we want. And
      6:06:01
      we can also pass in the pram as well.
      6:06:03
      So, we'll say prams just like that. Now,
      6:06:05
      our next panel is going to be a little
      6:06:06
      bit interesting because sometimes it's
      6:06:07
      going to be a panel. And sometimes we're
      6:06:09
      going to have a sheet like this where
      6:06:10
      our sidebar pops in and pops out because
      6:06:11
      on a small screen size, it doesn't make
      6:06:13
      sense to have two panels side by side.
      6:06:15
      It's better to make one pop in over the
      6:06:16
      top of the other. So, we're going to
      6:06:18
      create a component called is breakpoint.
      6:06:20
      And this is breakpoint component is
      6:06:22
      going to take in a breakpoint. For
      6:06:23
      example, min width 1024 pixels. That's
      6:06:26
      the breakpoint we're going to use. And
      6:06:28
      it's going to render out the code inside
      6:06:29
      of it if we meet that breakpoint.
      6:06:31
      Otherwise, we can render out code inside
      6:06:33
      of an otherwise section. Very similar to
      6:06:35
      how we did for our asynchronous if. So,
      6:06:36
      let's go ahead and create that is
      6:06:38
      breakpoint component real quick. We'll
      6:06:39
      go into our components folder. We'll
      6:06:41
      create that file. Isbreakpoint.tsx.
      6:06:44
      Export a function called is breakpoint.
      6:06:48
      And we're going to come up here and
      6:06:49
      we're going to make sure that this is a
      6:06:50
      client component because we're going to
      6:06:52
      be using a few hooks inside of here. So
      6:06:54
      we can say const is breakpoint is equal
      6:06:56
      to use is breakpoint which is a hook
      6:06:59
      that we'll create in just a second.
      6:07:00
      Breakpoint and we'll return is
      6:07:03
      breakpoint otherwise we'll return here
      6:07:05
      our children or we'll return otherwise.
      6:07:08
      So now let's make sure we get all those
      6:07:09
      different components. We have
      6:07:10
      breakpoint. Let's actually just do it
      6:07:12
      here. Breakpoint is going to be a
      6:07:14
      string.
      6:07:16
      We have children which is a react node
      6:07:19
      and we have otherwise which is going to
      6:07:21
      be optional and that is also a react
      6:07:23
      node. There we go. So now we can make
      6:07:26
      sure that we render all that different
      6:07:27
      content out. So here we have our
      6:07:29
      breakpoint our children and our
      6:07:30
      otherwise. Now down here we can do a
      6:07:33
      function use is breakpoint take in a
      6:07:36
      breakpoint that's a string.
      6:07:39
      And this is pretty much code that we've
      6:07:40
      kind of already seen. So I'm just going
      6:07:41
      to copy it over and explain what it
      6:07:43
      does. So you can see here we have our
      6:07:45
      use state and our use effect. The use
      6:07:47
      effect is for setting up our actual
      6:07:49
      media query to determine are we at that
      6:07:51
      breakpoint or not by just wrapping it
      6:07:52
      inside of parenthesis and putting in the
      6:07:54
      breakpoint. Same thing we did with
      6:07:55
      prefers media query. Same thing the use
      6:07:57
      is mobile hook is doing. They're all
      6:07:58
      hooked up to this use is breakpoint. So
      6:08:00
      that's all we're going to do. If we are
      6:08:02
      at the breakpoint it returns true
      6:08:03
      otherwise false. So we can render
      6:08:04
      whichever one of these components we
      6:08:06
      want. Now we can come in here with use
      6:08:08
      is breakpoint and we can render out what
      6:08:10
      our children are going to look like. So
      6:08:12
      in the first case when we are at that
      6:08:13
      larger screen size I want to render out
      6:08:16
      a resizable handle handle just like
      6:08:18
      that. I'm going to say with handle which
      6:08:20
      is going to add like a little grabber on
      6:08:22
      it so that way it's easy for people to
      6:08:24
      know they can actually change the size
      6:08:25
      of it. And then we'll come in here with
      6:08:26
      a class name and we're going to add a
      6:08:27
      little bit of margin of two on the left
      6:08:29
      and right. We can also make this so it
      6:08:32
      self-closes. And then we can go ahead
      6:08:34
      with a resizable panel. And this one's
      6:08:36
      going to have an ID of right cuz it's
      6:08:37
      our right side panel. Order is two cuz
      6:08:39
      it's the second one that we want to
      6:08:40
      render. Default size on this one is
      6:08:42
      going to be 40. Essentially 60 or 100
      6:08:44
      minus 60. And the minimum size on this
      6:08:47
      one is also going to be 30. So it can't
      6:08:49
      get too small.
      6:08:51
      Finally, we want to render what's inside
      6:08:52
      of here, which is a class with a padding
      6:08:54
      of four h of screen and the overflow y
      6:08:57
      of auto again to make sure everything
      6:08:59
      scrolls properly. There we go. And
      6:09:02
      inside of this, I want to render out
      6:09:04
      essentially my job listing details. So
      6:09:05
      we're going to render out job listing
      6:09:08
      details just like this. It's going to
      6:09:10
      take in my params and my search
      6:09:15
      params.
      6:09:17
      There we go. Close that off. This is a
      6:09:19
      component we'll create down below in
      6:09:20
      just a second. But I do want to wrap
      6:09:22
      this in a suspense.
      6:09:24
      And the suspense is going to have a nice
      6:09:26
      fallback inside of it, which is going to
      6:09:27
      be our loading spinner. And we're going
      6:09:29
      to create a custom component for this
      6:09:31
      loading spinner just because this is
      6:09:34
      something we're going to most likely use
      6:09:35
      in quite a few places. So, we're going
      6:09:37
      to come over to here inside of our
      6:09:38
      components folder, create that loading
      6:09:41
      spinner, export a function called
      6:09:43
      loading spinner, and I might as well
      6:09:45
      just copy this over because it's really
      6:09:46
      just a few classes applied to a loading
      6:09:48
      icon. So, what we're doing with this is
      6:09:50
      we're essentially saying it should take
      6:09:52
      up the full width and the full height of
      6:09:53
      whatever container it's inside of. It
      6:09:55
      should center everything, so itself, and
      6:09:57
      it should make sure it animates in a
      6:09:58
      spin direction and has a size of 16 by
      6:10:00
      default, which is a decently sized
      6:10:01
      spinner. So really, we're just taking a
      6:10:03
      spinner and centering it inside of
      6:10:04
      whatever container it's inside of. So
      6:10:06
      that's what this loading spinner right
      6:10:07
      here does. And then job listing details.
      6:10:10
      We'll create that function real quick.
      6:10:11
      Job listing details
      6:10:14
      return null. Just so at least we have
      6:10:15
      something to render on our page. And if
      6:10:17
      we refresh, we should hopefully see
      6:10:18
      things work. And of course, it's not
      6:10:19
      working cuz we need to specify this
      6:10:21
      other property. So in our case, we're
      6:10:22
      going to specify that we want to render
      6:10:23
      out a client sheet. This is going to be
      6:10:26
      a component that we create inside of
      6:10:28
      here because we need to have a client
      6:10:29
      component for this. So, I'm going to
      6:10:31
      make sure we come in here with an
      6:10:32
      underscoreclient sheet because I need to
      6:10:34
      do a few special things inside of there.
      6:10:36
      Now, inside this client sheet, I want it
      6:10:38
      to work just like a sheet inside of Chad
      6:10:40
      CN. So, we want to have a sheet content.
      6:10:44
      And this sheet content is going to hide
      6:10:46
      the close button, which is something
      6:10:48
      that we need to actually create
      6:10:49
      ourselves. So, we'll say class name P4
      6:10:53
      P4 just like that. Then, we can put our
      6:10:55
      sheet content inside of here, which is
      6:10:57
      going to be our sheet header. We'll make
      6:10:58
      sure that this is a screen reader only
      6:11:00
      version of our header.
      6:11:03
      And this will have a sheet title and
      6:11:05
      this is just going to say that it's
      6:11:06
      going to be our job listing details. And
      6:11:09
      this is just to help people that are
      6:11:11
      using a screen reader know that when
      6:11:12
      this opens up, this is opening up to job
      6:11:14
      listing details. Finally, we need a
      6:11:17
      suspense which is going to fall back to
      6:11:19
      that loading spinner.
      6:11:23
      And this suspense is going to render out
      6:11:24
      our job listing details. So I might as
      6:11:26
      well just copy that and paste it
      6:11:28
      directly down into there because that's
      6:11:29
      what it's going to render inside of our
      6:11:30
      container. Now we need to render out the
      6:11:32
      ability to hide our close button as well
      6:11:34
      as this client sheet. So let's work on
      6:11:35
      this client sheet first. Our client
      6:11:38
      sheet only has one property which is
      6:11:40
      going to be children which is coming
      6:11:41
      from our React node. And we want to
      6:11:43
      return a sheet. The open property is
      6:11:46
      going to be determined by us. So we're
      6:11:47
      going to have an isop property. So we
      6:11:49
      can come up here. Const is open. Set is
      6:11:53
      open is equal to use state. There we go.
      6:11:57
      And by default, we'll just set that to
      6:11:58
      true because on the page, if we're here,
      6:12:00
      we want it to be open. And then we also
      6:12:02
      want to come into our sheet on open
      6:12:04
      change.
      6:12:06
      There we go. Make sure I close all this
      6:12:09
      off properly. This should say sheet.
      6:12:11
      Make sure it's importing from the
      6:12:13
      correct location.
      6:12:15
      There we go. And I believe the reason
      6:12:17
      this is not working is because I need
      6:12:18
      this to be a tsx file. There we go. So
      6:12:21
      now we can import our sheet from the
      6:12:22
      correct location. On open change will
      6:12:24
      return to us whether or not it is open.
      6:12:26
      So we would get an open property from
      6:12:28
      here. And if open is true, then I just
      6:12:31
      want to return because I don't really
      6:12:33
      care. Otherwise, I will set is open to
      6:12:36
      false.
      6:12:37
      And I want my router whoops router.push
      6:12:41
      push to push essentially the route that
      6:12:44
      closes us by bringing us back to where
      6:12:45
      we were before. So essentially what I'm
      6:12:47
      going to do is I'm going to take here my
      6:12:50
      search params
      6:12:52
      and I'm going to convert them to a
      6:12:53
      string. So we need to get our router and
      6:12:54
      our search prams.
      6:12:57
      So here's our router
      6:13:02
      and then we can say search params is
      6:13:04
      equal to use search params just like
      6:13:06
      that. So now we essentially are
      6:13:08
      navigating back to the page we were on
      6:13:09
      before. if we are closing out of this.
      6:13:11
      So for example, if we hit escape or the
      6:13:13
      close button or so on. And I also want
      6:13:15
      this to be a modal. So I'll specify a
      6:13:16
      modal. And then we'll specify the
      6:13:18
      children inside of there. And that's
      6:13:19
      everything really. I just want to be
      6:13:21
      able to control that open state and
      6:13:22
      route us to the correct location. That's
      6:13:23
      the only reason why this has to be a
      6:13:25
      client component. Also, I mentioned it
      6:13:27
      needed to be client. Put use client at
      6:13:29
      the top. Now we can come into here and
      6:13:31
      we can import that client sheet. And now
      6:13:33
      all we need to do is add the hide close
      6:13:34
      button to our sheet content. So here we
      6:13:37
      want to have hide close button.
      6:13:40
      There we go. By default, this is going
      6:13:43
      to be equal to false. And we want to
      6:13:45
      make sure in here hide close button is
      6:13:48
      an optional boolean.
      6:13:50
      There we go. And then just wherever our
      6:13:52
      close button is at, which is way down
      6:13:53
      here, we can say if we want to hide our
      6:13:55
      close button, don't show it. So we say
      6:13:58
      if we don't hide our close button, then
      6:13:59
      we're going to show this particular
      6:14:01
      content, which is our close button
      6:14:02
      itself. Because we already have our own
      6:14:04
      custom close button we're going to
      6:14:05
      implement. So now you can see we have
      6:14:07
      this showing up. Now our job listing
      6:14:08
      items, this should be job listing
      6:14:10
      details instead of job listing items. So
      6:14:12
      I want to make sure here job listing
      6:14:13
      details right there. Now if I give that
      6:14:15
      a quick save, you can see it renders
      6:14:16
      null because right now job listing
      6:14:17
      details is null. So let's copy over all
      6:14:19
      this parameter related stuff because
      6:14:21
      this is all the parameters we're going
      6:14:22
      to be passing into our job listing
      6:14:24
      details so that we can use them inside
      6:14:25
      here. For example, I want to get my job
      6:14:28
      listing ID which is equal to awaiting
      6:14:30
      params. I also want to get my job
      6:14:32
      listing which is a wait get job listing
      6:14:36
      with my job listing ID
      6:14:39
      and I need to make sure that this is an
      6:14:41
      asynchronous function and this get job
      6:14:43
      listing function I'm going to paste in
      6:14:44
      and explain exactly what's going on
      6:14:46
      because it's pretty similar to stuff
      6:14:47
      that we've already seen before. Let me
      6:14:49
      just make sure we get all of our
      6:14:50
      different imports in place and our last
      6:14:53
      import right here. There we go. And
      6:14:55
      there we are. So essentially what I'm
      6:14:57
      doing is I'm getting my job listing. So
      6:14:58
      I'm getting my job listing based on an
      6:15:00
      ID. You can see here my wear clause to
      6:15:01
      make sure it's a published job listing
      6:15:03
      and it's based on ID. And I'm also
      6:15:04
      getting my organization information. And
      6:15:06
      if my listing is not equal to null, then
      6:15:08
      I'm essentially just making sure that I
      6:15:10
      cach based on my organization ID as
      6:15:11
      well. And I believe that's something I
      6:15:13
      should have done on my page for my
      6:15:15
      organization list. So I think that's in
      6:15:17
      my shared component, my job listing
      6:15:18
      items. If we scroll all the way down
      6:15:20
      here to the very bottom, when I get my
      6:15:22
      job listings, you can see that I'm
      6:15:24
      getting my organization information, but
      6:15:26
      I'm not actually caching based on that
      6:15:27
      information. So let's do that real
      6:15:29
      quick. We'll say const data is equal to
      6:15:31
      awaiting this and then we can return our
      6:15:34
      data down here. But we can add in some
      6:15:36
      additional caches. So we can say data
      6:15:38
      dot
      6:15:39
      for each listing.
      6:15:42
      And what we want to do is we want to run
      6:15:44
      some specific code to cache the listing.
      6:15:46
      So we can just do this code right here.
      6:15:51
      Organization ID.
      6:15:54
      Make sure I get the ID column from here.
      6:15:56
      There we go. So now I'm just making sure
      6:15:57
      I'm caching on that organization ID as
      6:15:59
      well inside of the section since I am
      6:16:01
      relying upon that organization data. So
      6:16:03
      now with that done, all of this code is
      6:16:05
      pretty much like we would expect it to
      6:16:06
      be. So now we have our job listing. Now
      6:16:08
      this entire top section of our job
      6:16:10
      listing details is identical to what we
      6:16:12
      had over here. These two are essentially
      6:16:14
      identical. So what I want to do is I
      6:16:16
      want to render out all the same stuff
      6:16:17
      that I had before. So you can see this
      6:16:19
      is all that same stuff. I'm just going
      6:16:20
      to close off my divs just like this. And
      6:16:22
      this is all the same content that I had
      6:16:24
      in the other section. So let's make sure
      6:16:25
      that I import all of these things. Just
      6:16:28
      like this, we have our job listing
      6:16:30
      organization. First, I should probably
      6:16:31
      check if our job listing
      6:16:34
      is equal to null.
      6:16:38
      Then we want to return not found. There
      6:16:40
      we go. Super straightforward. We get our
      6:16:42
      avatar fallback. Also, we should get our
      6:16:44
      name initials. Again, exactly the same
      6:16:46
      as what we had in the other section. So
      6:16:48
      there we go. We got those. And then all
      6:16:50
      the rest of our job listing information
      6:16:51
      is right there. And then finally, we
      6:16:53
      have our close button showing up here.
      6:16:54
      So, let's get our button import. Make
      6:16:56
      sure I get the right one. Import link.
      6:16:59
      And we're going to import for converting
      6:17:00
      our search params. Just like that. And
      6:17:02
      then finally, our X icon. There we go.
      6:17:05
      So, that hopefully should be everything.
      6:17:06
      You can see it essentially looks
      6:17:07
      identical. And we're on a much larger
      6:17:09
      screen size. You can see even larger. We
      6:17:11
      now have the ability to resize this. And
      6:17:13
      you can see things move around exactly
      6:17:15
      where they need to be based on whatever
      6:17:16
      screen size we're currently on and how
      6:17:18
      wide our different containers are. Now,
      6:17:20
      the next section directly after all of
      6:17:21
      our stuff that we have here, so we can
      6:17:23
      kind of minimize all of this down, is
      6:17:25
      going to be the buttons that we're going
      6:17:26
      to be rendering out. So, they're
      6:17:28
      actually going to be directly inside
      6:17:29
      inside of this section right here. We're
      6:17:30
      going to have our job listing badges.
      6:17:32
      So, we can come in here, job listing
      6:17:34
      badges, just like that. Again, exactly
      6:17:36
      the same as the previous section. You
      6:17:38
      can see we're listing out all of our
      6:17:39
      different badges. Then, after that,
      6:17:40
      we're going to add in a button for
      6:17:41
      applying. So, I'm just going to put the
      6:17:43
      text applied there so we can come back
      6:17:44
      to do this later. And then also, we need
      6:17:46
      to render out our markdown. So, we have
      6:17:48
      our markdown renderer and we know that
      6:17:51
      the source for this is going to be our
      6:17:52
      job listing.
      6:17:54
      And we can close that off. So, now it's
      6:17:56
      going to put whatever the description
      6:17:57
      for our job listing is right here. Right
      6:17:58
      now, we have a rather short one, but if
      6:18:00
      we were to clear out our search query,
      6:18:02
      just filter for anything. I think this
      6:18:03
      one maybe had a longer job listing.
      6:18:05
      Nope, it had the same size one. But
      6:18:06
      essentially, that's where our job
      6:18:07
      listing would go. So, now let's get our
    </chapter>
    <chapter title="Applying for job listings" start_time="6:18:08">
      6:18:09
      apply button in here. We can do a
      6:18:11
      suspense real quick with a fallback that
      6:18:13
      is just going to say
      6:18:16
      button
      6:18:18
      and we're going to have that be disabled
      6:18:19
      and it'll say apply just like that. And
      6:18:22
      then inside of here we want to render
      6:18:23
      out our apply button which is a
      6:18:25
      component that we're going to create.
      6:18:26
      We're going to pass in our job listing
      6:18:28
      ID. Joblisting do ID. There we go. So
      6:18:31
      let's create a component
      6:18:34
      apply button. This takes in our job
      6:18:37
      listing ID. And then what we want to do
      6:18:39
      is essentially do our popover kind of
      6:18:40
      like we did before for permissions. So
      6:18:42
      I'm going to kind of copy this over
      6:18:43
      because it's something that we've
      6:18:44
      already done before. Let's make this
      6:18:46
      asynchronous. We're going to create our
      6:18:48
      pop over just like that. Our popover
      6:18:50
      trigger, our popover content, our sign
      6:18:54
      up button, which we want to make sure we
      6:18:56
      import our own. And there we go. So
      6:18:57
      essentially, if we don't have an
      6:18:59
      account, we cannot apply for the job. As
      6:19:01
      you can see here, we're looking. If we
      6:19:03
      don't have an account, then we want to
      6:19:04
      render our popover that says, "Hey, you
      6:19:06
      don't have an account yet. you need to
      6:19:07
      create an account before you actually
      6:19:08
      apply for a job. We can test this by
      6:19:10
      really quickly coming over here. I can
      6:19:12
      do a quick log out and then we can come
      6:19:14
      over and we can click on a particular
      6:19:15
      job. And of course, I'm getting a thing
      6:19:18
      that says I need to redirect. And that's
      6:19:20
      because all the way down inside of our
      6:19:22
      middleware, if we open that up, we need
      6:19:24
      to make sure that we specify our job
      6:19:25
      listing page as public. So, we can say
      6:19:28
      slash job
      6:19:30
      listings
      6:19:32
      star or sorry, dotstar.
      6:19:34
      There we go. Now, that should be a
      6:19:36
      public page. So, now we can go to this
      6:19:37
      page. We can click on a job listing. And
      6:19:39
      of course, maybe I need to refresh my
      6:19:40
      page. Oh, of course, I should probably
      6:19:42
      spell job correctly. That should fix it.
      6:19:44
      Now, you can see I can click on this
      6:19:45
      apply button. And you can see I'm
      6:19:46
      getting an error. You pass multiple
      6:19:47
      children to the sign up button. So,
      6:19:49
      let's go ahead and fix that particular
      6:19:50
      problem. We're going to go back into our
      6:19:52
      app into the job listing page. We want
      6:19:54
      to get on the page itself. And it looks
      6:19:57
      like our sign up button had a problem
      6:19:59
      inside of it. I believe the problem is
      6:20:01
      this space right here. that is what's
      6:20:02
      causing the problem to have multiple
      6:20:04
      children being rendered. Now you can see
      6:20:05
      when I click apply, you need to create
      6:20:06
      an account before applying for a job.
      6:20:08
      Sign up and it's going to bring me over
      6:20:09
      to that page to sign up if I want or I
      6:20:11
      can just go ahead link with my GitHub
      6:20:12
      account like I had before. Going to take
      6:20:14
      a little while to redirect me and now
      6:20:15
      boom, it's back to here where hopefully
      6:20:17
      I can now render out a button to
      6:20:18
      actually apply. So before I can render
      6:20:20
      the button, I first need to figure out
      6:20:21
      if I've already applied for the job or
      6:20:22
      not. So we're going to create an async
      6:20:24
      function called get job listing
      6:20:27
      application. This is going to take in a
      6:20:29
      job listing ID and a user ID. So we have
      6:20:34
      our job listing ID
      6:20:37
      and our user ID just like that.
      6:20:41
      And now what I want to do is I just want
      6:20:43
      to run a function to be able to get that
      6:20:45
      information. So return db.query
      6:20:48
      on our job listing application table. I
      6:20:50
      want to find the first one that meets
      6:20:51
      both of that criteria. So I'll just copy
      6:20:53
      over the and clause that we have for our
      6:20:55
      wearer here. There we go. So where my
      6:20:57
      job listing ID is equal to the ID and my
      6:20:59
      user ID is equal to the user ID. Rather
      6:21:02
      straightforward. We can also make sure
      6:21:04
      that we cache this information and we
      6:21:06
      can add in here a cache tag which is get
      6:21:08
      job listing application ID tag. There we
      6:21:12
      go. And we can pass in the job listing
      6:21:14
      ID and the user ID just like that. And
      6:21:17
      now we have this information cached and
      6:21:19
      we can use it in our application. So
      6:21:20
      let's scroll back up to our apply
      6:21:22
      button. If we don't have if we do have a
      6:21:23
      user then what I want to do is I want to
      6:21:25
      get the application.
      6:21:27
      So we can call await by getting my
      6:21:29
      application passing it in my job listing
      6:21:31
      ID and my user ID and then we can say if
      6:21:34
      our application
      6:21:35
      is not equal to null then we've already
      6:21:37
      applied. So we should just let the user
      6:21:39
      know hey you've already applied. So I
      6:21:40
      can say const formatter equals new
      6:21:42
      intl.relative
      6:21:46
      whoops inl.relative
      6:21:48
      time format undefined. We want this to
      6:21:51
      be a style which is going to be short
      6:21:56
      and we want it to have a numeric of
      6:21:59
      always.
      6:22:02
      There we go. And then what I want to do
      6:22:04
      is I want to get my difference in days.
      6:22:05
      So we'll say the difference is the
      6:22:07
      difference in days
      6:22:09
      application.created at so that's the day
      6:22:12
      I applied for the job and new date. So
      6:22:15
      again we need to make sure that we await
      6:22:17
      connection before this. Whoops.
      6:22:19
      connection.
      6:22:21
      There we go. Because we're doing
      6:22:22
      something that's dynamic that Nex.js
      6:22:24
      needs to know about. And then finally,
      6:22:26
      we can return here essentially our code
      6:22:28
      that is going to render this out. So a
      6:22:29
      class name that says text muted
      6:22:31
      foreground text small
      6:22:34
      you applied for this job. And then we
      6:22:37
      can put whatever our difference is going
      6:22:39
      to be. So difference is equal to zero.
      6:22:41
      We'll just say today otherwise we'll put
      6:22:44
      whatever that difference is formatted.
      6:22:45
      So, we'll say formatter,
      6:22:49
      whoops, formatter.format
      6:22:52
      our difference, and we want to format
      6:22:54
      that as days. There we go. So, now it's
      6:22:56
      going to say you applied however many
      6:22:58
      days ago if we already applied. But in
      6:23:00
      our case, we've not applied for this
      6:23:01
      job. So, this does not apply to us. So,
      6:23:03
      we can move on to the next section where
      6:23:04
      we can actually add the button. But
      6:23:06
      first, we need to check to make sure we
      6:23:07
      have a resume because we can't apply for
      6:23:09
      a job without a resume. So, we want to
      6:23:11
      get our user resume,
      6:23:13
      and that's going to be calling get user
      6:23:16
      resume, which is a function we'll pass a
      6:23:18
      user ID into. So, let's just copy one of
      6:23:20
      these functions because it's going to be
      6:23:21
      pretty much identical. Get user resume.
      6:23:23
      This is going to take in a user ID as
      6:23:25
      the only property.
      6:23:28
      There we go. It's going to be caching
      6:23:30
      this on get user resume
      6:23:34
      ID tag. And that ID is just the user ID
      6:23:37
      because that is the primary key for the
      6:23:39
      ré table. User ré table. And we don't
      6:23:42
      even need an and query here. It's just
      6:23:44
      going to be a simple check on the ID
      6:23:46
      field for our user ré table. There we
      6:23:50
      go. So if that ID is equal to our user
      6:23:52
      ID, we are good to go. And I believe
      6:23:53
      this is just user ID. There we go. Now
      6:23:55
      we do need to add caching for this
      6:23:56
      section. So I'm going to go down into my
      6:23:58
      features folder in the user section
      6:24:00
      inside a database inside a cache. I'm
      6:24:02
      going to paste in our file for this
      6:24:03
      which is user rums. Very
      6:24:05
      straightforward. Same as everything
      6:24:06
      we've done before. We have a global tag,
      6:24:07
      we have an ID tag, and we revalidate
      6:24:09
      both of them down here. So, let's make
      6:24:11
      sure that we import this function. And
      6:24:13
      now we actually have the ability to get
      6:24:14
      the user resume to make sure they have a
      6:24:16
      resume. So, the next check is going to
      6:24:17
      look very similar to the one up here.
      6:24:19
      We're going to check to see if they have
      6:24:20
      a user resume. So, if their user resume
      6:24:22
      is equal to null, then what we want to
      6:24:23
      do is we want to essentially tell them
      6:24:25
      you need a resume. You need to upload
      6:24:28
      your resume before
      6:24:31
      applying for a job.
      6:24:34
      Then what we want to do is we want to
      6:24:35
      render out a button as child because
      6:24:37
      this is going to be a link and this link
      6:24:39
      is going to go to the page for rendering
      6:24:41
      or for uploading a resume which is user
      6:24:43
      settings/resume
      6:24:46
      upload resume.
      6:24:48
      There we go. So now we should actually
      6:24:49
      see the apply button and we can see that
      6:24:51
      we don't have a resume and this will
      6:24:52
      redirect us to the page even though it
      6:24:54
      doesn't exist yet. Now before we jump
      6:24:56
      over to work on that page, I still want
      6:24:57
      to actually finish out what the
      6:24:58
      application section is going to look
      6:25:00
      like just so we have this page entirely
      6:25:02
      done before we move on. So now we know
      6:25:04
      that we can essentially create an
      6:25:06
      application. So here I want to render a
      6:25:08
      dialogue component that allows us to
      6:25:10
      finish off what our application looks
      6:25:12
      like. So we're going to have our
      6:25:13
      dialogue trigger. This is going to be a
      6:25:15
      button.
      6:25:18
      And this button is just going to say
      6:25:20
      apply just like all the other buttons
      6:25:21
      we've been working with. Our dialogue
      6:25:23
      content. We want to make sure that this
      6:25:24
      is a large scale dialogue. So we're
      6:25:27
      going to add some class names. Medium
      6:25:28
      max width is 3XL. We want to have our
      6:25:31
      max H be a calculation
      6:25:34
      of 100% minus 2mm.
      6:25:38
      And then we want our overflow to be
      6:25:39
      hidden. And finally, flex with a flex
      6:25:42
      column. There we go. Now we can go ahead
      6:25:45
      and we can add in our dialogue header.
      6:25:48
      The dialogue header is going to have a
      6:25:49
      dialogue title.
      6:25:51
      That's just going to say application.
      6:25:53
      Then we're going to have a description.
      6:25:58
      There we go. This is going to say
      6:25:59
      applying
      6:26:01
      for a job cannot be undone and is
      6:26:05
      something you can only do once per job
      6:26:09
      listing just so they know not to try to
      6:26:12
      do this multiple times and once they do
      6:26:13
      it they are done. It's kind of a warning
      6:26:15
      for them. Then we're going to have our
      6:26:16
      div that fills the full screen size.
      6:26:18
      Flex one overflow of Y of auto so it
      6:26:21
      scrolls properly. And this is where
      6:26:23
      we're going to put essentially our form
      6:26:25
      for doing this. New job listing
      6:26:27
      application form. We're going to pass in
      6:26:30
      our job listing ID, which is just job
      6:26:32
      listing ID. Now, let's go ahead and work
      6:26:34
      on creating this form. So, we're going
      6:26:36
      to come over here into our component
      6:26:38
      section for our job listing component.
      6:26:40
      We're going to create a brand new file,
      6:26:41
      and we're making that form. So, export
      6:26:43
      function with that name, just like that.
      6:26:46
      And it's going to be taking in our job
      6:26:48
      listing ID.
      6:26:51
      job listing ID, which is a string. There
      6:26:54
      we go. And we essentially want to do the
      6:26:56
      same thing we've done in all of our
      6:26:57
      different forms. So, we're going to get
      6:26:58
      a form, which is use form.
      6:27:02
      There we go. We want to make sure we
      6:27:03
      pass in our resolver,
      6:27:06
      which is a ZOD resolver, which is going
      6:27:08
      to be our new job listing
      6:27:12
      application form. Just like that. And
      6:27:14
      make sure that this is actually a schema
      6:27:16
      application schema. There we go.
      6:27:19
      And our default values for this is just
      6:27:21
      going to be cover letter of an empty
      6:27:23
      string because that's the only thing
      6:27:24
      that we can actually define for this
      6:27:26
      schema. So let's go ahead and create
      6:27:27
      this schema directly inside of here. We
      6:27:29
      can kind of minimize these down. Move
      6:27:31
      all the way down here. Export consting
      6:27:35
      application
      6:27:36
      schema
      6:27:39
      that is equal to Z.Object.
      6:27:42
      Cover letter is the only property in
      6:27:43
      here which is a string that is nullable.
      6:27:47
      And we want to transform our string.
      6:27:49
      Essentially converting all of our
      6:27:50
      values,
      6:27:52
      trimming it just like that. If it's
      6:27:54
      equal to an empty string, we return
      6:27:56
      null.
      6:27:59
      There we go.
      6:28:03
      Otherwise, we return our value. And I
      6:28:05
      believe if I put nullable after here,
      6:28:07
      that'll make sure that this is not
      6:28:08
      nullable there. And there we go. Now,
      6:28:10
      essentially, that's exactly what we
      6:28:11
      want. Make sure I spell application
      6:28:12
      properly.
      6:28:15
      And now we can hopefully import this
      6:28:17
      directly in here. Looks like I spelled
      6:28:19
      it incorrectly. New job listing
      6:28:21
      application schema. And over here, there
      6:28:25
      we go. Hopefully those are spelled
      6:28:27
      correctly. Now, now the next thing we
      6:28:29
      can do is we can return our form. I'm
      6:28:30
      going to copy this in because it's very
      6:28:32
      similar to all the forms that we've
      6:28:33
      already worked on before. So, we can
      6:28:35
      come in here with our form field. Going
      6:28:37
      to make sure we import everything first
      6:28:38
      and then I'll explain exactly what's
      6:28:39
      going on inside of all the code. get our
      6:28:42
      description, our message, and then
      6:28:45
      finally our button down here with that
      6:28:46
      loading swap text. So, all we're doing
      6:28:49
      inside this form is we just have this
      6:28:50
      form item, which is going to be a cover
      6:28:53
      letter. And this is rendering out our
      6:28:54
      markdown editor. The exact same thing we
      6:28:56
      used for our job listing description.
      6:28:58
      We're now using it in this dialogue for
      6:28:59
      this specific form. Now, we need our
      6:29:02
      onsubmit function. This function is
      6:29:04
      going to be taking in all of our
      6:29:05
      different data, which is going to be
      6:29:07
      inferred from ZOD. Just like that.
      6:29:08
      That's our new listing schema. We want
      6:29:11
      to get our results which is calling
      6:29:12
      await create job listing application.
      6:29:16
      It's a function we're going to create
      6:29:17
      where we pass in our job listing ID as
      6:29:20
      well as the data for this application we
      6:29:22
      want to create. Let's make sure this is
      6:29:24
      an asynchronous function. And then what
      6:29:26
      we can do is if our result
      6:29:29
      error
      6:29:31
      there we go.
      6:29:34
      And then what we're going to do is just
      6:29:36
      render out a simple toast message. So
      6:29:37
      we'll just say toast.
      6:29:39
      And this will just be our results
      6:29:41
      dossage. Just like that. And otherwise
      6:29:44
      we're going to render out toast.uccess.
      6:29:47
      And that's our results message. There we
      6:29:49
      go. And we'll make sure that we return
      6:29:50
      after this. So we only render one of
      6:29:52
      these two different toast messages. So
      6:29:54
      now let's create this job listing
      6:29:56
      application function. So what we can do
      6:29:58
      is we can go into our actions
      6:30:00
      specifically for our job listing
      6:30:02
      applications. So we can come into our
      6:30:03
      job listing applications and this form
      6:30:05
      should also be inside of here. So, let's
      6:30:07
      create a folder inside of here called
      6:30:08
      components. Just like that. Move this
      6:30:11
      form into here because that's really
      6:30:12
      where this form should be living. And
      6:30:14
      make sure that's right there. And then
      6:30:15
      inside of our DB, we're going to create
      6:30:17
      a brand new file called joblisting
      6:30:21
      applications.ts.
      6:30:23
      And this is where we're going to create
      6:30:24
      this function.
      6:30:28
      And this is going to be an action. So,
      6:30:29
      it's going to be a use server at the
      6:30:31
      top. And this needs to be asynchronous.
      6:30:33
      So this action is going to take in our
      6:30:35
      schema as well as our job listing ID. So
      6:30:37
      let's make sure that we import those
      6:30:38
      particular properties. Then what I want
      6:30:40
      to do is I want to check to see if I
      6:30:42
      have a user and everything like that. So
      6:30:43
      we can come in here with our
      6:30:44
      permissions. Say you don't have
      6:30:46
      permission to submit an application. So
      6:30:47
      if we don't have a user account,
      6:30:49
      obviously we have a permission error.
      6:30:51
      Next, I want to get my user resume as
      6:30:53
      well as my job listing because I'm going
      6:30:55
      to use both of those to check to make
      6:30:56
      sure we have permission. promise.all all
      6:30:59
      and I'm going to return get user resume
      6:31:04
      just like that which is going to take
      6:31:05
      our user ID and then we're going to get
      6:31:07
      a public job listing which is going to
      6:31:10
      take in our job listing ID. There we go.
      6:31:13
      And these are functions that we're going
      6:31:14
      to create but essentially they're the
      6:31:15
      same as functions we've already created.
      6:31:16
      So to save you the time of me typing out
      6:31:18
      this code that we've already done a
      6:31:19
      million times, I'm going to paste in the
      6:31:21
      particular code. And again, you can see
      6:31:22
      we're just querying the database
      6:31:24
      specifically for public job listings
      6:31:26
      that match our ID. as well as when we go
      6:31:28
      down below to the next level for our
      6:31:30
      résumés, we're specifically querying our
      6:31:32
      table for résumés that match this
      6:31:34
      particular ID. And we're only returning
      6:31:36
      the IDs of the actual column. So the
      6:31:38
      user ID and the ID here because that's
      6:31:39
      all we care about. We just want to see
      6:31:40
      if these things exist or not. So then we
      6:31:42
      can check to see if either of these are
      6:31:44
      null. So if the user resume is equal to
      6:31:46
      null
      6:31:47
      or the job listing is equal to null,
      6:31:49
      that means you're trying to apply to a
      6:31:50
      job you don't have access to or you're
      6:31:52
      just essentially applying without a
      6:31:53
      resume. So we return that same exact
      6:31:55
      error. So then we can move down to the
      6:31:57
      next check we want to make and this is
      6:31:59
      going to be to make sure our application
      6:32:00
      data is successful. So we have our
      6:32:02
      success and our data which comes from
      6:32:04
      new job listing application schemas safe
      6:32:07
      parse and we want to parse that unsafe
      6:32:09
      data. There we go. Then we can say if we
      6:32:12
      are not successful then we're going to
      6:32:13
      return essentially an error. I'm going
      6:32:15
      to copy over the error message.
      6:32:16
      Essentially just says there is an error
      6:32:18
      submitting your application. Finally if
      6:32:20
      everything is successful we can finally
      6:32:21
      actually work on inserting this. So we
      6:32:23
      can say insert job listing application
      6:32:26
      and we can pass along our job listing
      6:32:28
      ID, our user ID, and then all of our
      6:32:31
      different data, which in our case is
      6:32:32
      just the cover letter. So now let's go
      6:32:34
      ahead and actually make this database
      6:32:35
      function. And it looks like I put this
      6:32:36
      in the wrong folder. So let me come in
      6:32:38
      here. We'll create our actions. There we
      6:32:40
      go. And action should be a folder, not a
      6:32:42
      file. There we go. So inside of here,
      6:32:45
      actions. I should move this up into my
      6:32:47
      actions. And then here, joblisting
      6:32:51
      applications.ts. ts. And there we go.
      6:32:54
      Also, I have my schema in the wrong
      6:32:56
      location. This should be in a file all
      6:32:58
      the way up here. Schemas.ts.
      6:33:03
      There we go. And I'll rename this to
      6:33:04
      actions. There we go. So, now we
      6:33:06
      hopefully have everything working fine.
      6:33:08
      Let me just make sure I get my imports
      6:33:09
      proper. That works fine there. And this
      6:33:12
      one, it looks like we just have some
      6:33:13
      errors because my imports aren't lining
      6:33:14
      up properly. That's imported from the
      6:33:16
      wrong location cuz I just moved it.
      6:33:18
      There we go. That should clean up all
      6:33:20
      this. Now all we need to do is create
      6:33:21
      this particular function in our database
      6:33:23
      folder right here. Export async function
      6:33:27
      and we want to insert that user. Now
      6:33:29
      doing this particular insert is actually
      6:33:30
      not too tricky. I'll import this code
      6:33:33
      and again explain exactly what's going
      6:33:34
      on in it. So if we take a look at the
      6:33:36
      code here, we're taking in our
      6:33:37
      application information. We're inserting
      6:33:39
      it into the table, passing along all the
      6:33:40
      values. And if for some reason we have a
      6:33:42
      conflict, I just want to do nothing at
      6:33:43
      all, not throw an error. If we happen to
      6:33:46
      have a conflict, it just means we're
      6:33:47
      trying to apply for a job multiple
      6:33:48
      times. Not sure why that would happen,
      6:33:50
      but essentially we're just going to
      6:33:51
      ignore that. And actually, we can remove
      6:33:52
      that. We can just throw an error if
      6:33:54
      we're trying to apply for the same job
      6:33:55
      multiple times because that's definitely
      6:33:56
      not something that we want to do. So now
      6:33:58
      we hopefully have everything set up like
      6:34:00
      we wanted to inside of here. We can
      6:34:01
      import this action. And now we
      6:34:03
      successfully created a job here or an
      6:34:04
      application, I mean. So now what we're
      6:34:06
      going to do is we're going to return
      6:34:07
      that message. So we can return error
      6:34:10
      false and message
      6:34:14
      your application was successfully
      6:34:21
      man I cannot type today submitted. There
      6:34:23
      we go. And before we do that though I'm
      6:34:25
      going to mark a little to-do here. What
      6:34:27
      we want to do is we actually want to be
      6:34:28
      able to AI generate a rating for the
      6:34:30
      user. So we'll say AI generation. And to
      6:34:33
      do that we're going to be using ingest.
      6:34:34
      So we're going to say await ingest.end.
      6:34:37
      I'm going to be sending along an event
      6:34:39
      to ingest. So, let me make sure I import
      6:34:40
      this. There we go. And I want to send
      6:34:42
      along an event with a specific name.
      6:34:44
      We'll call this app slash joblisting
      6:34:48
      application.created.
      6:34:51
      So, that's the event name. And we'll
      6:34:53
      give it all the data that we need, which
      6:34:54
      is just our job listing ID and our user
      6:34:57
      ID. Now, in order to make this work, we
      6:34:59
      need to go into ingest and specify this
      6:35:01
      new event. So here we can say that's our
      6:35:04
      event name and we have data and that
      6:35:06
      data is a job listing ID which is a
      6:35:08
      string and a user ID which is a string.
      6:35:12
      Now if we give that a quick save and we
      6:35:13
      go back over to our action, you can see
      6:35:15
      that this is working. We just need to
      6:35:16
      obviously implement the ingest function
      6:35:17
      for that which we'll do a bit later. For
      6:35:19
      now though, I want to test to see if
      6:35:21
      applying for job actually works. So I'm
      6:35:23
      going to do two really quick things. The
      6:35:24
      first thing I'm going to do is I'm going
      6:35:25
      to disable the need for a resume. So,
      6:35:27
      I'm just going to essentially remove
      6:35:29
      this line of code because now we don't
      6:35:30
      need a resume to apply. I'm going to go
      6:35:32
      back into my page in particular where
      6:35:34
      I'm using this. First of all, let's get
      6:35:36
      our form imported there. That works
      6:35:37
      fine. And I'm going to come up here and
      6:35:39
      I'm just going to comment out this
      6:35:40
      particular code as well. So, now let's
      6:35:42
      see if we just save everything. Looks
      6:35:44
      like this needs to be imported. And that
      6:35:46
      should hopefully be everything we need.
      6:35:48
      Looks like I still have an error inside
      6:35:49
      of this file. My control is not working
      6:35:51
      properly for my form. Let's see if I
      6:35:54
      called that cover. Oh, I just called it
      6:35:56
      cover potentially. No, it should be
      6:35:57
      cover letter, that's for sure. I think I
      6:35:59
      just have something being imported from
      6:36:01
      the wrong location. There we go. Need to
      6:36:03
      make sure that I update the import right
      6:36:04
      here. Now, that should hopefully fix all
      6:36:06
      the different errors we had. Give that a
      6:36:08
      refresh and my page should render. Looks
      6:36:09
      like my page is not working cuz this
      6:36:11
      should be a client component.
      6:36:13
      There we go. Now, if we give that a
      6:36:15
      save, you can see everything's
      6:36:16
      rendering. And when I click apply, it's
      6:36:18
      got a little bit of a problem going on.
      6:36:19
      Now, the reason for this is, as you can
      6:36:20
      see, we imported our button from the
      6:36:22
      wrong location. So, let's come down here
      6:36:23
      and make sure that we import the button
      6:36:25
      from the correct location. Now,
      6:36:27
      hopefully that'll remove all of our
      6:36:28
      errors. We click apply. You can see
      6:36:30
      apply for a job cannot be undone. Blah
      6:36:31
      blah blah blah blah. Import anything I
      6:36:33
      want from my cover letter. We can click
      6:36:35
      apply and hopefully that works. Your
      6:36:36
      application was submitted successfully.
      6:36:38
      And let's actually see if that worked.
      6:36:39
      We'll come over to our actual database
      6:36:41
      and we'll check to see if we have an
      6:36:42
      application. So, we can go to our job
      6:36:43
      listing applications and it does look
      6:36:45
      like we have an application with that
      6:36:46
      cover letter information passed inside
      6:36:48
      of it. So, at least we know that this
      6:36:49
      job application is working and
      6:36:51
      successfully submitting all of its
      6:36:53
      information. I do want to go through and
      6:36:55
      un essentially remove that stuff that we
      6:36:57
      removed. So, inside of our actions, I
      6:36:59
      want to make sure that we're checking
      6:37:00
      for our user resume here. And on the
      6:37:02
      actual page itself, let's go back to
      6:37:04
      that page. I want to make sure here
      6:37:05
      again, I'm checking for the user resume.
      6:37:07
      So, now if I were to try to apply for a
      6:37:08
      job, we can come into here. You can see
      6:37:10
      if I try to click apply, I need to
      6:37:11
      upload my resume. And for this
      6:37:13
      particular job, you can see you applied
      6:37:14
      for this job today. So, it knows that I
      6:37:15
      applied. Now, the next logical step is
    </chapter>
    <chapter title="User resume upload" start_time="6:37:16">
      6:37:17
      going to be moving to make it so that we
      6:37:19
      can upload an actual resume. And the
      6:37:20
      really nice thing about this is it's
      6:37:21
      going to allow us to do a lot of our AI
      6:37:23
      stuff as well. So, we're going to go
      6:37:24
      into our jobseker folder here, and I
      6:37:27
      want to add a new folder for user
      6:37:28
      settings. And inside that, I want to add
      6:37:30
      a folder for ré because we're going to
      6:37:32
      have two different settings. We're going
      6:37:33
      to have notification settings and ré
      6:37:35
      settings. So, in here, we're going to
      6:37:36
      create a folder for ré and then we're
      6:37:38
      going to create our page.tsx that we're
      6:37:40
      going to render inside of here. So,
      6:37:41
      let's export that function.
      6:37:44
      This is going to be our user resumeé
      6:37:46
      page.
      6:37:48
      There we go. And this is going to be a
      6:37:50
      relatively simple page all things
      6:37:52
      considered because we don't really have
      6:37:53
      much going on in here other than a
      6:37:55
      resume that you upload. And then we're
      6:37:56
      going to do all the AI stuff in the
      6:37:57
      background behind the scenes. So we can
      6:37:59
      do a quick return here. I want to render
      6:38:01
      out a div. This div is going to be kind
      6:38:03
      of small. I don't want it to be super
      6:38:04
      wide. So we'll do a max width of 3xl.
      6:38:06
      We're going to center it with mx auto.
      6:38:08
      add some space, some spacing on the top
      6:38:11
      and bottom as well as spacing out the
      6:38:13
      different content inside of here because
      6:38:14
      essentially we're going to have
      6:38:15
      different sections inside of this div.
      6:38:17
      We're essentially going to have a
      6:38:18
      section for uploading our resume, a
      6:38:20
      section for actually viewing our resume,
      6:38:21
      and a section for other things as well.
      6:38:23
      So, let's come in here with a little
      6:38:24
      title. We'll just say the title is going
      6:38:26
      to be upload your resume.
      6:38:30
      There we go. And then we'll add some
      6:38:31
      classes to make the text on that a
      6:38:33
      little bit larger.
      6:38:34
      So, we'll say text 2XL
      6:38:38
      and font bold. Now, before we get too
      6:38:41
      much further, I want to make sure that
      6:38:42
      our page is rendering. So, we can go
      6:38:43
      over to here, click on settings, and we
      6:38:45
      should hopefully be brought to that
      6:38:46
      settings page. And it looks like we're
      6:38:47
      brought to the notification section,
      6:38:49
      which is fine. That's kind of the
      6:38:50
      default place you want to go. We'll come
      6:38:51
      over here and just change this to resume
      6:38:53
      for now. So, at least we have something
      6:38:54
      popping up. But you'll notice we get a
      6:38:55
      404 error. The main reason for that is
      6:38:57
      because in my sidebar section, I don't
      6:38:59
      have anything for user settings. So, I'm
      6:39:01
      going to create a user settings /resume
      6:39:04
      folder. And inside of this, I'm just
      6:39:05
      going to create a page.tsx
      6:39:08
      export a function. Make sure it's the
      6:39:10
      default function. This will just say
      6:39:13
      user ré
      6:39:15
      sidebar. Doesn't really matter what we
      6:39:17
      call this. And in here, I'm going to
      6:39:18
      return a shared component, which I'm
      6:39:20
      going to call user settings
      6:39:22
      sidebar. And that's because I'm going to
      6:39:24
      share this sidebar between all my user
      6:39:26
      setting pages. So, let me make sure I
      6:39:27
      render that as a component. There we go.
      6:39:29
      And then I just need to create that
      6:39:30
      component which we'll do in that shared
      6:39:31
      folder we've already created up here.tsx
      6:39:35
      export that function just like that. And
      6:39:37
      inside here I essentially just wanted to
      6:39:39
      return a sidebar nav menu group that
      6:39:41
      custom component that we've created. And
      6:39:43
      we'll pass in the items for all the
      6:39:44
      things that we can render which is
      6:39:46
      really just two things. We're going to
      6:39:47
      have an href for our actual page. So let
      6:39:49
      me make sure we get that in there. Href.
      6:39:51
      This is going to be for/ user settings
      6:39:54
      slash notifications. So this is our
      6:39:57
      notification settings. And let me get
      6:39:58
      this so it formats properly. There we
      6:40:00
      go. Next section I need is an icon for
      6:40:02
      this. We're going to use a bell icon,
      6:40:04
      which is pretty normal for
      6:40:05
      notifications. And finally, we're going
      6:40:07
      to put in a label, which will be the
      6:40:08
      text that will just say notifications.
      6:40:10
      There we go. Now, I'm going to copy that
      6:40:12
      down to have our resume section as well.
      6:40:14
      So, we're going to have a file user icon
      6:40:17
      as well as resume here and resume here.
      6:40:21
      So, now if I make sure I import that
      6:40:22
      properly, we should see that in our
      6:40:23
      sidebar, we at least have those sections
      6:40:25
      in it. So, let me just give this a quick
      6:40:26
      refresh real quick. There we go. You can
      6:40:28
      see we have our H1 showing up. And over
      6:40:30
      here, you can see over in my sidebar, we
      6:40:32
      have notifications and resume. So, at
      6:40:33
      least those are both showing up. And
      6:40:35
      while I'm at it, I'm going to come over
      6:40:36
      here, copy this resume folder, and
      6:40:38
      change it to notifications.
      6:40:42
      There we go. Just so we have our page
      6:40:44
      for notifications already set up. So,
      6:40:45
      that way when we swap to that page,
      6:40:46
      it'll work just fine. Now, going back to
      6:40:48
      the page that we were actually working
      6:40:49
      on by just minimizing this down and
      6:40:51
      closing out of this as well, you can see
      6:40:53
      here we are. I want to add a little bit
      6:40:54
      of spacing on the left and right. So,
      6:40:55
      we're going to come in here with a
      6:40:56
      simple px of four just to give us some
      6:40:58
      spacing on our page. That looks really
      6:41:00
      good. And if we're on larger screen
      6:41:01
      sizes, you can see it's just going to
      6:41:02
      center itself even when our sidebar is
      6:41:04
      closed. So, that looks really good. Now,
      6:41:05
      what we can do is we can actually work
      6:41:07
      on putting the content inside of here.
      6:41:08
      And we're going to be using a card for
      6:41:09
      styling everything with a card content.
      6:41:12
      And inside this card content is where
      6:41:14
      we're going to put our drop zone.
      6:41:15
      Essentially, we'll just put the text for
      6:41:16
      now of drop zone. Just like that. And
      6:41:18
      that's essentially going to be where we
      6:41:19
      drag and drop our file to upload it.
      6:41:21
      Also, I'm going to create some suspense
      6:41:23
      sections. And one of these is going to
      6:41:24
      be for rendering out our resume details.
      6:41:27
      This is going to be essentially the
      6:41:28
      button to view more about our resume.
      6:41:30
      And that is going to be inside of our
      6:41:32
      card as well. So, let me make sure I get
      6:41:33
      that up into there. There we go. And
      6:41:36
      then the next thing that I want to do is
      6:41:37
      I want to render out below our card
      6:41:39
      suspense container.
      6:41:42
      And this one's going to be for the AI
      6:41:43
      summary
      6:41:45
      card. Just like that. And this is
      6:41:46
      essentially going to be where we render
      6:41:48
      out whatever the AI generates for our
      6:41:50
      particular resume. So, let's come in
      6:41:51
      here. Here we'll create an async
      6:41:53
      function.
      6:41:54
      Resume details
      6:41:56
      return null. And I want to do the exact
      6:41:58
      same thing for our AI summary just so we
      6:42:00
      at least have placeholders for those for
      6:42:01
      now. So if we give that a quick save,
      6:42:03
      really nothing changed because these
      6:42:04
      don't actually render out anything. Now
      6:42:05
      in order to manage file uploads in this
      6:42:07
      system, we're going to be using upload
      6:42:08
      thing which actually works really well
      6:42:09
      with Nex.js. It's the first time I've
      6:42:10
      tried it and I I quite liked it. So in
      6:42:12
      order to get through the steps here, we
      6:42:13
      can just copy over our install script.
      6:42:15
      Paste that down. It's going to be rather
      6:42:16
      straightforward. And then we need to get
      6:42:17
      our upload thing token. So, we can just
      6:42:19
      make sure we put that inside of our
      6:42:20
      environment variables. So, we can scroll
      6:42:22
      all the way down to our environment
      6:42:23
      variables. Create a section for upload
      6:42:26
      thing.
      6:42:29
      There we go. And we can say that our
      6:42:30
      upload thing token is whatever we're
      6:42:32
      going to get from our dashboard. So,
      6:42:33
      we'll get that in just a little bit. And
      6:42:34
      then we can work on setting up
      6:42:35
      essentially our file router. And the
      6:42:37
      router is essentially the thing that
      6:42:38
      allows you to actually hook up all the
      6:42:40
      different routes that you have for
      6:42:41
      uploading files. Essentially, you can
      6:42:42
      think about it as like an express
      6:42:43
      background that manages everything for
      6:42:45
      you. Also, we should make sure we force
      6:42:47
      install these dependencies so they
      6:42:48
      actually come through. So, I'm just
      6:42:49
      going to copy this router over and we'll
      6:42:51
      make the changes we need because a lot
      6:42:52
      of it is kind of what we already want.
      6:42:54
      So, we'll say that we have an upload
      6:42:55
      thing folder. And inside of here, we're
      6:42:57
      going to create our simple router. And
      6:42:58
      our router is rather simple. So, we're
      6:42:59
      just going to put it in a single file
      6:43:01
      like this. So, let's scroll all the way
      6:43:02
      to top and kind of go through this line
      6:43:03
      by line. The very first thing we're
      6:43:04
      doing up here is we're just creating the
      6:43:06
      function that we use. Now, they have a
      6:43:07
      fake authentication. We'll remove that
      6:43:09
      cuz we don't actually need that. We'll
      6:43:10
      use our own authentication. I'm going to
      6:43:12
      call this a custom file router just
      6:43:14
      because I like the name custom better.
      6:43:15
      Now, here we're going to be using a ré
      6:43:17
      uploader. So, we'll call this a ré
      6:43:19
      uploader. And the nice thing is you just
      6:43:20
      essentially define keys for all the
      6:43:22
      different things that you want to do.
      6:43:23
      So, our first key, ré uploader, is for
      6:43:24
      uploading a PDF file. So, we'll put in
      6:43:27
      PDF here. And then we can specify that
      6:43:29
      we want the maximum size to be 8
      6:43:30
      megabytes. And I'm also going to put in
      6:43:32
      here a keyword which is a weight server
      6:43:34
      data. Essentially, what this does is on
      6:43:36
      the client, we have the ability to
      6:43:38
      listen to like a success event. And this
      6:43:40
      is just saying, hey, I want to make sure
      6:43:41
      that you wait until the server has said
      6:43:43
      that we are successfully done before we
      6:43:45
      go ahead and we submit the actual
      6:43:47
      success status from our page. Let me get
      6:43:50
      a comma here. So really what happens
      6:43:52
      down here, we have this on upload
      6:43:53
      complete. Normally without this, it'll
      6:43:56
      just send down to the client that things
      6:43:57
      were successful before this actually
      6:43:59
      finishes. We want to make sure this
      6:44:00
      finishes because this is where we upload
      6:44:02
      our actual file to the server. And then
      6:44:03
      that way after we get sent back down to
      6:44:05
      the client, we can refresh the page so
      6:44:07
      they can view all their resume
      6:44:08
      information. Now we can get rid of a lot
      6:44:10
      of these comments because we don't
      6:44:11
      really need them. And now we can move on
      6:44:12
      to middleware which is all about
      6:44:13
      handling permissions. So we can just get
      6:44:15
      our user ID from that get current user
      6:44:18
      function. So we can say get current user
      6:44:21
      just like that. Make sure that we await
      6:44:23
      this. There we go. We don't even need
      6:44:25
      this request because it's kind of
      6:44:26
      already handled for us inside this
      6:44:27
      function. This gives us our user ID. And
      6:44:30
      if user ID is equal to null, we can just
      6:44:32
      throw a specific error. So we'll say
      6:44:34
      throw new upload thing error. And we can
      6:44:37
      just say unauthorized.
      6:44:39
      There we go. That's essentially what
      6:44:40
      they're doing right down here. We just
      6:44:42
      did it up here for our particular code.
      6:44:43
      Then what we can do is we can turn the
      6:44:45
      user ID information so we can use it in
      6:44:47
      other places. For example, when we
      6:44:48
      upload our file. So here now essentially
      6:44:50
      we just got the user ID, made sure it's
      6:44:51
      there, and then used it or returned it.
      6:44:53
      So we can use it down here inside this
      6:44:54
      metadata section. Now inside this upload
      6:44:56
      complete, the first thing I want to do
      6:44:57
      is I want to get my user ID from that
      6:44:59
      metadata just like this. And the next
      6:45:02
      thing is we have type safety. You can
      6:45:03
      see all of this is type safe, which is
      6:45:04
      really nice. And then the next thing we
      6:45:06
      can do is we can actually do whatever we
      6:45:07
      want with our particular code. So in my
      6:45:09
      case, I want to actually get the résé
      6:45:11
      file key for the existing résé. We'll
      6:45:13
      just put a little to-do to delete old ré
      6:45:16
      cuz we'll do that in a little bit. But
      6:45:17
      the next step is to actually upload the
      6:45:18
      new ré. So we'll say upsert user ré. And
      6:45:23
      we're going to pass in the user ID for
      6:45:24
      what we want to upload to as well as we
      6:45:26
      want to pass in the ré file URL which is
      6:45:30
      the file dot. And then we have this URL
      6:45:32
      option right here. And then finally we
      6:45:34
      have the résé file key which we can get
      6:45:37
      from here as well as the key. Now this
      6:45:39
      key you can think about as like a unique
      6:45:41
      identifier. So an upload thing this is
      6:45:42
      like the ID of the resume in upload
      6:45:44
      thing and the URL is just the public URL
      6:45:46
      we can access the file from. So people
      6:45:48
      can view this particular file. So this
      6:45:50
      gives us an ID and it gives us a URL and
      6:45:52
      it's going to tie it to a particular
      6:45:53
      user. And the reason we're using upsert
      6:45:56
      here is because essentially I want to
      6:45:57
      either insert a résé if they don't have
      6:45:58
      one or I want to update their resume to
      6:46:00
      be this new ré if they already have one
      6:46:02
      uploaded on our page. Now the next thing
      6:46:04
      that we can do is we can make sure that
      6:46:06
      we delete that old resume. So I'll just
      6:46:07
      kind of put the to-do below here because
      6:46:08
      we're going to have to get the data and
      6:46:09
      delete it. So we'll put that down there.
      6:46:11
      And then the final thing that we want to
      6:46:12
      do is we want to be able to send off a
      6:46:14
      request to our backend to do all the AI
      6:46:16
      processing as well. So we're just going
      6:46:18
      to say await
      6:46:20
      ingest.end send and make sure that we
      6:46:23
      import this properly. There we go. And
      6:46:25
      we want to send across an event that's
      6:46:27
      going to say appres.uploaded.
      6:46:30
      So whenever we upload a resume, we're
      6:46:31
      going to send across this event and then
      6:46:32
      we can listen to that to do things such
      6:46:34
      as AI processing or other things if we
      6:46:36
      want behind the scenes. Also, I'm going
      6:46:37
      to pass along all of our user
      6:46:39
      information for this ré as well.
      6:46:41
      Finally, we can pass down some type of
      6:46:42
      message if we want to. So we can say
      6:46:44
      message and this is going to say ré
      6:46:48
      uploaded successfully. And this is
      6:46:50
      actually used by the front-end client.
      6:46:52
      Like this message gets returned down to
      6:46:54
      our client. Now here we're going to call
      6:46:56
      this our custom file router. Oops.
      6:46:58
      Custom file router. There we go. And
      6:47:00
      this is going to be custom
      6:47:02
      file router which is we're going to use
      6:47:04
      for type safety later on in our
      6:47:06
      application. Now let's go ahead and
      6:47:07
      actually create this ingest event and
      6:47:09
      then this function right here. And then
      6:47:10
      all we need to do is implement this on
      6:47:11
      the front end and we're pretty much
      6:47:12
      done. So I'm going to copy the name of
      6:47:14
      this event over. And what we can do is
      6:47:15
      we can go all the way over to where we
      6:47:17
      have our ingest client and we're going
      6:47:18
      to add a brand new event for that. So
      6:47:21
      we'll come in here, give it that
      6:47:22
      particular name.
      6:47:24
      I'm going to say that I specifically
      6:47:25
      want this to return a user object
      6:47:27
      instead of a data object. And it's going
      6:47:29
      to have an ID which is a string. That's
      6:47:31
      the only thing we're going to be passing
      6:47:32
      to this object. And now if we go back
      6:47:34
      into our router, we should see that this
      6:47:36
      error has been removed because now we
      6:47:37
      have that event. Final thing we need to
      6:47:39
      do is add this upsert user resume
      6:47:40
      function. And if we go into our features
      6:47:42
      section for users and database, you'll
      6:47:44
      notice we need to create a brand new
      6:47:46
      file for user rums. So we'll say user
      6:47:48
      rumés.ts,
      6:47:50
      we're going to export a function with
      6:47:53
      that specific name. And we know it's
      6:47:55
      going to take in a user ID.
      6:47:59
      There we go. And then it's going to take
      6:48:00
      in all of our data. Now, this data is
      6:48:02
      coming from the type of our user resume
      6:48:07
      table. There we go. and we want to infer
      6:48:09
      the select property from that. But
      6:48:11
      specifically, we want to make sure that
      6:48:12
      we don't include the user ID because
      6:48:14
      it's already included here. So, we're
      6:48:15
      going to say omit just like that. And
      6:48:18
      we're going to make sure we omit the
      6:48:19
      user ID just because we already have
      6:48:21
      that included right here. Now, what we
      6:48:23
      can do is we can call DB.insert.
      6:48:26
      And we want to insert into the user ré
      6:48:27
      table. We want to insert the values. And
      6:48:30
      these values are our user ID followed by
      6:48:33
      all of our data that we passed in for
      6:48:34
      our resume. And in this one, since we
      6:48:36
      want this to be an upsert, when we have
      6:48:38
      a conflict, we just want to update the
      6:48:40
      particular resume. So, we're going to
      6:48:41
      take the target, which is the user ré
      6:48:44
      table dot user ID. And whenever there's
      6:48:47
      a conflict on that key, we just want to
      6:48:49
      set the data to the rest of our data.
      6:48:51
      Just like that. Now, the last thing we
      6:48:52
      need to do is revalidate this. So, we're
      6:48:54
      going to say revalidate user resumeé
      6:48:55
      cache, just like that. And we can pass
      6:48:58
      it in our user ID. And then, finally,
      6:49:00
      make this an async function so that we
      6:49:01
      get rid of all of our errors. There we
      6:49:03
      go. And it looks like now everything is
      6:49:05
      working as we expect it to. If we go
      6:49:06
      back over here, we should be able to
      6:49:07
      import this. And we should see
      6:49:08
      everything works fine with no errors.
      6:49:10
      Now we are getting some errors. So I
      6:49:11
      most likely messed something up in my
      6:49:12
      typing. And you can see here I used
      6:49:14
      infer select. This should be infer
      6:49:16
      insert instead. And that does clean up
      6:49:18
      our different errors that we have. Now
      6:49:19
      I'm going to go ahead and work on the
      6:49:21
      functionality for deleting the old résé
      6:49:22
      as well while we're here before we
      6:49:24
      actually go ahead and implement the
      6:49:25
      uploading of a résé because if someone
      6:49:26
      uploads a new ré and we call this
      6:49:28
      upsert, that's going to overwrite the
      6:49:30
      key in the URL for the rs. But on upload
      6:49:32
      thing where we actually have that data
      6:49:33
      stored, the old resume is still going to
      6:49:35
      be there and it's just going to kind of
      6:49:36
      be orphaned on its own with no way to
      6:49:37
      delete or reference it, which means
      6:49:39
      we're going to be racking up more
      6:49:40
      storage bills and we don't really want
      6:49:41
      that. So here we're going to first check
      6:49:43
      to see if they have a resume. We can do
      6:49:45
      that real quick by just saying ré file
      6:49:47
      key is equal to a wait get user ré file
      6:49:50
      key. We can pass it in our user ID. And
      6:49:53
      then we can just create this function
      6:49:54
      down here.
      6:49:56
      Get user ré file key. This is going to
      6:49:59
      take in a user ID which is a string and
      6:50:01
      then we just want to return the data
      6:50:03
      that we're going to be getting back from
      6:50:04
      that. So we're going to say db.query
      6:50:06
      user ré table. We want to find the first
      6:50:09
      one where and in our case we want it to
      6:50:11
      be equal to user ré table.
      6:50:15
      Whoops. Table dot user ID. There we go.
      6:50:18
      So we're making sure that that's equal.
      6:50:19
      We only really care about one column. So
      6:50:21
      I'm just going to manually get that
      6:50:22
      exact column which is our resume file
      6:50:24
      key. There we go. So we'll say const
      6:50:27
      data is equal to awaiting that.
      6:50:30
      And then we can just come down here and
      6:50:32
      we can return data.res
      6:50:34
      file key. Now we could add caching to
      6:50:36
      this function if we want. But in our
      6:50:37
      particular case it doesn't really make
      6:50:38
      sense to cache this particular
      6:50:39
      information because it's only going to
      6:50:41
      be accessed when we're uploading a new
      6:50:43
      resume which happens very rarely and
      6:50:45
      most often they're not going to have an
      6:50:46
      actual cached piece of data for that. So
      6:50:48
      I'm not going to bother with caching
      6:50:49
      that information. So now what we can do
      6:50:51
      here is we can essentially say hey if
      6:50:52
      there is a résé file key then we want to
      6:50:55
      delete the old ré because that means
      6:50:56
      they had one before and it's stored on
      6:50:59
      upload things still but we now added a
      6:51:01
      new ré that we replaced it with. So we
      6:51:02
      want to delete the data for the old one
      6:51:04
      while keeping our new database record.
      6:51:06
      This is actually incredibly easy to do.
      6:51:07
      So we'll just say whenever it's not
      6:51:09
      equal to null we're going to come in
      6:51:10
      here and we're going to await upload
      6:51:12
      thing
      6:51:14
      delete files and we're going to pass in
      6:51:15
      our ré file key. Now, this upload thing
      6:51:18
      variable is something that we're going
      6:51:19
      to need to create a new client for, kind
      6:51:20
      of like how we do with almost all of our
      6:51:21
      services. We are going to create a
      6:51:23
      client file where we export a constant
      6:51:25
      variable with that name, and it's going
      6:51:27
      to be called UT API. There we go. And
      6:51:29
      this is going to take in our token. And
      6:51:31
      we know that our token is our upload
      6:51:35
      thing token just like that. And we of
      6:51:38
      course want to put this into our
      6:51:39
      environment variable. So, let's import
      6:51:40
      our env.
      6:51:44
      And we're going to say, hey, this is
      6:51:45
      going to be a string
      6:51:47
      with a minimum value of one. Also, this
      6:51:50
      should have a minimum value of one. I
      6:51:51
      don't know why it got changed to 10.
      6:51:52
      There we go. Come back over to this
      6:51:54
      location. We can import upload thing.
      6:51:56
      Just like that. And in here, everything
      6:51:58
      is working fine. So, it looks like all
      6:51:59
      of that is working fine. We have the
      6:52:01
      deletion set up. We have the insertion
      6:52:02
      set up properly. We have this event that
      6:52:04
      we're going to get to in a little bit.
      6:52:05
      So, I'm just going to mark this as to-do
      6:52:07
      since we actually haven't processed that
      6:52:08
      event yet. There we go. And now we can
      6:52:10
      work on the next steps from the
      6:52:11
      documentation because essentially now we
      6:52:12
      have the ability to upload things but we
      6:52:13
      don't have the actual ability to
      6:52:14
      interact on our client with any of these
      6:52:16
      different things. So we scroll down a
      6:52:17
      ways here you can see that we first of
      6:52:19
      all need to create some router routes
      6:52:20
      for all of this inside of our
      6:52:21
      application. So we're going to go into
      6:52:23
      this API folder. So app we're going to
      6:52:25
      go into API. We're going to create a
      6:52:27
      brand new folder. This is going to be
      6:52:28
      for upload thing. And we're going to
      6:52:30
      create a brand new file called route.ts.
      6:52:33
      And we're just essentially going to copy
      6:52:34
      this exact code paste it in and then
      6:52:36
      change around any of the typing
      6:52:37
      information that we need. So, for
      6:52:39
      example, we called this custom file
      6:52:40
      router just like that. And otherwise, it
      6:52:42
      looks like everything else is exactly
      6:52:44
      the same. So, we'll just keep that all
      6:52:45
      as is. Next, if we scroll down some
      6:52:47
      further, we can essentially see how we
      6:52:48
      actually use our buttons inside of this.
      6:52:50
      So, I'm going to copy this over and I'm
      6:52:51
      going to put it inside of a components
      6:52:52
      folder. So, just minimize this down in
      6:52:54
      our services for upload thing. We'll
      6:52:56
      create a new folder called components.
      6:52:58
      There we go. And inside of here, we'll
      6:53:00
      create a component that's called upload
      6:53:02
      thing.tsx.
      6:53:04
      This is going to be for our upload
      6:53:05
      components. Then, we can just paste in
      6:53:07
      what those components are. Now, we're
      6:53:08
      going to modify these quite a bit, but
      6:53:10
      what we can do is make sure we use the
      6:53:11
      correct file router, which is custom
      6:53:13
      file router. Just like that. Paste that
      6:53:16
      into both of them. And instead of
      6:53:17
      uploading these or exporting these
      6:53:19
      directly, I'm actually going to change
      6:53:20
      this to be called component.
      6:53:23
      And I'm going to add component to the
      6:53:24
      end of this one. And what I want to do
      6:53:26
      is I want to create my own component
      6:53:27
      that wraps these that has all my own
      6:53:28
      customization to it. So, for example,
      6:53:30
      we'll export a constant called upload
      6:53:34
      drop zone. Just like that. And actually,
      6:53:36
      I'm going to make this a function. So
      6:53:37
      we'll say function upload drop zone.
      6:53:39
      There we go. And inside of here we can
      6:53:41
      return that upload drop zone component
      6:53:44
      and we can pass it in all the different
      6:53:46
      information that we want. So inside of
      6:53:48
      here I'm going to take in some props. So
      6:53:49
      we're going to take in a class name. One
      6:53:51
      of my favorite props to take in on
      6:53:53
      client upload complete. Make sure I
      6:53:56
      spell that properly. We're going to get
      6:53:58
      an on upload error. And then just all
      6:54:00
      the remaining props. And we're going to
      6:54:02
      set this equal to component props. and
      6:54:04
      it's going to be the component props of
      6:54:06
      this upload drop zone component. So
      6:54:08
      we'll say upload drop zone component
      6:54:12
      just like that. Make sure this is type
      6:54:14
      of. Give that a quick save. And now you
      6:54:17
      can see we can pass all that information
      6:54:18
      into here. So for example, we can pass
      6:54:20
      along all of our props plus these three
      6:54:22
      things as well because we're going to
      6:54:23
      specify our own class names and other
      6:54:24
      things. So we'll come in here with class
      6:54:26
      name just like that. We're going to use
      6:54:28
      the CN function to be able to combine
      6:54:30
      our class names with the existing class
      6:54:32
      names. I'm just going to give it some
      6:54:33
      boilerplate class names. For example,
      6:54:35
      we're going to make it have a dashed
      6:54:36
      border. Size of two. Make it have a
      6:54:38
      muted color. Rounded is going to be
      6:54:40
      large. Flex. And then we're just going
      6:54:42
      to center everything just like this. And
      6:54:45
      then I'm going to add on any additional
      6:54:47
      class names that we want using this
      6:54:48
      class name prop here. Next, we're going
      6:54:50
      to have on client upload complete.
      6:54:52
      That's going to take in a response. And
      6:54:54
      then what we want to do is if we hover
      6:54:56
      over this response, you'll see it's an
      6:54:57
      array of messages. What we can do is we
      6:54:59
      can just say res. each. So for each one
      6:55:01
      of our messages, it's going to give us
      6:55:03
      some server data.
      6:55:05
      Whoops. Server data. Just like that. And
      6:55:07
      all I want to do is I want to render out
      6:55:09
      a toast. Success for that server data
      6:55:12
      message. So we'll say server data
      6:55:13
      dossage. There we go. And that's going
      6:55:15
      to be whatever we return down from our
      6:55:17
      server. So inside of that route that we
      6:55:19
      created, there we go. This message right
      6:55:21
      here is exactly what that's going to be.
      6:55:23
      So that's what this is going to return.
      6:55:25
      And then we can call on client upload
      6:55:27
      complete just like that with our
      6:55:29
      response variable. Finally, I want to do
      6:55:31
      essentially the exact same thing but for
      6:55:33
      upload error. So on upload error, this
      6:55:36
      is going to take in an error
      6:55:39
      just like that. And this is going to be
      6:55:40
      an upload thing error with some JSON
      6:55:43
      data in it. There we go. And then what
      6:55:46
      we can do is we can use that error to
      6:55:47
      make a toast. So we can say toast error
      6:55:50
      error dossage. There we go. And then we
      6:55:53
      can say on error
      6:55:56
      we can pass along that error message. So
      6:55:58
      essentially all I'm doing is I'm making
      6:56:00
      it so I have some custom classes, some
      6:56:02
      default behavior for success and some
      6:56:04
      default behavior from error. But I can
      6:56:05
      add in my own custom behavior if I want
      6:56:07
      for each one of these. Now I could do
      6:56:09
      the exact same thing for the upload
      6:56:10
      button, but in our case, we're only
      6:56:11
      using the drop zone. So I'm not even
      6:56:13
      going to bother with the button. I'm
      6:56:14
      just going to have the drop zone
      6:56:15
      component. Now we can go further to see
      6:56:16
      what we're going to do with Tailwind. We
      6:56:18
      are using Tailwind V4. So we can see to
      6:56:20
      use that it's as simple as just creating
      6:56:21
      these two different import statements.
      6:56:23
      So I'm going to copy these different
      6:56:24
      import statements. I'm going to move
      6:56:25
      over into my application. We have our
      6:56:27
      global CSS right here. Scroll to the
      6:56:29
      very top of our page. And we're just
      6:56:31
      going to paste those in like that. Now
      6:56:33
      you'll see that we need to make sure
      6:56:34
      that our actual path for this node
      6:56:36
      modules is correct. And in our case,
      6:56:38
      since we are inside of an additional
      6:56:39
      folder, we need to add dot dot slash do.
      6:56:42
      And that's going to bring us directly to
      6:56:43
      node modules. If I just come up here
      6:56:45
      again and I type in, you'll see n OD
      6:56:48
      modules, this is the correct folder that
      6:56:50
      we're inside of because essentially
      6:56:51
      we're going backward one to app,
      6:56:53
      backward one to source, and then into
      6:56:54
      the node modules. So we just need to
      6:56:56
      make sure that's lined up with our
      6:56:57
      particular path. Now we can go ahead and
      6:56:58
      we can actually finish off what the rest
      6:56:59
      of the document is. And essentially this
      6:57:01
      is the putting a button on your page and
      6:57:03
      making it do something section. So
      6:57:04
      that's all we have left to do is just
      6:57:06
      essentially add in a button to our page
      6:57:08
      and then deal with some SSR stuff, which
      6:57:09
      is what we're going to be doing as well.
      6:57:11
      So we're going to go all the way back
      6:57:12
      over here. We're going to make sure
      6:57:13
      inside of upload thing here that we
      6:57:15
      actually specify this as a client
      6:57:16
      component. So we'll say use client just
      6:57:18
      like that because obviously we're using
      6:57:20
      functions and so on. Then what we're
      6:57:22
      going to do is all the way up here
      6:57:23
      inside of our user settings for ré. I'm
      6:57:25
      going to create a brand new file called
      6:57:26
      drop zoneclient.tsx
      6:57:29
      and again I'm putting that underscore to
      6:57:31
      kind of denote that this is a file that
      6:57:32
      is specifically only made because I need
      6:57:34
      a client component. And that's going to
      6:57:36
      be what this section right here is where
      6:57:38
      it says drop zone. I'm going to be using
      6:57:40
      this drop zone client. So, we're going
      6:57:42
      to export a function called drop zone
      6:57:44
      client.
      6:57:46
      This is going to be a use client. And
      6:57:48
      all this is going to do is essentially
      6:57:50
      return that drop zone component that I
      6:57:51
      created. So, it's upload thing drop
      6:57:53
      zone. And I believe I just called it
      6:57:55
      upload drop zone. There we go. Get that
      6:57:57
      from the right location. And then I just
      6:57:59
      need to make sure I return the specific
      6:58:01
      things I need. So, the main thing is
      6:58:02
      endpoint. This is going to be pointing
      6:58:03
      to the endpoint I created, which was ré
      6:58:05
      uploader. This the only one we have. And
      6:58:07
      then on client upload complete, I want
      6:58:09
      to refresh my page. So, we can come in
      6:58:10
      here. we can get our router
      6:58:13
      is equal to use router
      6:58:15
      just like that and then I can say
      6:58:17
      router.refresh
      6:58:20
      router.refresh.
      6:58:23
      Now the reason that I'm refreshing my
      6:58:24
      page on a successful upload is because
      6:58:26
      when we upload a file that means that
      6:58:27
      the file is now on the server. So we
      6:58:29
      want to refresh our page so we can show
      6:58:30
      the user the button that says hey here
      6:58:32
      is your file you can actually download
      6:58:34
      and use it. And then we're going to do
      6:58:36
      this final step of improving SSR. This
      6:58:38
      is just something that we need to do to
      6:58:39
      make sure it works properly with Nex.js.
      6:58:41
      And we specifically have a section down
      6:58:42
      here on how to do it with dynamic IO,
      6:58:44
      which is the feature that we're using
      6:58:46
      because we're using the experimental
      6:58:47
      version of Next.js. Now, to make this
      6:58:48
      easier, I'm actually going to be
      6:58:49
      creating a custom component for this.
      6:58:51
      So, in our component section, we're
      6:58:52
      going to call this upload thing SSR.tsx.
      6:58:56
      And inside of here, we essentially need
      6:58:58
      to create this little component right
      6:58:59
      here. So, we're going to export this
      6:59:01
      function. And this one actually is not
      6:59:02
      one that we export, but we do want this
      6:59:04
      to essentially wrap all of our code to
      6:59:06
      say, hey, this is dynamic code. So,
      6:59:08
      let's make sure that we import this next
      6:59:09
      SSR plugin. This is coming from
      6:59:15
      upload thing
      6:59:18
      slash reacts SSR plugin. There we go. We
      6:59:21
      also need to be able to extract the
      6:59:23
      router config from our custom file
      6:59:25
      router.
      6:59:27
      There we go. So, now that should be
      6:59:29
      everything we need to do to get this
      6:59:30
      particular component. All we need to do
      6:59:31
      next is wrap it inside of a suspense. As
      6:59:33
      you can see right here, that's what this
      6:59:35
      code is doing. So, we'll say export
      6:59:37
      function
      6:59:40
      upload thing SSR.
      6:59:43
      And this is just where we essentially
      6:59:45
      wrap what we created here in suspense.
      6:59:48
      So, we'll say suspense
      6:59:50
      and we will say UT SSR. There we go. And
      6:59:55
      if we import suspense, we should see
      6:59:56
      that everything is now working. And all
      6:59:58
      we need to do is just add this
      6:59:59
      essentially to our page. If we look
      7:00:00
      here, we essentially just add it to our
      7:00:02
      page anywhere that we want. So, we can
      7:00:03
      come all the way back over into our
      7:00:05
      layout and we can make sure we add that
      7:00:06
      particularly in.
      7:00:09
      There we go. And that's everything
      7:00:11
      inside of the documentation done. All we
      7:00:13
      need to do is hook up to make sure that
      7:00:14
      we have our actual API key and to make
      7:00:16
      sure that we have everything imported
      7:00:18
      properly. So, here we're going to render
      7:00:19
      out our drop zone client. There we go.
      7:00:22
      And now, let's go ahead and make sure we
      7:00:23
      get our API key. So, we can just create
      7:00:25
      an account, go onto our dashboard, sign
      7:00:26
      in, do whatever you want. And once
      7:00:28
      you're here, you should be able to
      7:00:29
      essentially create an app. You can see I
      7:00:30
      have this job board test. I'll create a
      7:00:32
      brand new app. We'll just go on the free
      7:00:33
      T tier here. We'll say job board final.
      7:00:37
      And then what I want to do is I just
      7:00:38
      want to create this app. And I'll zoom
      7:00:39
      in a little bit so it's a little easier
      7:00:40
      for you to see. There we go. Scroll all
      7:00:42
      the way down. Create that app. And then
      7:00:44
      we can actually access our API keys by
      7:00:46
      clicking this key button up here. And we
      7:00:48
      just want to get our key just like this.
      7:00:50
      So we'll say secret key. And then if we
      7:00:52
      scroll all the way to the side, you can
      7:00:53
      see right here we can copy this
      7:00:55
      particular key. And now we can move into
      7:00:56
      our environment variable and paste that
      7:00:58
      key down. So now we have our secret key
      7:00:59
      for this particular application. We can
      7:01:01
      now hopefully be able to upload files to
      7:01:03
      this. So now what we can do is we can
      7:01:05
      just give this a quick refresh.
      7:01:06
      Hopefully it'll be able to import
      7:01:07
      everything properly. Looks like it's
      7:01:08
      trying to import from the wrong
      7:01:09
      location. So let me just try to fix that
      7:01:10
      up. This is a capital D and this is a
      7:01:12
      lowercase L. That should hopefully fix
      7:01:14
      that import. There we go. Give that a
      7:01:16
      quick refresh. And it looks like we have
      7:01:18
      some errors possibly with our
      7:01:19
      TypeScript. First thing I'm going to do
      7:01:20
      is I'm just going to restart my server.
      7:01:22
      So we're going to come in here. We're
      7:01:23
      going to restart our server just because
      7:01:24
      it might fix some of these import errors
      7:01:25
      that we're having between these files
      7:01:27
      not showing up and thinking that they're
      7:01:28
      there versus not there. And then we're
      7:01:30
      going to look inside of our CSS to make
      7:01:31
      sure that we actually have everything
      7:01:32
      correctly imported for our files. And
      7:01:34
      already I can see a problem. I forgot to
      7:01:35
      put a semicolon right here. There we go.
      7:01:37
      That should clean up our Tailwind
      7:01:39
      specific problems. And now if we give
      7:01:40
      this a refresh. Hopefully everything is
      7:01:41
      going to work on our page. It'll take a
      7:01:42
      few seconds for it to render. But now
      7:01:44
      we'll see that we have the ability to
      7:01:45
      choose and upload a file. So, to test
      7:01:47
      this file upload, I just have this old
      7:01:49
      ré file that's just like a template file
      7:01:50
      that I'll just upload to actually use.
      7:01:52
      We'll click upload one file. That should
      7:01:54
      hopefully upload that file. And of
      7:01:56
      course, we're getting an invalid token
      7:01:57
      error. I believe the reason we're
      7:01:58
      getting that error is because we
      7:01:59
      actually copied over the wrong secret
      7:02:00
      key. We should be copying this V7 right
      7:02:02
      here. If we paste that down, you can see
      7:02:03
      that that's our actual upload thing
      7:02:05
      token. The other one's like a secret key
      7:02:06
      that we use for API request, which is
      7:02:08
      not what we're doing. We actually don't
      7:02:09
      want to use that at all because that
      7:02:11
      shouldn't be exposed to the client. So
      7:02:13
      we can come over here with our upload
      7:02:14
      thing token just like that. So now we
      7:02:16
      have the correct token being used. And
      7:02:18
      hopefully if we give this a little bit
      7:02:20
      of an upload button click it should
      7:02:22
      work. And there you go. You can see ré
      7:02:23
      successfully uploaded. And if we come
      7:02:25
      over here and we access our files you
      7:02:27
      can see that file right there has been
      7:02:28
      uploaded. And if we go to our user ré
      7:02:30
      section here you can see we have that
      7:02:32
      file being uploaded and the résé file
      7:02:34
      key. Now the important thing that I want
      7:02:36
      to show you is that when we upload a new
      7:02:38
      file it'll actually overwrite this old
      7:02:40
      file that we have right here. So, I'm
      7:02:41
      going to come in here and I'm just going
      7:02:42
      to upload a brand new file. We're going
      7:02:44
      to click upload. It's the same exact
      7:02:45
      file, but we can see that it should work
      7:02:47
      properly. If we didn't do the deletions,
      7:02:49
      we would have two files here, but when I
      7:02:51
      refresh, you'll see we now only have the
      7:02:52
      one file. And over here, we have just
      7:02:54
      still one user file, resume, and it has
      7:02:57
      that exact file uploaded inside of it.
      7:02:59
      So, now that we have the ability to
      7:03:00
      upload a specific resume to a specific
      7:03:02
      user, we can dive into the fun AI stuff
      7:03:04
      of creating like AI summaries, this
      7:03:06
      ranking applicants, and all that other
      7:03:07
      really cool stuff. So, let's go ahead
      7:03:09
      and actually work on that next. And
      7:03:10
      actually before we dive into that, I
      7:03:12
      want to make sure I add a button here
      7:03:13
      that shows the user's resume as well as
      7:03:15
      the section for the AI summary below it.
      7:03:17
      So let's do that real quick because that
      7:03:19
      will not take us very long. So resume
      7:03:21
      details. This is going to be a rather
      7:03:22
      simple function that first of all is
      7:03:24
      going to get our user ID which is await
      7:03:27
      current user. Make sure I spell user not
      7:03:29
      organization.
      7:03:31
      There we go. And then what I want to do
      7:03:32
      is I want to get the user resume which
      7:03:34
      is await user resume. And we're going to
      7:03:38
      pass in our user ID.
      7:03:41
      There we go. And then of course if our
      7:03:44
      user resume is equal to null, we return
      7:03:47
      null.
      7:03:51
      And we essentially do the exact same
      7:03:52
      thing up here for if our user ID is
      7:03:54
      equal to null. Also, we'll just return
      7:03:56
      not found here because obviously we
      7:03:58
      don't have a user. So we shouldn't be
      7:03:59
      able to access this particular page. Now
      7:04:01
      the next thing that we can do is we can
      7:04:03
      actually use that user resume to render
      7:04:04
      out our card footer which is going to be
      7:04:06
      where our button shows up. So we can say
      7:04:08
      button. Make sure we get the correct one
      7:04:10
      as child and we want to render out a
      7:04:12
      link component with an href that points
      7:04:15
      to that user resumeé
      7:04:18
      file URL. There we go. And for this
      7:04:21
      actually button, we can just say view
      7:04:22
      resume. And also since we want this to
      7:04:24
      redirect to a brand new page without
      7:04:26
      changing our current page, we'll set the
      7:04:28
      target equal to underscore blank. And
      7:04:30
      we'll also set the re equal to no
      7:04:34
      opener,
      7:04:35
      no refer. There we go. That'll just open
      7:04:38
      our page in a brand new tab instead of
      7:04:39
      opening it in the current tab. Now we
      7:04:41
      can come down here and we can create a
      7:04:42
      function async function. Get user
      7:04:46
      resume.
      7:04:49
      This is going to take in a user ID. And
      7:04:51
      since you've seen me create functions
      7:04:53
      like this a million times, we'll just
      7:04:54
      end up pasting that function in real
      7:04:56
      quick. And essentially all we're doing
      7:04:58
      is we're just creating that table
      7:04:59
      specifically where the user ID is equal
      7:05:01
      to the ID that we pass in. Now if we
      7:05:03
      give that a last import, you can now see
      7:05:05
      we have that function. And you can see
      7:05:06
      the view resume button shows up. Now the
      7:05:08
      next section we have to work on is our
      7:05:09
      AI summary card which is actually pretty
      7:05:11
      similar to what we have here. We first
      7:05:12
      want to get the information for our user
      7:05:14
      ID as well as our user resume. And we
      7:05:17
      also want to check to see if our user
      7:05:18
      resume
      7:05:20
      summary is equal to null and return as
      7:05:22
      well in that particular scenario.
      7:05:23
      Essentially we want to make sure that we
      7:05:25
      have a summary to render out to the user
      7:05:26
      before we try to render it. And we're
      7:05:28
      going to put this inside of a card. So
      7:05:30
      we'll come in here with a card header.
      7:05:32
      And this is going to have a class name
      7:05:33
      of border bottom just so we have a
      7:05:35
      little bit of distinction between the
      7:05:36
      header and the rest of our content.
      7:05:39
      Card title. This is going to say III
      7:05:41
      summary. Then we're going to come down
      7:05:42
      here with a card description.
      7:05:46
      This card description is going to say
      7:05:48
      this is an AI
      7:05:51
      generated summary of your resume. This
      7:05:55
      is used by employers to quickly
      7:05:58
      understand your qualifications.
      7:06:01
      and experience.
      7:06:04
      There we go.
      7:06:07
      Let me make sure I spell everything
      7:06:08
      properly.
      7:06:13
      And there we go. Now we have that. And
      7:06:15
      all we need to do is render out the
      7:06:16
      content. Card content. And this card
      7:06:18
      countdown is going to use markdown. So
      7:06:20
      we're going to use a markdown render
      7:06:21
      because we're going to tell the AI to
      7:06:22
      essentially return to us a markdown
      7:06:24
      summary. So we'll say source here is
      7:06:26
      user resume.AI summary.
      7:06:30
      There we go. So, right now, it doesn't
      7:06:32
      matter how many times we refresh the
      7:06:33
      page, nothing's going to show up there
      7:06:34
      because we don't have the AI summary
    </chapter>
    <chapter title="AI resume summary" start_time="7:06:35">
      7:06:35
      yet. So, that's the section that we can
      7:06:36
      kind of work on next is making that AI
      7:06:38
      summary for our application. And that is
      7:06:40
      going to be done using ingest because
      7:06:42
      that allows us to do long running
      7:06:43
      background jobs and they have lots of
      7:06:44
      tools specifically built for AI, which
      7:06:46
      is really handy. So, inside the services
      7:06:48
      folder for ingest in our functions
      7:06:49
      section, we're going to create a new
      7:06:51
      section for doing resume related
      7:06:52
      functions. And we're going to export a
      7:06:54
      constant variable called create AI
      7:06:58
      summary. of uploaded resume and that's
      7:07:02
      going to be a new ingest.create
      7:07:04
      function.
      7:07:07
      Make sure we import ingest.
      7:07:11
      There we go. And this create function
      7:07:13
      right here. This is going to take in the
      7:07:15
      ID of the function which we're going to
      7:07:17
      call create AI
      7:07:20
      summary of uploaded resume. Pretty much
      7:07:23
      the same thing that we did above. And
      7:07:24
      for the name, we're just going to give a
      7:07:25
      human readable version of this.
      7:07:28
      create AI summary of uploaded resume.
      7:07:33
      And then finally, we can say what event
      7:07:35
      we want this to trigger on. And this is
      7:07:36
      going to be based on those event names.
      7:07:38
      And in our case, the job application
      7:07:40
      created is not the event that we want,
      7:07:41
      but we do want résé uploaded. Whenever
      7:07:43
      we upload a resume, we want to run the
      7:07:44
      code inside of this particular function.
      7:07:47
      Then we can get an asynchronous function
      7:07:48
      that's going to return to us the step as
      7:07:50
      well as all of our event data, which is
      7:07:52
      really all that we care about. Now,
      7:07:54
      inside of here, we can get our ID,
      7:07:57
      which is our user ID, and that's coming
      7:07:59
      from event do user. So, we're just
      7:08:02
      renaming ID to user ID, so we have a
      7:08:04
      good idea of what that ID is
      7:08:05
      specifically for. And now, I want to use
      7:08:07
      a bunch of different steps to be able to
      7:08:09
      get our resume and then to do AI related
      7:08:10
      stuff to it, and then to save that
      7:08:12
      information back into our database. And
      7:08:14
      this is going to be one of the more
      7:08:15
      simple implementations of how we
      7:08:16
      actually use AI in our application
      7:08:17
      because it's like a one-step process.
      7:08:20
      So, we'll say our user resume is
      7:08:21
      awaiting step.run. This is going to be
      7:08:23
      called get user resumeé.
      7:08:28
      And inside this particular function, we
      7:08:30
      just want to await db.query
      7:08:32
      dot user ré table. We want to find the
      7:08:35
      first one. And we specifically want to
      7:08:38
      get it where the user ré table. User ID
      7:08:42
      is equal to our user ID. And we only
      7:08:45
      really care about one column and that is
      7:08:47
      the column a column for our ré file URL.
      7:08:50
      So we'll just get that as our only
      7:08:51
      column because we really only want to
      7:08:53
      use the resume itself. Then once we have
      7:08:55
      that, if the user resume is equal to
      7:08:57
      null, well, we'll just return because
      7:08:59
      for some reason we have no data in our
      7:09:00
      database. It got deleted or something
      7:09:02
      bad happened. Essentially, we can't
      7:09:03
      continue with this. Then what we want to
      7:09:06
      do is we want to get our AI result. So
      7:09:07
      we'll just call that result. And we can
      7:09:09
      await step.AI, which allows us to
      7:09:11
      integrate with a lot of different AI
      7:09:13
      tools relatively easily. And we'll call
      7:09:15
      this infer function. And we can give it
      7:09:16
      a name, create AI summary. And then what
      7:09:19
      we want to do is we want to specify all
      7:09:21
      the details for what we're going to be
      7:09:22
      interacting with. Now in our case, we're
      7:09:23
      going to be using a model and we
      7:09:25
      specifically are going to be using
      7:09:26
      Claude's model. So we'll say
      7:09:27
      step.ai.mmodels.anthropic.
      7:09:29
      That's how we're going to use Claude.
      7:09:31
      And for the model itself, we're going to
      7:09:33
      be using Claude 3.5. And we're just
      7:09:35
      going to get the latest version of it.
      7:09:37
      Now for our default parameters, we're
      7:09:39
      going to say that max tokens is going to
      7:09:41
      be 2048. You can set this to whatever
      7:09:43
      value makes the most sense for your
      7:09:44
      particular application. And then we can
      7:09:46
      come in here with an API key. Envir
      7:09:49
      get that from our server version. And
      7:09:51
      what I want to do is I want to get
      7:09:52
      anthropic.
      7:09:54
      API key. So we need to get an API key
      7:09:56
      for anthropic to use in this particular
      7:09:58
      section. Before we get to that though, I
      7:10:00
      just want to come in here with our body
      7:10:01
      cuz that's going to be where the bulk of
      7:10:02
      our application goes and that's where
      7:10:04
      we're going to pass in all of our
      7:10:05
      different messages and stuff like that.
      7:10:06
      So now let's go ahead and make sure
      7:10:08
      anthropic API key is a Z.string with a
      7:10:11
      min of one value. And then we can come
      7:10:13
      down into here for our environment
      7:10:15
      variables and we can set a section for
      7:10:17
      AI and we can say that that is going to
      7:10:19
      be our anthropic API key. Now to work
      7:10:20
      with cloud we need to create an API key.
      7:10:22
      So we're going to go to anthropic. If
      7:10:24
      you just search for the anthropic API
      7:10:25
      console or something along those lines,
      7:10:27
      you get to this section, click on API
      7:10:28
      keys and we can create a brand new API
      7:10:30
      key. We're just going to call this job
      7:10:32
      board final. There we go. And that gives
      7:10:35
      us our API key which we can copy and
      7:10:37
      paste into here. Now if you are using
      7:10:38
      Anthropic, you will get about $5 of free
      7:10:41
      usage. You can see I've used about 20
      7:10:42
      cents in the testing of this particular
      7:10:44
      application. So if you want to create a
      7:10:45
      brand new free account, you can
      7:10:46
      hopefully at least get a few dollars to
      7:10:47
      be able to test things out, but
      7:10:49
      otherwise, you know, you can create an
      7:10:50
      account. And doing this will, you know,
      7:10:51
      cost you only a few cents to run it a
      7:10:53
      couple times. So it's not a huge deal if
      7:10:54
      you have to actually pay for it. So now
      7:10:56
      with that API keyboarded into our
      7:10:58
      application, we can come back over into
      7:10:59
      here into our resume section and we can
      7:11:01
      implement what this body is going to be.
      7:11:02
      And this is just pretty much matching
      7:11:03
      the API for anthropic. So we're going to
      7:11:05
      pass in some messages. And inside of
      7:11:08
      this messages, we're going to have a
      7:11:09
      role. And this is going to be our user
      7:11:11
      specific message. And then we're going
      7:11:12
      to put some content inside of here. And
      7:11:14
      the content inside of this message is
      7:11:15
      really just going to be a type here of
      7:11:17
      document. Essentially, we're uploading a
      7:11:19
      file. This is going to be where our
      7:11:20
      resume goes. And we can specify where
      7:11:22
      this file comes from. In our case, it is
      7:11:24
      a URL. And we can specify the URL, which
      7:11:27
      is our user ré file URL. So we can say
      7:11:30
      user ré.res file URL. So now we at least
      7:11:33
      have our first message being passed
      7:11:34
      along, which is our file that we're
      7:11:36
      passing along. Next, I'm going to be
      7:11:38
      passing along another message. This is
      7:11:40
      going to be a text message right here.
      7:11:41
      And this message should go in the
      7:11:42
      content section. So, let me make sure I
      7:11:44
      get that in the correct location. There
      7:11:45
      we go. Because this is content we're
      7:11:46
      passing along. And then we need to pass
      7:11:48
      along what the text for this should be.
      7:11:49
      Now, this is rather lengthy text. So,
      7:11:51
      I'll paste it in place and then I'll
      7:11:52
      read it to you to explain exactly what
      7:11:53
      we're doing. But, you want to be as
      7:11:54
      specific as possible with the AI when
      7:11:56
      you're doing things like this. So, I
      7:11:57
      told it to summarize the following
      7:11:58
      resume and extract all the key skills,
      7:11:59
      experience, and qualifications. And
      7:12:01
      since I know I'm going to be using this
      7:12:02
      resume to help rank applicants, I told
      7:12:04
      this that hey, the summary should
      7:12:06
      include all the information a hiring
      7:12:07
      manager would need to know about a
      7:12:08
      candidate in order to determine if
      7:12:10
      they're a good fit for a job because I'm
      7:12:11
      going to be using this AI summary to
      7:12:13
      rank an applicant at a later point. And
      7:12:15
      then I should say it should be formatted
      7:12:16
      as markdown since I want markdown. I
      7:12:18
      tell it not to return any other text.
      7:12:19
      That way I don't get a bunch of
      7:12:20
      placeholder stuff that's like, hey,
      7:12:22
      here's your response for you. I just
      7:12:23
      wanted to return just the markdown. And
      7:12:25
      then I said if the file doesn't look
      7:12:26
      like a resume, like if someone uploads a
      7:12:27
      bogus file, just return na. So at least
      7:12:29
      I know there's no actual value being
      7:12:31
      returned. So then what we can do is we
      7:12:32
      can kind of minimize this down because
      7:12:33
      we have that step completed, we have
      7:12:35
      that step completed. The next thing we
      7:12:36
      want to do is to create another step for
      7:12:38
      saving this data. So we can say step.run
      7:12:41
      and we can say save AI summary
      7:12:45
      that's going to be an asynchronous
      7:12:46
      function and we can get our message
      7:12:49
      which comes from the API. So we can say
      7:12:51
      result.content of zero because we want
      7:12:53
      to get the very first message responded.
      7:12:55
      And if the message type is not equal to
      7:12:57
      text, well, that means for some reason
      7:12:59
      it's not returning the data we want. So,
      7:13:00
      we can just return and do nothing at
      7:13:02
      all. Otherwise, I want to upsert or
      7:13:04
      update our user resume,
      7:13:08
      pass in our user ID, and we're going to
      7:13:10
      get our AI summary and pass in that
      7:13:12
      message.ext. Just like that. Also, what
      7:13:14
      I could do inside of here is I could say
      7:13:16
      or if the message.ext
      7:13:19
      is equal to NA, that means I know that
      7:13:21
      it's not a valid file. So I can also
      7:13:22
      just ignore it in this particular case
      7:13:24
      as well. Actually, I probably don't want
      7:13:26
      to do that. I think I'll leave that off.
      7:13:27
      And the reason why is I want to save the
      7:13:28
      AI summary as NA because if I upload a
      7:13:31
      file that's invalid, I want to overwrite
      7:13:32
      the existing summary that's there for
      7:13:34
      the previous file. I always want to make
      7:13:35
      sure I overwrite this summary pretty
      7:13:36
      much no matter what. So now we are going
      7:13:38
      to be able to update the user resume. So
      7:13:40
      let's create a particular function for
      7:13:41
      that. It's not going to be too hard
      7:13:42
      because we kind of have already created
      7:13:43
      a function for this. So in users db user
      7:13:46
      rumés I essentially want to take this
      7:13:48
      upsert function and we're going to
      7:13:50
      replace it with an update user ré
      7:13:52
      function. There we go. This is going to
      7:13:54
      take a partial of this data. So we'll
      7:13:56
      just wrap this in a partial.
      7:13:59
      There we go. We're going to make sure
      7:14:00
      that this says update. This says set.
      7:14:03
      And we can remove all that information.
      7:14:04
      We don't need to pass along the user ID.
      7:14:07
      We just need the actual data that we're
      7:14:08
      updating. And then we just need a wear
      7:14:10
      clause so we don't update our entire
      7:14:11
      database by accident. That would be
      7:14:13
      pretty terrible.
      7:14:14
      So we'll say where the user ID is equal
      7:14:17
      to our user ID we pass in and then reset
      7:14:20
      my cache on all of that. So this should
      7:14:21
      hopefully update the AI portion of our
      7:14:23
      user resume as soon as we actually run
      7:14:25
      this particular function. So let's go
      7:14:26
      back over here and we're going to import
      7:14:28
      that function. And those are the three
      7:14:29
      steps that we essentially need to run
      7:14:31
      this particular code. And that's all we
      7:14:32
      need to do to create this actual event.
      7:14:34
      So now let's test to see if this is
      7:14:36
      something that actually works. I'm going
      7:14:37
      to go through I'm going to take that
      7:14:38
      exact same file and I'm going to
      7:14:39
      re-upload it. So essentially we can
      7:14:41
      re-trigger this event. I'll click upload
      7:14:42
      one file and we should hopefully see in
      7:14:44
      our ingest server that something is
      7:14:46
      going to happen as long as this is
      7:14:47
      successful. You can see it successfully
      7:14:48
      uploaded inside of ingest. You can see
      7:14:50
      actually right here we have an event
      7:14:51
      that is running currently. You can see
      7:14:53
      that it looks like it failed when it
      7:14:55
      tried to run stuff. So let's take a look
      7:14:56
      at that. We'll just make this full
      7:14:57
      screen. There we go. And you can see
      7:14:59
      that we're posting to localhost 3001
      7:15:02
      API ingest. Some stuff failed. Create AI
      7:15:05
      summary could not be made. The match
      7:15:07
      with target machine actively refused. If
      7:15:08
      we look down here, we have some errors
      7:15:10
      going on. was trying to sync to multiple
      7:15:11
      different job boards. I think the reason
      7:15:13
      for this was specifically because I was
      7:15:14
      doing some testing on my machine machine
      7:15:16
      in between some recording. So, I loaded
      7:15:18
      up a different one by accident. So,
      7:15:19
      we're going to delete that extra one
      7:15:20
      that shouldn't be there cuz this is the
      7:15:21
      actual one we want. But, you will notice
      7:15:23
      that there is going to be a particular
      7:15:25
      problem because we need to make sure we
      7:15:26
      add our functions cuz right now we only
      7:15:28
      have these functions. So, let's make
      7:15:29
      sure that in our code we implement all
      7:15:31
      of our different functions. So, let's
      7:15:32
      come all the way over here inside of app
      7:15:34
      and we go to API ingest route. We want
      7:15:36
      to make sure we add that as one of our
      7:15:38
      particular routes. Also, we have our
      7:15:40
      update organization and delete
      7:15:42
      organization. We need to also make sure
      7:15:43
      those are inside of ingest as well. So,
      7:15:45
      we'll come in here with update
      7:15:49
      and we'll say clerk delete
      7:15:52
      organization. There we go. So, now that
      7:15:54
      should have all of our different
      7:15:55
      functions in place. So, at least that
      7:15:57
      code should work properly. And now let's
      7:15:58
      try re-uploading that file again. So,
      7:16:00
      I'll just drag it over. We'll upload
      7:16:02
      that one more file. Hopefully this time
      7:16:03
      it'll actually trigger properly. If we
      7:16:05
      go over into ingest and we look at our
      7:16:06
      runs, you can see that this one is
      7:16:07
      running. This is the one that was bad.
      7:16:09
      So, we can cancel that one. And this one
      7:16:11
      looks like it actually is successfully
      7:16:12
      running. We have a queued up step that
      7:16:14
      is for some reason taking a really long
      7:16:15
      time. Let's look at what that step is.
      7:16:16
      Actually, it just finished. That was the
      7:16:18
      AI summary. Obviously, it makes sense
      7:16:19
      that that takes a little while, but you
      7:16:21
      can see here this is what we sent to it.
      7:16:22
      And if we look at the output, you can
      7:16:24
      see this is the text that is essentially
      7:16:25
      a big summary of all that information.
      7:16:27
      And then it's going to finalize that
      7:16:28
      that was imported and saved into our
      7:16:30
      application. So, we should see here if
      7:16:32
      we actually give this a quick refresh,
      7:16:33
      we do have a full AI summary down here
      7:16:35
      of what's going on. This looks like it's
      7:16:37
      not quite formatted like I want it to
      7:16:38
      be. My guess is I imported like the
      7:16:40
      wrong markdown render or something like
      7:16:42
      that. So, let's go to where I have that
      7:16:44
      rendering out, which is inside of my
      7:16:47
      jobseker folder, user settings page
      7:16:49
      right here. I believe I probably just
      7:16:51
      have the wrong markdown renderer. So,
      7:16:53
      let's go ahead and we're going to make
      7:16:55
      sure wherever we imported that, we
      7:16:56
      remove it. Actually, that does look like
      7:16:58
      it's the correct one. Interesting. Let's
      7:17:00
      take a look at it to see the class names
      7:17:02
      should be applied to it, but it looks
      7:17:04
      like they're not being applied cuz
      7:17:05
      obviously these are not the correct CSS
      7:17:07
      styles. It could be an issue of where
      7:17:09
      we're actually exporting these from cuz
      7:17:10
      this is a client component. So, what I'm
      7:17:12
      going to do is I'm actually going to
      7:17:13
      take these out of here. I'm going to
      7:17:14
      move them into this, which is a server
      7:17:16
      component because maybe that was causing
      7:17:18
      some issues. And then I'm going to make
      7:17:19
      sure here I import those class names
      7:17:21
      properly. So, now we're going to give
      7:17:23
      that a little bit of a refresh. See if
      7:17:24
      that makes a difference. Looks like it's
      7:17:26
      doing some things, but again, clearly
      7:17:28
      not the styling that I'm looking for.
      7:17:30
      So, after lots of digging, I finally
      7:17:31
      figured out what the problem was, and
      7:17:32
      it's from the very beginning of the
      7:17:33
      video. I put schema instead of scheme.
      7:17:37
      That literally is the only reason that I
      7:17:39
      was having all these issues with the
      7:17:40
      dark mode for all my stuff. So,
      7:17:42
      actually, we can look for pros invert
      7:17:45
      because there's another section where we
      7:17:46
      are implementing this, but we don't
      7:17:48
      actually need this because this section
      7:17:49
      we don't need to put anymore because it
      7:17:51
      should just work because I actually
      7:17:52
      spelled scheme correctly instead of
      7:17:54
      schema. So now if we make this a little
      7:17:55
      bit larger, we can kind of see this is
      7:17:56
      what that summary looks like. It looks
      7:17:58
      like my border on the bottom is not
      7:17:59
      showing up like it should, but otherwise
      7:18:01
      you can see that it's rendering.
      7:18:03
      Obviously my border is showing up down
      7:18:04
      here. So I have a little bit of a
      7:18:05
      placement issue on where my code is
      7:18:06
      going. That's purely just a me issue
      7:18:08
      though. So inside of my page here, we
      7:18:10
      have my AI summary card. And if we
      7:18:12
      scroll down to the AI summary card, you
      7:18:14
      can see this is inside the card content,
      7:18:16
      which is also inside the header. Clearly
      7:18:18
      that's not correct. So now you can see
      7:18:19
      our line shows up. And then we have our
      7:18:21
      actual summary for the entire resume
      7:18:22
      here, which looks really good overall.
      7:18:24
      So now that we actually have the ability
      7:18:25
      to upload a resume, the next step is to
      7:18:27
      actually rank an applicant when they
      7:18:29
      apply for a job. Because now we can
    </chapter>
    <chapter title="AI applicant ranking" start_time="7:18:30">
      7:18:31
      apply for a job with a real resume with
      7:18:32
      a real resume summary to use for that
      7:18:35
      particular application. So for example,
      7:18:36
      if I go back to the job board and I were
      7:18:38
      to click on one of these jobs to try to
      7:18:40
      apply for it, for example, let's say
      7:18:41
      that I clicked on like this job or this
      7:18:43
      job. And then when I went to apply for
      7:18:44
      it, we should be able to use that resume
      7:18:46
      to actually rank the user cuz I've
      7:18:47
      already applied for this one, but I
      7:18:48
      didn't have a resume. So when I click
      7:18:49
      apply here, we should actually use the
      7:18:51
      AI portion in the background. So let's
      7:18:53
      go ahead and implement that. First of
      7:18:54
      all, in our application, let me just
      7:18:55
      search for to-do because I believe this
      7:18:57
      AI generation one has already been
      7:18:59
      solved. Actually, this is the one that
      7:19:01
      we've already solved for uploading the
      7:19:02
      resume. This is the next one that we
      7:19:03
      have to work on, which is the app job
      7:19:05
      listing application created. So let's go
      7:19:07
      ahead and we're going to create a
      7:19:08
      section for that inside of our ingest
      7:19:10
      services. So we'll go down into ingest
      7:19:12
      here. We're going to go down into
      7:19:13
      functions and we'll create a brand new
      7:19:14
      file inside of here for the job listing
      7:19:17
      application.
      7:19:19
      And inside of this file, we'll just say
      7:19:21
      export const rank applicant. And that's
      7:19:25
      going to be an ingest create function.
      7:19:28
      It's going to take in all of our
      7:19:29
      different parameters. But we already
      7:19:30
      have our event copied into our
      7:19:32
      clipboard, so we might as well use that
      7:19:33
      because that is the event that we're
      7:19:34
      going to be processing. Now, we're going
      7:19:36
      to give it an ID and a name. So, we'll
      7:19:37
      say rank applicant.
      7:19:40
      And the name is rank applicant. There we
      7:19:44
      go. And now we can actually use this
      7:19:46
      asynchronous event with our step and our
      7:19:49
      event data.
      7:19:52
      There we go. And we can get our user ID
      7:19:55
      and our job listing ID from our
      7:19:58
      event.data because we know that that is
      7:19:59
      the type that we passed along to our
      7:20:01
      information. Then we can use that to get
      7:20:03
      all the data that we're going to need
      7:20:04
      because we're going to need to be able
      7:20:05
      to get their cover letter if they pass
      7:20:07
      one in. We need to get their resume
      7:20:08
      summary. We need to be able to get the
      7:20:10
      job listing data. And then we want to
      7:20:11
      pass all that along to our AI and
      7:20:13
      essentially tell the AI, hey, given all
      7:20:14
      this information, give us a rating of
      7:20:16
      one to five. And we're going to use some
      7:20:18
      more sophisticated and advanced AI tools
      7:20:20
      to understand this particular system
      7:20:21
      system. So let's come in here. We're
      7:20:23
      going to get our cover letter. That's
      7:20:26
      going to be step.run. We're going to say
      7:20:28
      get cover letter.
      7:20:31
      We're going to make this an asynchronous
      7:20:32
      function. And this essentially is just
      7:20:34
      going to return to us a rather simple
      7:20:36
      little bit of code. So I'm going to copy
      7:20:38
      over our database query because we've
      7:20:40
      run these database queries a million
      7:20:42
      times. So let me just import this
      7:20:43
      particular code. Get an and query here
      7:20:48
      and import that.
      7:20:50
      There we go. So essentially let me just
      7:20:52
      say const
      7:20:54
      resume is equal to that. There we go. Or
      7:20:56
      actually not resume. This is
      7:20:58
      application.
      7:20:59
      There we go. And this application is
      7:21:01
      just going to get from our database
      7:21:02
      table where the user ID and the job
      7:21:04
      listing ID match. essentially what is
      7:21:05
      the application this user just
      7:21:06
      submitted. We're specifically only
      7:21:08
      getting the cover letter from it. And
      7:21:10
      then down here, I want to return
      7:21:11
      application.co
      7:21:13
      letter if it exists. So now we have a
      7:21:15
      function that gets our cover letter. And
      7:21:16
      you'll notice I'm not actually awaiting
      7:21:17
      this because I want to run these in
      7:21:19
      parallel, which is a nice thing about
      7:21:20
      ingest. We can run our steps in parallel
      7:21:22
      if we want because we have lots of steps
      7:21:23
      that are going to be all run at the same
      7:21:25
      time because we just need this data
      7:21:26
      next. So for example, get resume.
      7:21:30
      This is going to get us our resume. And
      7:21:32
      we can return our resume. And we want to
      7:21:34
      get the AI summary. Just like that. And
      7:21:36
      this is going to be coming from our user
      7:21:38
      resumeé table. So, let me just paste
      7:21:40
      that down a couple times. There we go.
      7:21:42
      We don't care about the job listing
      7:21:44
      section. So, we don't need an and here
      7:21:45
      or there. And we want to get the AI
      7:21:48
      summary. There we go. So, we're
      7:21:49
      essentially just querying our user ré
      7:21:51
      table to get whatever the current rés
      7:21:52
      is.
      7:21:54
      And we'll call that step get résumé. And
      7:21:56
      again, I'm not awaiting this step. I'm
      7:21:57
      just getting it right here so I can run
      7:21:58
      it in parallel. And then the kind of
      7:22:00
      final big step we need is the step for
      7:22:01
      getting our job listing. And I'll just
      7:22:03
      kind of copy paste this in again because
      7:22:04
      all we're doing is querying our job
      7:22:05
      listing table where our ID is our job
      7:22:07
      listing ID. And I'm just getting all the
      7:22:09
      columns that the AI needs. So the AI
      7:22:11
      needs to know what the ID is so it can
      7:22:12
      save the information in our database. It
      7:22:14
      needs to know what the city is, the
      7:22:15
      description, the experience level,
      7:22:16
      location requirement, state
      7:22:17
      abbreviation, title, and the wage
      7:22:19
      information. There's other information I
      7:22:20
      could get such as like posted at and
      7:22:22
      status and so on, but it doesn't need
      7:22:23
      that. Actually, type should be in there
      7:22:24
      as well. So let's make sure we get type
      7:22:26
      in there. So that way we know if
      7:22:27
      someone's only looking for like a
      7:22:28
      part-time job and this is a full-time
      7:22:30
      job. It obviously would tell them, "Hey,
      7:22:31
      not a good match." So now that we have
      7:22:33
      all the information we need, we can just
      7:22:35
      stream this all into our AI and
      7:22:36
      essentially tell the AI, "Hey, do all
      7:22:38
      this information for us, rank the
      7:22:39
      database user, and then store it in our
      7:22:41
      database." So the next little bit of
      7:22:42
      code is rather simple. Essentially, all
      7:22:44
      we're doing right here is we're getting
      7:22:45
      our cover letter, our resume summary,
      7:22:46
      and our job listing by waiting for these
      7:22:48
      different steps. So we ran all these
      7:22:50
      steps at once. Now we're waiting for all
      7:22:51
      of them to finish so we can run them in
      7:22:53
      parallel to save a little bit of
      7:22:54
      computation and time. Then we're
      7:22:55
      checking to make sure we have a resume
      7:22:57
      summary and a job listing because if for
      7:22:59
      some reason there's no job listing or no
      7:23:00
      resume. There's no point in ranking the
      7:23:02
      applicant because we don't know what to
      7:23:03
      rank them against and we don't know what
      7:23:05
      their skills are. If there's no cover
      7:23:06
      letter, that doesn't matter. That's an
      7:23:08
      optional thing. So, we don't really need
      7:23:09
      that. We just need the resume and the
      7:23:10
      job listing. Then we can actually create
      7:23:12
      an agent to be able to run this. And
      7:23:14
      this is kind of where the real power of
      7:23:15
      a tool like Inest comes in because their
      7:23:17
      agent kit system is really, really
      7:23:18
      powerful for running AI with a lot of
      7:23:20
      different tools and networks and
      7:23:21
      everything like that. We're only going
      7:23:22
      to be scratching the surface with what
      7:23:24
      you can do, but it's quite powerful. So,
      7:23:25
      we're going to create an applicant
      7:23:27
      ranking agent. So, we'll call this
      7:23:28
      applicant ranking
      7:23:31
      agent and we'll just call run on this
      7:23:35
      and we'll pass it in the information we
      7:23:36
      want and we're going to be passing it in
      7:23:38
      as JSON. So, we're going to say
      7:23:39
      JSON.stringify our cover letter, our
      7:23:42
      resume summary,
      7:23:45
      we're going to get our job listing,
      7:23:48
      and then finally our user ID. So that's
      7:23:50
      all the information we're going to be
      7:23:51
      passing into this applicant ranking
      7:23:52
      agent. And to handle all of our AI
      7:23:54
      stuff, I'm going to create a separate
      7:23:55
      folder called AI. And I'm going to
      7:23:57
      create that applicant raking agent
      7:23:59
      directly inside this folder. So we're
      7:24:01
      going to say export content raking
      7:24:03
      agent. Now to create an agent is
      7:24:04
      actually quite simple. We can just come
      7:24:06
      in here and say create agent. And of
      7:24:08
      course we need to make sure we install
      7:24:09
      the library for this. So the library for
      7:24:11
      this is the agent kit library. So we can
      7:24:13
      come down here and we can install
      7:24:17
      ingest/ aentkit. We're going to force
      7:24:20
      that since we're using the essentially
      7:24:21
      canary version of Nex.js that's going to
      7:24:23
      install this library for us with all the
      7:24:25
      different stuff that we need. And then
      7:24:26
      what we can do is we can actually create
      7:24:27
      an agent using that particular library.
      7:24:29
      And this kind of just wraps all the AI
      7:24:31
      tools to make them easier to work with
      7:24:33
      in general. It adds a lot of tools for
      7:24:35
      example like doing networks of agents
      7:24:36
      that communicate with each other, doing
      7:24:38
      different things with tools like
      7:24:39
      accessing databases and so on. It's
      7:24:41
      quite powerful and we're again only
      7:24:42
      going to scratch the surface. So let's
      7:24:44
      import create agent. I might have to
      7:24:46
      manually import that.
      7:24:49
      Just like that. And this is from that
      7:24:52
      ingest/ aentkit. Now for creating this
      7:24:54
      particular agent, it's actually
      7:24:56
      relatively simple how you create an
      7:24:57
      agent. It's kind of like an AI prompt.
      7:24:58
      First of all, we'll give it a name. This
      7:25:01
      is an applicant
      7:25:03
      ranking agent. And this name could be
      7:25:05
      useful for other AIs. If we have them in
      7:25:07
      like a network and they can communicate
      7:25:08
      with each other, they might use this
      7:25:09
      name and description to understand what
      7:25:11
      these different tools do. So, speaking
      7:25:13
      of description, we need to define a
      7:25:14
      description for this AI. I'm going to
      7:25:16
      copy over the description because it's
      7:25:17
      kind of a long text. Essentially, I'm
      7:25:18
      just saying, "Hey, this is an agent for
      7:25:19
      ranking job applications for specific
      7:25:21
      job listings based on the resume and
      7:25:23
      cover letter. And then inside the system
      7:25:25
      text is essentially the meat and
      7:25:27
      potatoes of how we make this AI work."
      7:25:29
      It is our instructions to the AI on
      7:25:30
      exactly what to do and how things are
      7:25:32
      formatted. So, our system text is going
      7:25:34
      to be quite long. Almost always you'll
      7:25:35
      have a really long text. In our case,
      7:25:36
      we're saying that you are an expert at
      7:25:38
      ranking job applications for specific
      7:25:39
      jobs based on the resume and cover
      7:25:41
      letter because that's kind of the
      7:25:42
      information we're passing in. I then
      7:25:44
      specify how our information comes in.
      7:25:45
      You'll be provided a user prompt that
      7:25:47
      includes a user's ID, resume, and a
      7:25:49
      cover letter, as well as the job listing
      7:25:51
      they're applying for. And it's all in
      7:25:52
      JSON format. That's this section right
      7:25:54
      here. We applied a user prompt. That's
      7:25:56
      what run does. And we put it in a JSON
      7:25:58
      format. So, we essentially are telling
      7:25:59
      the AI what to expect as our input.
      7:26:01
      We're then telling the AI what to do.
      7:26:02
      Your task is to compare the job listing
      7:26:04
      with the applicant's resume and cover
      7:26:05
      letter and provide a ranking for the
      7:26:07
      applicant on how well they fit that
      7:26:08
      specific job listing. So, we're
      7:26:10
      essentially telling it, hey, look at the
      7:26:11
      job listing. Look at their resume.
      7:26:12
      figure out if they're a good fit for
      7:26:13
      this job. Then we specify what the
      7:26:15
      rating scale should look like. I say
      7:26:17
      that the rating is a number between one
      7:26:18
      and five where five is like a perfect
      7:26:20
      score on someone. Three is someone that
      7:26:22
      barely meets the requirements and one is
      7:26:23
      for someone that does not meet the
      7:26:25
      requirements at all. And then I specify
      7:26:26
      that you should save this user rating in
      7:26:28
      the database and not return any output
      7:26:30
      because all I care about is them saving
      7:26:31
      the information in the database and
      7:26:32
      nothing else. Now, in order to save the
      7:26:34
      information in the database, we need to
      7:26:36
      use a tool. we can pass along tools
      7:26:38
      which are essentially just pieces of
      7:26:39
      code that we create that the AI can run
      7:26:41
      and all of it's going to be type- safe
      7:26:42
      and really useful. So let's come up here
      7:26:43
      and create a brand new tool. We'll call
      7:26:45
      this save applicant
      7:26:49
      whoops rating tool and we'll call create
      7:26:52
      tool which is a function again from this
      7:26:54
      exact same system. And we have the
      7:26:56
      ability to define a name for this. We'll
      7:26:57
      say save applicant ranking
      7:27:01
      and then the description is what the AI
      7:27:02
      uses to figure out, hey, is this
      7:27:04
      something that I need to do? So we'll
      7:27:05
      say saves the applicants
      7:27:08
      ranking for a specific job listing in
      7:27:12
      the database. So now the AI knows, hey,
      7:27:14
      if I want to save this rating, I should
      7:27:15
      use this particular tool because this is
      7:27:17
      what it does. Parameters is a type safe
      7:27:19
      version of what our parameters are. So
      7:27:20
      we're going to be using zod for that. So
      7:27:22
      we can say zod object is going to be
      7:27:24
      rating and it's going to be a number.
      7:27:28
      There we go. And it's going to be an
      7:27:30
      integer. The maximum value is five. the
      7:27:32
      minimum value
      7:27:34
      is one. So, it's going to make sure it's
      7:27:36
      rated based on these parameters. So, we
      7:27:38
      have our parameter for our rating. We're
      7:27:40
      also going to be passing in the job
      7:27:41
      listing ID. That's going to be a string.
      7:27:44
      And then finally, we have a user ID and
      7:27:47
      that is going to be a string as well.
      7:27:50
      There we go. So, now we at least know
      7:27:51
      we're passing in the information for
      7:27:52
      these particular things. Now, we can
      7:27:54
      specify a handler. And this handler is
      7:27:56
      going to be this function that is
      7:27:57
      actually typed based on our parameters.
      7:27:59
      So you can see inside this async
      7:28:00
      function. If I just define it real
      7:28:02
      quick, inside the parameters, we have
      7:28:04
      our job listing ID, we have our rating,
      7:28:06
      and we have our user ID that match these
      7:28:07
      parameters up here. So what I can do is
      7:28:09
      I can call update job listing
      7:28:12
      application. I can pass it in my job
      7:28:15
      listing ID, my user ID, that's like my
      7:28:18
      ID key, and then I can pass in the data
      7:28:20
      I want to update, which is my rating,
      7:28:21
      and that'll do that for me. And then I
      7:28:23
      can return some text so the AI knows
      7:28:24
      what happened because the AI calls this
      7:28:26
      tool and then waits for a response. And
      7:28:28
      we can just say successfully
      7:28:31
      saved applicant ranking score. There we
      7:28:34
      go. So now the AI knows that this was a
      7:28:35
      successful tool call. And down here we
      7:28:37
      can pass that along as one of our tools.
      7:28:39
      So let's go ahead and create this
      7:28:40
      function to update this. So we can come
      7:28:42
      over into our features for our job
      7:28:43
      listing applications inside the
      7:28:45
      database. We can just create a brand new
      7:28:46
      function.
      7:28:49
      There we go. This is going to take in
      7:28:51
      some information for our application.
      7:28:53
      And it's going to take in our ID
      7:28:54
      information as well. So instead of
      7:28:55
      making you watch me type that out, I'll
      7:28:57
      just copy over the types themselves cuz
      7:28:58
      they're relatively straightforward. You
      7:29:00
      can see here we have our ID information.
      7:29:02
      And then we have the partial information
      7:29:03
      on the insertion that we're going to be
      7:29:04
      doing. Then inside of our function, all
      7:29:06
      we're doing is we're calling that we
      7:29:07
      want to update this database. Make sure
      7:29:09
      this is an asynchronous function. And
      7:29:11
      for our checks here, we're just doing a
      7:29:12
      simple wear check where we're just
      7:29:14
      checking to make sure our ID columns are
      7:29:15
      correct. So essentially, we're just
      7:29:16
      updating the user with this ID based on
      7:29:18
      this particular data that we're passing
      7:29:19
      in. Now we can give that a quick save
      7:29:21
      and we can head back into our
      7:29:22
      application for our ranking section. We
      7:29:24
      can import this code and then all we
      7:29:26
      need to do is tell our model what AI
      7:29:27
      model we're using. So we can come in
      7:29:29
      here with a model. I'm going to actually
      7:29:30
      be using Gemini for this because they
      7:29:32
      have a free tier that's actually rather
      7:29:33
      good. So we can come in here, we can say
      7:29:35
      model and the model we're going to be
      7:29:37
      using is the Gemini 2.0 flash just like
      7:29:39
      that. And then we can specify our API
      7:29:42
      key and that is going to be envi
      7:29:47
      API key. And this is just kind of nice
      7:29:49
      because it doesn't matter what model we
      7:29:50
      use. You could swap this out for an
      7:29:51
      anthropic model and everything else in
      7:29:53
      our code stays exactly the same. So
      7:29:54
      whatever model you want, you can swap it
      7:29:56
      around, change it however you want. This
      7:29:57
      is really nice cuz it kind of gives you
      7:29:58
      one way to interact with many different
      7:30:00
      models. The only reason we're using
      7:30:01
      Gemini in this particular case is
      7:30:03
      because it has a free tier that we can
      7:30:04
      use unlike Claude which only has that
      7:30:06
      small little free sample. So we'll come
      7:30:08
      in here with a minimum of one just like
      7:30:10
      that. And then we're going to define
      7:30:12
      this particular API key. So we'll come
      7:30:14
      down here Gemini API key. So to use
      7:30:15
      Gemini all we need to do is just go to
      7:30:17
      the AI studio for Google. We can just
      7:30:19
      type in Gemini API key. You'll probably
      7:30:20
      get brought to this particular page. And
      7:30:22
      then we can just click create API key.
      7:30:23
      We can select an existing project. For
      7:30:25
      example, this Gemini API is one I was
      7:30:27
      using for testing. So, we'll just create
      7:30:28
      an API in that project for it. Sometimes
      7:30:30
      it'll even let you create an API key for
      7:30:31
      a brand new project. I'll click copy
      7:30:33
      right here. And we'll just paste that in
      7:30:34
      as our API key. Again, you can use
      7:30:36
      whatever model you want. I'm just using
      7:30:37
      Gemini because they have a free tier
      7:30:39
      that is generous enough for the testing
      7:30:40
      purposes that we're doing. So, now we
      7:30:42
      can close out of that. We don't need
      7:30:43
      that anymore. We don't even need this
      7:30:44
      anymore. So, we can come back over to
      7:30:46
      here. We have that Gemini API key. Let's
      7:30:48
      make sure everything is imported
      7:30:49
      properly such as this. And now hopefully
      7:30:51
      with all of that done, we should have
      7:30:52
      everything we need done to actually use
      7:30:54
      this to rank applicants based on data
      7:30:56
      that we pass in. Now, in order to test
      7:30:57
      this properly, we need to have a good
      7:30:59
      description for our actual job. So, what
      7:31:00
      I'm going to do is I'm going to come
      7:31:01
      over here, go back to my employer
      7:31:02
      dashboard. I'm going to modify this job
      7:31:05
      right here to give it a much better
      7:31:06
      description. So, we'll come in here.
      7:31:07
      We're going to edit this job. And what I
      7:31:09
      want to do is I just want to paste down
      7:31:10
      a description that I got directly from
      7:31:11
      Indeed for a random job on Google. And
      7:31:13
      this is a job that is going to be very
      7:31:15
      front-end focused. So hopefully our
      7:31:17
      application which is a front-end focused
      7:31:18
      application should be relative
      7:31:20
      relatively qualified for this particular
      7:31:22
      job. We're also going to just say that
      7:31:24
      it's a remote job for sure and we'll
      7:31:25
      just say full stack developer because
      7:31:28
      that's kind of what the job title is.
      7:31:29
      Actually I believe I can just copy it
      7:31:30
      over. This is the exact title that is
      7:31:32
      from Indeed. So at least have an
      7:31:34
      implementation with a decently long
      7:31:35
      description that can detail exactly what
      7:31:37
      this job is looking for. Now we can go
      7:31:39
      back to our job board and we can try
      7:31:41
      applying for that specific job with the
      7:31:42
      lengthy job description. Also, I noticed
      7:31:44
      the problem is I can't scroll this list.
      7:31:46
      So, we'll come back and fix that in a
      7:31:47
      little bit. But, I'm going to click
      7:31:48
      apply. I'm not going to upload a cover
      7:31:49
      letter. We're just going to click apply.
      7:31:50
      And actually, before I do that, I want
      7:31:52
      to make sure I set up the actual system
      7:31:54
      to rank this. So, let's come over here.
      7:31:56
      We have this function that we created,
      7:31:57
      but we didn't actually add that function
      7:31:59
      to our API. So, inest route just like
      7:32:02
      this. Add in that function. So, now at
      7:32:04
      least it'll run that function for us.
      7:32:06
      And now we can come back over here and
      7:32:08
      we can apply for that job. So, we're
      7:32:09
      going to click apply. We're going to
      7:32:10
      click apply. And hopefully it's going to
      7:32:12
      rank this applicant for us. So if we
      7:32:13
      look at the ingest system which we have
      7:32:15
      right here, we can look at the runs that
      7:32:17
      are going on and it looks like job
      7:32:20
      listing application created ranking the
      7:32:21
      applicant and actually ran very quickly
      7:32:23
      and you can see that it ranked our
      7:32:24
      applicant. A little hard to see make
      7:32:26
      that a little bit bigger but you can see
      7:32:27
      we have the output for this particular
      7:32:28
      ranking and you can see it gave them a
      7:32:30
      fivestar rating which makes sense
      7:32:31
      because this is a front-end focused job
      7:32:33
      and we have a very strong front-end
      7:32:34
      focused resume for this. So you can see
      7:32:36
      that that properly worked and it
      7:32:37
      hopefully saved it in our database. So,
      7:32:39
      if we look at our database, we look at
      7:32:40
      our job listing application. You can see
      7:32:42
      we have a fivestar rating for that user
      7:32:43
      we just applied with with no resume.
      7:32:45
      Now, I do want to fix this overflow
      7:32:46
      issue where we can't actually scroll.
      7:32:48
      That's clearly a problem. So, I'm going
      7:32:49
      to go into my application. We're going
      7:32:50
      to find that section which is inside the
      7:32:52
      app. It's in the jobseker section. This
      7:32:54
      is the job listing. And this is the
      7:32:55
      client sheet section. This is probably
      7:32:57
      where I need to add my class names. And
      7:32:59
      of course, I can't do it on the sheet
      7:33:00
      itself. I need to do it in here where we
      7:33:02
      use that sheet. So, I believe scroll all
      7:33:04
      the way to the top cuz I think that's
      7:33:05
      where we used it. Here we go. We have
      7:33:08
      our sheet content. We probably just want
      7:33:10
      this to be overflow y auto. That should
      7:33:13
      allow us to scroll. There we go. And now
      7:33:14
      we can scroll through all the different
      7:33:16
      content inside of here, which is exactly
      7:33:17
      what we want to be able to do. Now that
    </chapter>
    <chapter title="AI search capabilities" start_time="7:33:19">
      7:33:19
      we have all that done, I think the next
      7:33:20
      step that we kind of want to work on is
      7:33:21
      going to be our AI search functionality.
      7:33:23
      Because right now we don't have anything
      7:33:24
      for our AI search. And I think since
      7:33:26
      we're on the trend of doing AI related
      7:33:27
      stuff, this is a great place for us to
      7:33:29
      jump into. So let's kind of close out of
      7:33:30
      everything that we're working on
      7:33:31
      currently. I want to create a brand new
      7:33:33
      page for this AI search. So, we'll just
      7:33:34
      come in here with a brand new folder, AI
      7:33:37
      search, and we'll create a page.tsx
      7:33:40
      inside of there. And also in our
      7:33:41
      sidebar, we're going to need to create
      7:33:42
      an AI search folder, and we're going to
      7:33:45
      need to put a page in here as well. Now,
      7:33:47
      the sidebar portion of this is going to
      7:33:49
      be very easy because we don't have a
      7:33:50
      custom sidebar. So, I'm just going to
      7:33:51
      return null as a sidebar for this
      7:33:53
      because we don't have a custom sidebar.
      7:33:55
      Otherwise, for our actual AI page, we
      7:33:57
      can export a function. Make sure this is
      7:33:59
      a default function, AI search page.
      7:34:04
      There we go. And we can just return
      7:34:06
      null. And hopefully we should at least
      7:34:08
      see something on our screen if we
      7:34:09
      refresh our page. There we go. You can
      7:34:10
      see we have nothing on our sidebar. And
      7:34:12
      we're on that AI search page. Now, for
      7:34:14
      this particular page, we're just going
      7:34:15
      to render this inside of a div. So,
      7:34:16
      we'll give it a class name, padding
      7:34:17
      four, flex the items in the center.
      7:34:20
      Whoops. Yeah, center. There we go.
      7:34:22
      Justify in the center. And we'll set the
      7:34:25
      minimum height to be screen.
      7:34:28
      There we go. That's just going to center
      7:34:30
      everything in the center for us. And we
      7:34:31
      can just put some random text inside of
      7:34:32
      here. And you can see we're just dead
      7:34:34
      center inside of our screen. Now, we do
      7:34:35
      have a problem with scrolling because of
      7:34:36
      this nav bar at the top. So, I think if
      7:34:38
      I change this to full, we should have it
      7:34:39
      be centered without any scrolling. And I
      7:34:40
      believe even on larger screen sizes, if
      7:34:42
      I just zoom this out, you can see it's
      7:34:43
      still centered for us. So, it does look
      7:34:44
      like it's working across all screen
      7:34:46
      sizes, which is great. Next thing that I
      7:34:47
      want to do is I want to render out a
      7:34:49
      card that's going to contain all that
      7:34:50
      information. So, this card, we're just
      7:34:52
      going to say it's going to have a class
      7:34:53
      name. Max width is going to be 4XL. So,
      7:34:56
      we have that card showing up. And then,
      7:34:57
      we need to put some content obviously
      7:34:59
      inside the card as you can see here. So,
      7:35:01
      what we're going to do is first of all
      7:35:02
      make it so it's an async load because we
      7:35:04
      only want people to do an AI search if
      7:35:06
      they have an account on our page because
      7:35:08
      this is consuming resources and costing
      7:35:10
      us money. So, we want to make sure the
      7:35:11
      user at least has an account so they're
      7:35:12
      more likely to actually apply for jobs.
      7:35:14
      So, we're going to come in here with an
      7:35:16
      async if. And for this async if, the
      7:35:18
      condition is going to be a rather simple
      7:35:20
      condition of do we have a user? So,
      7:35:21
      we'll come in here await current user.
      7:35:25
      Whoops. Get current user.
      7:35:28
      There we go. And we want to just make
      7:35:30
      sure that this is not equal to null. So
      7:35:31
      we're going to get the user ID from
      7:35:32
      that.
      7:35:34
      And I might as well just put this on a
      7:35:35
      new line to make it a little bit easier.
      7:35:39
      So we'll say whoops, there we go. Const
      7:35:42
      user ID is equal to that. Move that
      7:35:46
      down. And we'll just say return user ID
      7:35:50
      is not equal to null. So we only want
      7:35:52
      them to do this particular condition if
      7:35:54
      the user ID is not equal to null. We'll
      7:35:56
      close that off. So at least we have some
      7:35:57
      formatting going on. Next thing I want
      7:35:59
      to do is add in a loading fallback. So
      7:36:01
      we'll just say loading fallback like
      7:36:03
      this. And we'll use our loading swap.
      7:36:05
      And this is so that we have our
      7:36:06
      container be the exact same size as it
      7:36:08
      is before. So what we're going to do is
      7:36:10
      we're going to create a simple function
      7:36:11
      right here. Function. Make sure I close
      7:36:14
      this off. And this is just going to be
      7:36:17
      AI card. Doesn't matter what it is for
      7:36:19
      now. It'll just return null. But
      7:36:21
      essentially I want to render this AI
      7:36:23
      card in here. And then for my loading
      7:36:25
      swap, I want to render the AI card as
      7:36:28
      like the background element. I'll show
      7:36:29
      you what I'm talking about. We'll close
      7:36:31
      off this loading swap.
      7:36:33
      Render my AI card. But for my loading
      7:36:36
      swap, I'm going to say that it's always
      7:36:37
      in the loading state. So, we're going to
      7:36:38
      say is loading true. Just like that. So,
      7:36:40
      now if I give that a quick save, this AI
      7:36:42
      card, we can just put some text inside
      7:36:44
      of here. So, at least it renders
      7:36:45
      something out. And you can see the exact
      7:36:46
      size of my card. Now, if we were in the
      7:36:49
      failure state, it's going to render this
      7:36:50
      loading section right here for the
      7:36:52
      loading fallback. Now, I want to just
      7:36:53
      show you what that loading fallback
      7:36:55
      would look like. So, instead, I'm going
      7:36:56
      to make the loading fallback the only
      7:36:58
      thing that loads. And we'll put the AI
      7:36:59
      card up here as the fallback. So, now
      7:37:01
      you can see when I'm loading that my
      7:37:02
      loading spinner is the exact same size
      7:37:04
      of whatever is in my AI card. If I add
      7:37:06
      more text inside of here, you can see
      7:37:07
      that my loading section grows in size.
      7:37:09
      So, I know that my loading will always
      7:37:11
      be the exact same size as my content.
      7:37:13
      This is really nice because often when
      7:37:14
      you're doing skeleton loaders, the
      7:37:16
      skeleton loader is one size and then
      7:37:17
      when your content loads, it changes
      7:37:19
      size. This allows us to make sure our
      7:37:21
      content is the same size when it's
      7:37:22
      loading and when it's not loading
      7:37:24
      because the difference between whether
      7:37:25
      or not we have a current user or not
      7:37:27
      does not change what our content looks
      7:37:28
      like. Our content will look the same no
      7:37:29
      matter what. So, we can actually
      7:37:31
      pre-render that content kind of behind
      7:37:32
      the scenes. So, we'll go back to what we
      7:37:34
      had before where we have the correct
      7:37:35
      locations for both of these different
      7:37:37
      things. And now we can specify what we
      7:37:39
      want to render inside of our AI card.
      7:37:41
      So, this is going to be a card header
      7:37:44
      with a card title. Card title will say
      7:37:47
      AI search. We're then going to have a
      7:37:50
      card description. And inside of here,
      7:37:52
      this can take a few minutes to process.
      7:37:56
      So, please be patient. And essentially,
      7:37:58
      we just want to let them know, hey, you
      7:37:59
      know what? This takes a while. This is
      7:38:00
      AI. It's not going to be instantaneous.
      7:38:02
      Below our header, we then want to have
      7:38:04
      our content for our card.
      7:38:07
      Just like that. We should probably wrap
      7:38:09
      this inside of some fragments.
      7:38:11
      There we go. Make sure I import card
      7:38:14
      content. And then inside here, we want
      7:38:16
      to have a job listing AI search form,
      7:38:19
      which is a component that we're going to
      7:38:20
      create for doing all of our different AI
      7:38:21
      search related stuff. Finally, I'm going
      7:38:22
      to be creating a simple component called
      7:38:24
      no permission. And this is just going to
      7:38:25
      render if they don't have permission.
      7:38:27
      And essentially, all this says is, hey,
      7:38:28
      permission denied. You need to create an
      7:38:30
      account before using the AI search. So,
      7:38:32
      we can just kind of come all the way up
      7:38:33
      here in the otherwise section and we can
      7:38:36
      render out that no permission component.
      7:38:39
      So, if they don't have permission, it'll
      7:38:40
      render that out instead. And we can
      7:38:41
      actually see what that looks like by
      7:38:43
      just coming into here real quick. We'll
      7:38:44
      make this equal to null and we'll just
      7:38:47
      comment out this line. Yeah, maybe we
      7:38:48
      don't even need to comment out. You can
      7:38:49
      just see it says permission denied. You
      7:38:50
      need to create an account before using
      7:38:52
      this. And we click sign up and it'll
      7:38:53
      bring us to that login page. But
      7:38:54
      obviously, we're already signed in. So,
      7:38:56
      it's just going to bring us back to this
      7:38:57
      page. So, let's change this back to not
      7:38:58
      equal to null. And now what we can do is
      7:39:01
      we can work on this job listing AI
      7:39:02
      search form. Now, this search form is
      7:39:04
      going to be relatively simple because we
      7:39:05
      really only have one input on our entire
      7:39:07
      page. So, here we go to our features
      7:39:09
      inside of job listings components. I'm
      7:39:11
      going to create a brand new component
      7:39:12
      with that name.
      7:39:14
      export this function.
      7:39:18
      There we go. This is going to be a
      7:39:19
      client component.
      7:39:22
      There we go. And we just want to get
      7:39:23
      started by saying form is equal to use
      7:39:25
      form. Pretty much what we do in all of
      7:39:26
      our forms. We're going to have a
      7:39:28
      resolver. And that's going to be a zod
      7:39:31
      resolver. And then we're going to pass
      7:39:32
      in our job listing AI search schema,
      7:39:35
      which we're going to create in just a
      7:39:36
      second. So, let's go ahead and create
      7:39:38
      that in our actions in our schemas all
      7:39:40
      the way down at the bottom. export a
      7:39:43
      constant variable with that name and
      7:39:45
      that's going to be a ZOD object. So
      7:39:47
      we'll say Z.object and this is going to
      7:39:49
      be a relatively simple object because we
      7:39:51
      only have one form field. So it's a
      7:39:52
      query which is going to be a string with
      7:39:55
      a minimum value of one and it'll just
      7:39:57
      say required. There we go. That's all
      7:39:59
      we're going to do for that AI search
      7:40:00
      form. So we can come back into here and
      7:40:02
      we can make sure we import that and then
      7:40:04
      we can specify our default values. And
      7:40:06
      our default value for this is just going
      7:40:07
      to be query which is an empty string.
      7:40:08
      Now we might as well put that on one
      7:40:09
      line. There we go. Then we can create a
      7:40:11
      function for onsubmit
      7:40:14
      which is going to be an async function.
      7:40:17
      We're going to make sure it takes in
      7:40:19
      some data. So we're going to say z.infer
      7:40:22
      type of joblisting ai search schema.
      7:40:25
      There we go. And we'll just console.log
      7:40:27
      our data for now.
      7:40:31
      There we go. And now we can move on to
      7:40:33
      actually rendering out what our form is
      7:40:34
      going to look like. So let's get that
      7:40:36
      form component.
      7:40:38
      pass it in all of our form data and then
      7:40:40
      we can render our actual form with an
      7:40:42
      onsubmit.
      7:40:44
      This is form.andsubmit where we pass in
      7:40:46
      our onsubmit and we'll give it those
      7:40:49
      class names that we always do of space
      7:40:51
      y6 just to space things out. That's
      7:40:53
      going to space out our button from our
      7:40:55
      actual form element. Now the next thing
      7:40:56
      we need to do is to create a form field
      7:40:58
      for our text area. So I'm going to copy
      7:41:00
      this form field over because it's
      7:41:01
      relatively straightforward. So, we can
      7:41:02
      come into here, make sure I spell
      7:41:04
      onsubmit properly, and then let's import
      7:41:06
      all these different components we're
      7:41:08
      going to use, and then I'll explain
      7:41:09
      exactly what each one of these different
      7:41:10
      pieces of code does. I believe we're
      7:41:12
      going to need to create our text area
      7:41:14
      component. So, we're going to need to
      7:41:15
      import that
      7:41:17
      from shad CN. So, let's just go up to
      7:41:19
      where we have that text area. There we
      7:41:22
      go. And of course, we'll probably need
      7:41:24
      to force install that.
      7:41:26
      Actually, maybe not. It's looking like
      7:41:28
      it's potentially running. There we go.
      7:41:29
      That actually installed without needing
      7:41:30
      to force install. So now we can move on.
      7:41:32
      We can import that. And essentially all
      7:41:34
      this is doing is everything we've done
      7:41:35
      with normal forms before. We have a
      7:41:36
      label. We have our control which is this
      7:41:38
      text area. We give it a minimum height
      7:41:39
      so that at least it gives us a little
      7:41:40
      bit of spy size. And then we give a
      7:41:42
      description of what we want the user to
      7:41:43
      do. Telling them, hey, give us a long
      7:41:45
      description of your skills, experience,
      7:41:46
      and all that other stuff. Then what we
      7:41:48
      can do down here is we can provide a
      7:41:50
      button. Make sure we get the correct
      7:41:52
      button. And this button is actually the
      7:41:53
      same as every form submit button we've
      7:41:55
      done. We give it a type submit class
      7:41:56
      name of full. Make sure it's disabled
      7:41:58
      when the form is submitting. and we
      7:41:59
      loading swap in our text based on if
      7:42:01
      it's loading or not. So now we give that
      7:42:03
      a quick save. Of course, we need to
      7:42:05
      import the form here and that should be
      7:42:07
      everything to actually show our form on
      7:42:08
      the page. You can see we have our query.
      7:42:09
      It is resizable, but it has a minimum
      7:42:11
      size, which is perfect. And we can type
      7:42:13
      in whatever we want for an AI based
      7:42:14
      search query. Now, what we're going to
      7:42:15
      do is we're going to scroll all the way
      7:42:16
      back up to our onsubmit section for that
      7:42:18
      form. So, let's go into the form, go to
      7:42:20
      our onsubmit, and what I want to do
      7:42:21
      inside of here is I want to essentially
      7:42:23
      call a server action that's going to do
      7:42:24
      that AI search for us. So, we're going
      7:42:26
      to say results is equal to await. get AI
      7:42:28
      job listing search results. I'm going to
      7:42:32
      pass in our data for that. That's a
      7:42:34
      function we're going to create. If
      7:42:35
      resultserror, so if we have an error,
      7:42:38
      then we want to just render out a toast
      7:42:39
      letting the user know toast.
      7:42:42
      Is going to be results message. We can
      7:42:45
      return. Otherwise, what we're going to
      7:42:47
      do is this is going to return to us our
      7:42:48
      job listing IDs, which we can use down
      7:42:50
      here. So, we'll just say to-do to handle
      7:42:52
      that specific section next because we
      7:42:53
      need to create this function first
      7:42:54
      before we can do anything. So, let's go
      7:42:56
      into our features. This is going to be
      7:42:58
      our job listings in our actions. Scroll
      7:43:00
      all the way down to the very bottom so
      7:43:01
      we can create a brand new one. We're
      7:43:03
      going to say export
      7:43:06
      async function. Just like that. This
      7:43:09
      function is specifically going to take
      7:43:10
      in our unsafe data. That's going to be
      7:43:12
      from our schema. Pretty much what we've
      7:43:14
      done with all of our different forms.
      7:43:15
      Then what we want to do is we want to
      7:43:17
      parse that schema data. So what we're
      7:43:18
      going to do is we're going to parse that
      7:43:20
      schema by passing in our unsafe data.
      7:43:21
      And we're going to begin parsing it
      7:43:23
      against that schema. If success is not
      7:43:25
      true, well, we have some type of error.
      7:43:27
      So, we're just going to return error
      7:43:29
      true message. There was an error
      7:43:34
      processing your search query. There we
      7:43:37
      go. Next up we need to do is to be able
      7:43:38
      to get our user. So, we can come in
      7:43:40
      here. We can call get current user. Just
      7:43:42
      like that. And you can see if we don't
      7:43:44
      have a user, we're essentially saying,
      7:43:45
      hey, you need an account to be able to
      7:43:46
      access this particular AI. Then, we're
      7:43:49
      going to be getting all the job
      7:43:50
      listings. Now, this is something
      7:43:52
      depending on your use cases for your AI,
      7:43:53
      you could limit the amount of job
      7:43:54
      listings you put in here, only put the
      7:43:56
      recent ones, whatever you want to try to
      7:43:57
      limit the amount of tokens you're
      7:43:58
      sending because this could send a ton of
      7:44:00
      information if you have lots and lots of
      7:44:02
      job listings. So, we're going to try to
      7:44:03
      pair down this information as much as
      7:44:05
      possible. So, we're going to call this
      7:44:06
      get public job listings. Just like that.
      7:44:10
      This is going to give us all of our
      7:44:11
      public job listings. And we're going to
      7:44:12
      create a function called get public job
      7:44:15
      listings. And again, you can try to pair
      7:44:17
      this down as much as you want to make it
      7:44:18
      as small as possible. Now, for our case,
      7:44:20
      I'm not going to really modify or bother
      7:44:22
      pairing that down. We're just going to
      7:44:23
      get all the different job listing
      7:44:25
      information, and we'll use it just like
      7:44:26
      this. So, this just gets me all the
      7:44:28
      public job listings available. So, this
      7:44:30
      right here, we might as well call all
      7:44:32
      listings. There we go. And then I'm
      7:44:34
      going to create a function that's going
      7:44:35
      to give us our matched listings, and
      7:44:38
      that's going to be called get matching
      7:44:41
      job listings. We're going to be passing
      7:44:43
      it in the query that the user passed in.
      7:44:45
      That's our AI query that we want to
      7:44:46
      prompt the AI with. We're going to be
      7:44:48
      passing in all the different listings as
      7:44:50
      well as we're going to pass in a maximum
      7:44:52
      number of jobs of 10 just so it doesn't
      7:44:56
      return to us like a million jobs. It's
      7:44:58
      going to return to us the 10 jobs that
      7:44:59
      they are most equipped to handle with
      7:45:01
      their particular AI search and
      7:45:02
      qualifications. Now, this get matching
      7:45:04
      job listings function is going to be an
      7:45:05
      AI based function. So, we're going to
      7:45:07
      just minimize this down, go into our
      7:45:09
      section for our source for services,
      7:45:11
      ingest AI, and we're going to create a
      7:45:13
      function for this. And this is going to
      7:45:14
      kind of show you other use cases for the
      7:45:16
      AI where it's like a one-off
      7:45:17
      transactional thing, but you want to
      7:45:18
      have some dynamic prompts and so on. So,
      7:45:20
      what we can do inside of here is export
      7:45:22
      an async function with that particular
      7:45:25
      name. We're going to give it our prompt,
      7:45:27
      which is a string. We're also going to
      7:45:29
      give it the job listings that we're
      7:45:30
      matching against. And that is going to
      7:45:32
      come from a specific type we're going to
      7:45:33
      create. So, we'll say type of listing
      7:45:36
      schema.
      7:45:38
      And that's a type that we're going to
      7:45:39
      create up here. Listing schema. And
      7:45:42
      that's going to be a Z.Object.
      7:45:45
      Make sure we import zod. Just like that.
      7:45:47
      And we'll pass in some information into
      7:45:49
      that to make it work like we want it to.
      7:45:50
      And then lastly, we're going to have
      7:45:52
      some options for the max number of jobs.
      7:45:54
      And by default, that's going to be an
      7:45:56
      optional parameter. So we'll say max
      7:45:58
      number of jobs is going to be an
      7:46:01
      optional number because we could return
      7:46:03
      all the jobs possible or we could just
      7:46:04
      return some of the jobs that are
      7:46:06
      possible. And let me make sure I spell
      7:46:07
      that properly. There we go. Now, for our
      7:46:09
      schema up here, I'm essentially defining
      7:46:10
      only the keys that we actually want to
      7:46:12
      pass along to again limit the amount of
      7:46:14
      tokens that we're using. So, I'm going
      7:46:15
      to paste in what this looks like. We'll
      7:46:17
      just do a quick import on these enums
      7:46:19
      because this is kind of something we've
      7:46:20
      already seen before. I'll go through
      7:46:21
      really quickly any major differences,
      7:46:23
      but we're essentially saying we have the
      7:46:24
      ID, we have the title, we have the
      7:46:25
      description, we have the wage, the wage
      7:46:27
      interval, the state, the city, the
      7:46:29
      experience level, the type, and the
      7:46:30
      location requirement. essentially the
      7:46:32
      minimum requirements that someone would
      7:46:33
      need to determine if a job is a good fit
      7:46:35
      for them or not. Then we're going to
      7:46:37
      even take this a step further by
      7:46:38
      essentially removing all of the null
      7:46:40
      values so we don't pass along null
      7:46:41
      values to our API for for our AI, sorry,
      7:46:44
      because it doesn't make sense to pass
      7:46:45
      along those null values. So to do that,
      7:46:47
      we're going to come in here and we're
      7:46:48
      going to create our agent and that'll be
      7:46:49
      where we actually do all of our
      7:46:50
      different parsing. So we're going to say
      7:46:51
      create agent that's coming from agent
      7:46:53
      kit. We're going to give our agent a
      7:46:55
      name. This is going to be our job
      7:46:59
      matching agent. And again, we're going
      7:47:01
      to give it a description because that is
      7:47:02
      what's used by other AIS if you match
      7:47:04
      them together inside of a larger
      7:47:05
      network. So, we'll say it's an agent for
      7:47:08
      matching users with job listings.
      7:47:12
      Then, we're going to create our system
      7:47:13
      prompt. So, we'll come in here with our
      7:47:14
      system. And this system prompt is going
      7:47:16
      to be dynamic. It's going to take in
      7:47:17
      some of the information we have passed
      7:47:18
      up here. So, for our system prompt, I'm
      7:47:20
      actually going to copy over the entire
      7:47:22
      thing and then I will explain exactly
      7:47:24
      what it's doing. So, I'll paste this in.
      7:47:26
      It's a rather large prompt. So you can
      7:47:28
      see it says you are an expert at
      7:47:29
      matching people with jobs based on their
      7:47:30
      specific experience and requirements.
      7:47:32
      Most of the time I like to give a prefix
      7:47:34
      of what the AI is supposed to be good
      7:47:35
      at. And then I say what it's going to
      7:47:37
      expect. The provided user prompt will be
      7:47:38
      a description that can include
      7:47:39
      information about themselves as well as
      7:47:41
      what they are looking for in a job. Then
      7:47:43
      if we have a maximum number of jobs, I
      7:47:45
      specify you are only to return the
      7:47:47
      maximum number of jobs. So up to 10 jobs
      7:47:49
      or return all jobs that match the
      7:47:51
      requirements. So we change this prompt
      7:47:52
      based on what the max number of jobs is.
      7:47:54
      Then I'm telling the AI what to I'm
      7:47:56
      saying specifically return the jobs as a
      7:47:57
      commaepparated list of job ids. That way
      7:48:00
      I can use that information to send along
      7:48:02
      queries and search pars and so on. If
      7:48:03
      you cannot find any jobs that match the
      7:48:05
      user prompt, return the text no jobs.
      7:48:07
      And we're just going to create that text
      7:48:08
      up here. No jobs. And that'll just say
      7:48:11
      no jobs or something like that. There we
      7:48:13
      go. Doesn't matter what the text really
      7:48:14
      says. Here is the JSON array of
      7:48:16
      available job listings. And this is
      7:48:17
      where I'm pairing down my job listings.
      7:48:19
      So you can see here I'm getting my
      7:48:20
      listing and transforming it by taking
      7:48:22
      all my normal listing properties and
      7:48:23
      anything that could be null I'm making
      7:48:25
      sure I pass along as undefined instead.
      7:48:27
      And that removes it from my listing. So
      7:48:29
      if a value is undefined, it will not get
      7:48:31
      passed along when we stringify it as
      7:48:33
      JSON. So this just allows me to remove
      7:48:35
      things that are not needed to help pair
      7:48:36
      down the amount of tokens I send across
      7:48:38
      to my AI. So really all this prompt is
      7:48:40
      doing is saying, hey, you're going to be
      7:48:41
      expecting some information from a user.
      7:48:43
      Give them this number of jobs and here's
      7:48:45
      all the jobs that you can give them of.
      7:48:47
      So here's a list of all the jobs to look
      7:48:49
      through and then give them only the max
      7:48:50
      number of jobs that we want. Finally, we
      7:48:52
      need to specify what model we're using.
      7:48:54
      In our case, we're going to be using
      7:48:55
      Gemini as our model. So we'll go inside
      7:48:57
      of here and we'll just import that like
      7:48:59
      that. And now what we can do is we can
      7:49:00
      use this model because we still haven't
      7:49:02
      given it a user prompt. We've just given
      7:49:03
      it the model itself and said, "Hey,
      7:49:05
      here's your agent. Here's your system
      7:49:06
      prompt. Now we want to go ahead and run
      7:49:08
      this particular model." So we can say
      7:49:10
      agent.run. And we can pass it along the
      7:49:12
      prompt that user passed in. So, it's
      7:49:14
      going to take our system prompt as well
      7:49:15
      as the prompt the user passed in,
      7:49:16
      combine these together, and give us the
      7:49:18
      list of jobs that match them the best.
      7:49:20
      So, let's go ahead and we're going to
      7:49:21
      say const result is equal to calling a
      7:49:24
      wait on that. Now, the way this result
      7:49:25
      returns to us is an agent result. And we
      7:49:27
      really only care about getting the last
      7:49:29
      output message. So, we're going to
      7:49:30
      create a helper function for doing that
      7:49:32
      for us called get last output message.ts
      7:49:36
      because we're going to use this
      7:49:37
      potentially in multiple places. So,
      7:49:39
      we're going to export that function.
      7:49:40
      It's going to take in an agent result.
      7:49:42
      That's essentially what our AI returns
      7:49:43
      to us. Every single agent inside of
      7:49:45
      agent kit is going to return this
      7:49:47
      particular thing. And I want to get the
      7:49:48
      last message from it. That's just going
      7:49:51
      to be result.output and we want to get
      7:49:53
      the last one. So it's at the negative
      7:49:55
      one index. Then if our last message is
      7:49:58
      equal to null, for example, it didn't
      7:49:59
      return anything. Or our last message.ype
      7:50:02
      is not equal to text, then I don't care
      7:50:04
      about it. So we're just going to return
      7:50:05
      null. Essentially, I don't care about a
      7:50:07
      message unless it's a type message
      7:50:08
      because we could have like tool calls
      7:50:10
      and tool results. Those aren't important
      7:50:11
      to me. I only want the text the AI
      7:50:13
      actually outputs back to us. Then we're
      7:50:16
      going to get the type of our last
      7:50:17
      message content. And we want to make
      7:50:19
      sure that's equal to a string because it
      7:50:20
      could be multiple things. As you can
      7:50:22
      see, it could be a string or it could be
      7:50:23
      a text content. So if it's a string, I
      7:50:25
      just want to return my last
      7:50:26
      message.content and I want to trim it.
      7:50:28
      So we get rid of any new lines and so
      7:50:29
      on. Otherwise, I want to take my last
      7:50:31
      message.content.
      7:50:33
      If it's an array, I want to join it on
      7:50:35
      the new line character and then I want
      7:50:37
      to trim it after that. So essentially
      7:50:39
      all that I'm doing here is I'm
      7:50:40
      converting my last message into a single
      7:50:42
      string that I can use anywhere inside my
      7:50:44
      application. This is just a nice little
      7:50:46
      handy helper method that we can use. Now
      7:50:48
      what we can do is we can do that by
      7:50:49
      saying last message is equal to calling
      7:50:52
      that function with a result passed in
      7:50:54
      and it's going to convert our result
      7:50:55
      from this agent result to a single
      7:50:57
      string or undefined. Now what we can do
      7:50:59
      down here is if our last message is
      7:51:01
      equal to null, maybe something went
      7:51:03
      wrong. Or if our last message equals no
      7:51:05
      jobs, well, that means that it returned
      7:51:07
      no results at all. So, we can just
      7:51:09
      return an empty array. Otherwise, we're
      7:51:11
      going to take our last message, we're
      7:51:13
      going to split it on a comma because we
      7:51:16
      know that it's giving us a
      7:51:17
      commaepparated list. We want to get rid
      7:51:19
      of any white space, so we're going to
      7:51:20
      take our job ID and we're just going to
      7:51:22
      trim it.
      7:51:24
      There we go. And then I want to filter
      7:51:27
      out anything that's not there. So, we're
      7:51:29
      going to say filter boolean.
      7:51:30
      Essentially, this is going to remove any
      7:51:31
      empty strings. So if we had like text
      7:51:32
      that was an empty string somewhere in
      7:51:34
      there like after a comma before a comma
      7:51:35
      this will remove that. So essentially it
      7:51:37
      just gives us an array of job ids that
      7:51:38
      this AI found for us. So now we can
      7:51:40
      specifically go back to this search form
      7:51:42
      or actually not to the search form to
      7:51:44
      the action itself and we can import this
      7:51:45
      to get all of our matching job ids. And
      7:51:47
      what we can do with this information is
      7:51:49
      we can first check to see if our matched
      7:51:51
      listings length is equal to zero. If it
      7:51:53
      is then we didn't get any jobs. So we
      7:51:54
      can just let them know hey no jobs match
      7:51:56
      your criteria. Otherwise we return that
      7:51:58
      there was no error and we return the
      7:51:59
      matching job IDs. Now, if we look at
      7:52:01
      this particular function, you can see
      7:52:02
      the return type is going to be an error,
      7:52:04
      a message, and then optionally some job
      7:52:06
      ids. And down here, the message is
      7:52:08
      optional. So, it's kind of a weird type.
      7:52:09
      We want to manually type this because we
      7:52:11
      only want to return one of two different
      7:52:13
      things. We want to return a promise that
      7:52:15
      is going to be an error of true and a
      7:52:18
      message of string.
      7:52:21
      If I can spell properly. There we go.
      7:52:24
      or we want to return a promise where
      7:52:27
      error
      7:52:29
      is false
      7:52:31
      and our job ids
      7:52:34
      is going to be an array of strings.
      7:52:36
      There we go.
      7:52:38
      Make sure I put that parenthesy inside
      7:52:39
      of there or this bracket inside of
      7:52:41
      there. And the reason that I'm breaking
      7:52:42
      this up like that is that way when we
      7:52:44
      use this API, we know exactly what's
      7:52:46
      going to be returned because otherwise
      7:52:48
      we had like an optional message and
      7:52:49
      optional job ids. Now I know if I have
      7:52:51
      an error then I have a message and if I
      7:52:52
      have no error I have job ids. Now I do
      7:52:55
      actually want to change this by instead
      7:52:56
      putting this inside of here cuz I'm
      7:52:57
      always returning a promise. I
      7:52:59
      essentially just want to say I return a
      7:53:00
      promise that is either going to be an
      7:53:02
      error true message string or it's going
      7:53:04
      to be an error false job ids. It just
      7:53:06
      makes my code a little cleaner. They
      7:53:07
      both do the same thing but this I find a
      7:53:09
      little easier to read. Now let's put in
      7:53:10
      this bracket that we accidentally
      7:53:12
      deleted. And there we go. Now we have
      7:53:13
      this returned to us as a good type. So
      7:53:15
      we look over results. If I make sure I
      7:53:17
      import this properly. There we So now if
      7:53:19
      we hover over results, you can see it's
      7:53:20
      either error true with a message or
      7:53:21
      error false with job IDs. Now let's
      7:53:23
      import toast since it looks like we
      7:53:25
      didn't import that. And down here, we
      7:53:26
      can actually use that job ID
      7:53:28
      information. So what we want to do is we
      7:53:29
      want to be able to reroute us back to
      7:53:30
      the job listing page by pushing in the
      7:53:32
      job listing IDs. So I'm going to say
      7:53:34
      const router equals use routouter.
      7:53:38
      Make sure it's use not user. There we
      7:53:40
      go. And now what I can do down here is I
      7:53:42
      can say router.push. And I specifically
      7:53:45
      want to push us to the homepage with a
      7:53:47
      question mark because I want to get some
      7:53:48
      search params. So we'll say prams.ring.
      7:53:52
      That's going to be our search params. So
      7:53:54
      let's say params is equal to new URL
      7:53:56
      search params. And we're going to say
      7:53:58
      for each one of our job ids. Whoops. Job
      7:54:02
      ids. We want to push that into the
      7:54:03
      thing. So for each one we want to take
      7:54:05
      our params. We want to append along a
      7:54:08
      job ids with that ID. Just like that. So
      7:54:11
      essentially, if I have three job ids
      7:54:13
      returned, I have three parameters with
      7:54:14
      job ids inside of my URL search params.
      7:54:17
      And since earlier we already implemented
      7:54:19
      the ability to do filtering based on job
      7:54:21
      IDs, we should have this all already
      7:54:23
      working for us. And now we can just type
      7:54:24
      in a query and it should return to us
      7:54:26
      jobs that fit that specific query. So
      7:54:27
      now before we get too far into that, I
      7:54:29
      want to go back to my employer dashboard
      7:54:30
      to make sure we at least have two job
      7:54:32
      listings that have different information
      7:54:33
      inside them. Not sure why that error
      7:54:35
      showed up there. Just some weird caching
      7:54:36
      stuff probably. But here we have a
      7:54:38
      software engineering full stack job. For
      7:54:40
      this one, I want to just make it super
      7:54:41
      simple and basic. We're just going to
      7:54:42
      come in here. We're going to say it's
      7:54:44
      going to be in mobile developer
      7:54:49
      role. There we go. And we're going to
      7:54:51
      make this one for senior developers. And
      7:54:53
      we can just leave this description
      7:54:54
      mostly blank. We'll say for only
      7:54:57
      experienced
      7:54:59
      mobile devs just so we have two job
      7:55:02
      listings that are very different from
      7:55:03
      each other. This one is specified as a
      7:55:06
      junior level full stack job and this one
      7:55:08
      is specified as a senior level mobile
      7:55:10
      developer role. So at least we have two
      7:55:12
      very different jobs that we can look
      7:55:14
      through. So now inside of my AI search I
      7:55:16
      want to say I am looking for an
      7:55:18
      entrylevel web developer job. There we
      7:55:22
      go. Super basic. Obviously you would
      7:55:24
      want to put more in there if you're
      7:55:25
      doing a real AI search. But we can come
      7:55:26
      in here and we can click search. It's
      7:55:28
      going to take us a little bit of time.
      7:55:29
      But you can see it has now told us we
      7:55:31
      have one job with this job ID that
      7:55:32
      matches our requirements. And here is
      7:55:34
      that job ID which again is that software
      7:55:36
      developer full stack webdev job. If I
      7:55:38
      were to go back to my AI search and I
      7:55:40
      say I am looking or I am an experienced
      7:55:45
      mobile developer, we should hopefully
      7:55:48
      see that it's going to return to us that
      7:55:49
      mobile developer job. And there we do
      7:55:50
      mobile developer role. Now obviously if
      7:55:52
      you have more jobs and you have more
      7:55:54
      information you pass into your AI, you
      7:55:55
      can get more sophisticated results. But
      7:55:57
      this is a good example showcasing how we
      7:55:58
      can actually filter our results based on
      7:56:00
      just human readable text. Now, the next
    </chapter>
    <chapter title="User settings page" start_time="7:56:02">
      7:56:02
      thing that I want to work on, which is
      7:56:03
      tying directly into the AI stuff that
      7:56:05
      we've already been working on, is going
      7:56:06
      to be inside of our user settings on the
      7:56:08
      notification setting itself. Obviously,
      7:56:10
      we don't have a page for this yet. So,
      7:56:11
      I'm going to go ahead and implement the
      7:56:12
      page for this so we have everything
      7:56:13
      working. So, we can come over here. We
      7:56:15
      can go to where we have our app jobseker
      7:56:18
      user settings. And we specifically want
      7:56:20
      to have a file called
      7:56:22
      notifications/page.tsx.
      7:56:26
      And we're going to export a default
      7:56:27
      function notifications page.
      7:56:33
      We'll just return null.
      7:56:36
      There we go. And hopefully you can see
      7:56:37
      over here now we have a null page for
      7:56:39
      that and we at least have our
      7:56:40
      notifications tab and we can swap
      7:56:42
      between resume and notifications. Now,
      7:56:43
      as per usual, we're going to wrap pretty
      7:56:45
      much everything in a suspense because
      7:56:46
      we're going to have a suspended
      7:56:47
      component. So, I'm just going to come in
      7:56:48
      here. I'm going to get that wrapped in a
      7:56:50
      suspense and then we'll just work on our
      7:56:51
      suspended component next. In our
      7:56:53
      suspended component, we want to get our
      7:56:55
      user ID. So, we'll just say await get
      7:56:58
      current user. And if we don't have a
      7:56:59
      user, we're going to return null. So, if
      7:57:03
      user ID equals null, we'll actually just
      7:57:05
      return not found cuz that makes more
      7:57:07
      sense. There we go. And then down here,
      7:57:08
      we can actually return the information
      7:57:10
      we want. So, we're going to do a div
      7:57:11
      with a max width of 3XL, MX auto, py8,
      7:57:17
      and we'll also do some px4 just to get
      7:57:20
      this mostly centered in our screen. Then
      7:57:22
      inside of here, we can create an H1.
      7:57:24
      Class name is going to be text 2XL.
      7:57:27
      We're going to make it a bold font. And
      7:57:29
      we'll put some margin on the bottom. And
      7:57:31
      this is just going to say notification
      7:57:33
      settings. There we go. So now we should
      7:57:35
      have that text pop up. Now below that,
      7:57:37
      we're going to create a card. And inside
      7:57:39
      this card, we're going to have some card
      7:57:40
      content.
      7:57:43
      There we go. And inside of here, we're
      7:57:45
      again going to have suspense because
      7:57:46
      we're going to be putting a form inside
      7:57:48
      of here. So we'll just call this form.
      7:57:50
      And we'll just say it's going to be
      7:57:52
      suspended form. There we go. And for
      7:57:54
      this one, we're going to have a
      7:57:55
      fallback. Whoops. Fall back.
      7:57:58
      Actually, the fallback is going to go up
      7:58:00
      here. There we go. Fall back. And this
      7:58:02
      is going to be a loading spinner.
      7:58:06
      Perfect. So, now we have that being
      7:58:07
      rendered. We have our suspended form,
      7:58:09
      which is actually just self-closing
      7:58:11
      because now down here we can have a
      7:58:12
      function suspended form.
      7:58:15
      Make this an async function. And in
      7:58:17
      here, we're going to be getting our
      7:58:18
      notification settings.
      7:58:21
      So, we can call await get notification
      7:58:24
      settings. I don't want to get the global
      7:58:26
      tags or anything. So, we're just going
      7:58:27
      to say get
      7:58:29
      notification settings. There we go.
      7:58:31
      Because we're going to create this as
      7:58:32
      our own function.
      7:58:37
      There we go. We're going to pass in the
      7:58:38
      user ID. So, we can make sure we get
      7:58:40
      that in here. User ID.
      7:58:45
      user ID, which is a string,
      7:58:50
      and user ID. There we go. So, at least
      7:58:51
      we have all that information we passed
      7:58:53
      in. For now, I'll just return null to
      7:58:54
      get rid of any errors. And down here,
      7:58:57
      user ID, which is a string. We can use
      7:58:59
      that to get our information. And I'll
      7:59:01
      just copy over what this is cuz we've
      7:59:03
      done this a million times before. We're
      7:59:04
      essentially just going to query the
      7:59:05
      database specifically for one ID. And we
      7:59:09
      also want to make sure that we're
      7:59:10
      caching this properly. So, we'll get our
      7:59:11
      cache tag information. And there we go.
      7:59:13
      That's getting our notification setting.
      7:59:15
      And now what we can do is we can
      7:59:16
      actually pass that into our form. So we
      7:59:18
      can say notification
      7:59:20
      form. This is going to be notification
      7:59:23
      settings which is going to be equal to
      7:59:25
      our notification settings. There we go.
      7:59:27
      So now we have our form that we can use.
      7:59:29
      And we just need to create that
      7:59:30
      particular component because the rest of
      7:59:31
      this card does everything that we need
      7:59:32
      it to do. So let's scroll all the way
      7:59:34
      down to our featured section for our
      7:59:36
      users. Inside of our components, let's
      7:59:37
      create a brand new component with that
      7:59:39
      name.
      7:59:40
      Export a function with that name. This
      7:59:42
      is going to take in our notification
      7:59:44
      setting. And specifically, the only
      7:59:46
      things that we care about are the new
      7:59:47
      job email notification and the AI prompt
      7:59:50
      categories. So, actually back here, I
      7:59:52
      can even make my query a little bit
      7:59:53
      better by only querying those columns.
      7:59:55
      So, I want to get the AI prompt and I
      7:59:57
      want to get the new email job
      7:59:58
      notifications. Those are the only two
      8:00:00
      columns that I care about for this form.
      8:00:02
      Now, we can import this form and we can
      8:00:04
      go back into the form. And if I just
      8:00:05
      return null,
      8:00:07
      that should at least clean up the errors
      8:00:08
      in this file. And it looks like it did.
      8:00:10
      So now all we have to do is make this
      8:00:11
      actual form work. And just like all of
      8:00:13
      our forms, we're going to make this a
      8:00:14
      client component and we're going to come
      8:00:17
      in here, use form. So we're gonna have a
      8:00:19
      form use form.
      8:00:22
      We're going to pass it in our resolver,
      8:00:24
      which is a ZOD resolver, and we're going
      8:00:26
      to pass it in our user notification
      8:00:29
      settings schema. Just like that. We're
      8:00:32
      going to create this. So let's open up
      8:00:34
      our actions section for this. We
      8:00:36
      actually don't even have one, so we'll
      8:00:37
      create a new file. Actions slash
      8:00:40
      schemas.ts.
      8:00:42
      Paste this in there as a constant
      8:00:44
      variable. And it's going to be a Zod
      8:00:46
      object. And this object only really has
      8:00:48
      two things. Our new job
      8:00:51
      email notifications.
      8:00:54
      That's going to be a boolean.
      8:00:57
      And then we have our AI prompt.
      8:00:59
      And this is just going to be a string
      8:01:01
      because essentially we can do an AI
      8:01:03
      prompt be notified of these new
      8:01:04
      settings. So we want to transform this
      8:01:06
      as well to make sure that we have a null
      8:01:07
      value. It gets rid of it. So, val.trim.
      8:01:11
      If that's equal to an empty string, then
      8:01:13
      we're going to return null. Otherwise,
      8:01:15
      we're going to return our value. And
      8:01:16
      we're going to make sure that this value
      8:01:18
      is nullable. There we go. Make that a
      8:01:21
      function. And perfect. So now we've
      8:01:22
      essentially said that we have an AI
      8:01:24
      prompt that's optional. And we have this
      8:01:25
      new job email notifications. So now we
      8:01:28
      can come back into here, import that. We
      8:01:30
      can get our default values.
      8:01:32
      And our AI prompt is going to be a
      8:01:34
      string. And our new email notifications
      8:01:36
      is going to be false by default. Also,
      8:01:38
      we want to use our notification settings
      8:01:40
      by default if we have those. So, if we
      8:01:41
      have notification settings, use those.
      8:01:43
      Otherwise, fall back to these default
      8:01:44
      settings. Now, what we can do is we can
      8:01:46
      create our onsubmit function.
      8:01:51
      This is going to take in our data which
      8:01:53
      is Z.infer.
      8:01:55
      Make sure I import Z. There we go. It's
      8:01:57
      going to infer this particular schema.
      8:01:59
      Just like that. Oops. Let me make sure I
      8:02:01
      get the schema. There we go.
      8:02:04
      And we can console.log the data. And
      8:02:06
      this has to be a type of. There we go.
      8:02:08
      Now, for this particular form, we're
      8:02:09
      going to show and hide things
      8:02:10
      dynamically based on if we check that
      8:02:12
      checkbox. So, I'm just going to come in
      8:02:13
      here and say our new job email
      8:02:15
      notifications. We're going to make sure
      8:02:16
      we watch that property. So, we can
      8:02:17
      toggle things based on if this is true
      8:02:19
      or false. Now, we can render out our
      8:02:21
      actual form with all of our content
      8:02:23
      inside of it. Pretty much just like
      8:02:24
      we've done for the rest of our
      8:02:25
      application. We're going to add an
      8:02:27
      onsubmit here. That's going to be
      8:02:29
      form.andsubmit.
      8:02:31
      pass in our onsubmit function and the
      8:02:33
      same exact class name which is going to
      8:02:35
      be space
      8:02:37
      y of six.
      8:02:39
      Let's make sure that we close all this
      8:02:40
      off properly.
      8:02:45
      There we go. Now we're going to wrap
      8:02:46
      everything inside of a div. This is
      8:02:48
      going to be kind of emulating a card. So
      8:02:49
      we're going to add a border
      8:02:52
      rounded large padding four shadow small
      8:02:55
      and space Y six just to space the
      8:02:59
      elements out. Then we're going to have a
      8:03:01
      form field. The name on this form field,
      8:03:04
      if we import this properly. Whoops. Form
      8:03:07
      field. There we go. Name on this is
      8:03:10
      going to be our new job
      8:03:13
      email notifications.
      8:03:16
      If we close this off, we should
      8:03:17
      hopefully be able to get some
      8:03:18
      autocomplete on this. There we go. Next
      8:03:20
      thing that we need to do is our control,
      8:03:21
      which is our form. And then finally, our
      8:03:24
      render function to render this out. So
      8:03:26
      we can come in like this with our field.
      8:03:29
      And we essentially want to render out a
      8:03:30
      toggle switch. So we'll get a form item.
      8:03:34
      For our form item, we're going to come
      8:03:35
      in here with a div class name of flex
      8:03:37
      and items center and justify between. So
      8:03:40
      we want to have text on the left and our
      8:03:42
      toggle on the right hand side. Then what
      8:03:44
      we can do is we can create another div
      8:03:45
      for our left-hand side text content.
      8:03:47
      We'll make it so it's relatively close
      8:03:49
      together with only a 0.5 space between
      8:03:52
      our text. And then this is where our
      8:03:54
      form label and description come in. So
      8:03:55
      we'll say daily email notifications
      8:03:59
      and on the lefth hand side it'll say
      8:04:01
      formed or not on the left hand side
      8:04:02
      below it it'll say receive
      8:04:05
      emails about new job listings
      8:04:10
      that match your interests. There we go.
      8:04:15
      Now we have that section that's going to
      8:04:16
      show up on the left as you can see here.
      8:04:17
      We then want to have a form control that
      8:04:19
      shows up on the right and this is going
      8:04:21
      to be our toggle switch. So, we're going
      8:04:23
      to use the switch component, which it
      8:04:24
      looks like we need to install.
      8:04:27
      There we go. We're most likely going to
      8:04:28
      have to force install this. There we go.
      8:04:30
      So, now we can use the switch component
      8:04:32
      directly inside of here. So, let's make
      8:04:35
      sure that it gets installed. We want to
      8:04:37
      specify that checked
      8:04:39
      is going to be equal to our value from
      8:04:41
      our field.
      8:04:43
      And then the unchecked changed is going
      8:04:46
      to be equal to field.onchange.
      8:04:49
      And that's going to be everything for
      8:04:50
      rendering out our switch. So now you can
      8:04:51
      see we have this toggle on the right
      8:04:53
      hand side and the left side hand side we
      8:04:55
      have the text explaining what this
      8:04:56
      toggle does. Now the next thing that we
      8:04:58
      can move on to is going to be the
      8:04:59
      section for actually rendering out our
      8:05:00
      form field for our AI input. So we can
      8:05:03
      minimize down this form field. And what
      8:05:05
      we can do directly below it is if our
      8:05:07
      new job email notifications is checked
      8:05:09
      then we can render out this check or
      8:05:11
      this field down here because we don't
      8:05:12
      want to show this unless they
      8:05:13
      specifically ask for daily email
      8:05:15
      notifications. Now, this one is going to
      8:05:17
      be a form field. And I'm going to copy
      8:05:20
      over some of this stuff. So, we'll come
      8:05:22
      in here. Whoops. Just like that. So, we
      8:05:24
      have our AI prompt. And then we have our
      8:05:26
      form item that we're rendering inside of
      8:05:28
      this. There we go. And it looks like I'm
      8:05:30
      missing a couple brackets here. These
      8:05:33
      ones actually go on the outside. There
      8:05:35
      we go. So, that fixed up all of our
      8:05:36
      brackets. Now, we have our form item.
      8:05:38
      Again, we're going to do kind of similar
      8:05:39
      stuff. We're going to have some spacing
      8:05:40
      between these elements to make them so
      8:05:42
      they're relatively close together. 0.5.
      8:05:45
      So, we're going to have our form label.
      8:05:47
      Our form label is going to say filter
      8:05:49
      prompt, just like that. And then we're
      8:05:51
      going to have a description. I'll just
      8:05:52
      copy over what the description says
      8:05:53
      because essentially it's just saying our
      8:05:54
      AI will use this prompt to filter your
      8:05:56
      job listings and only send you
      8:05:57
      notifications for jobs that meet your
      8:05:59
      actual criteria. Then we can message
      8:06:02
      what our form control is, which is where
      8:06:03
      our text area is going to go. So, we
      8:06:06
      have a text area just like that. And
      8:06:07
      this text area is going to be very
      8:06:08
      similar to our previous text area. So,
      8:06:10
      I'll kind of copy down what the props
      8:06:11
      are for it. Make it self-closing just
      8:06:14
      like that. So, as you can see, we're
      8:06:15
      getting our field value or the default.
      8:06:17
      Our class name gives it a minimum
      8:06:19
      height, and we're giving it a nice
      8:06:20
      placeholder telling people what they
      8:06:22
      should put inside of here. Then, lastly,
      8:06:24
      we need our form description and
      8:06:25
      message. And the message is just the
      8:06:27
      error. And our description just tells
      8:06:28
      them to leave it blank if they want
      8:06:29
      notifications for all new job listings.
      8:06:32
      So, now if we toggle this to be true,
      8:06:33
      you can see we get our filter prompt
      8:06:35
      down here with all the information. And
      8:06:36
      on larger screen sizes, it looks much
      8:06:38
      better, as you can see right here. So,
      8:06:39
      we can easily toggle between these
      8:06:41
      different states. And if they type
      8:06:42
      something into here, it'll actually
      8:06:44
      essentially use that as the AI prompt
      8:06:45
      for our tool. Lastly, for our specific
      8:06:47
      coding section all the way down here at
      8:06:49
      the end of our form, we just need to add
      8:06:50
      in our default button. And this is the
      8:06:52
      exact same button we've been using on
      8:06:53
      all of our forms. So, I'll just copy it
      8:06:55
      in just like that. Now, if we give this
      8:06:57
      quick refresh, that's just something to
      8:06:58
      do with the hot module reloading.
      8:06:59
      Actually, I imported the wrong button is
      8:07:01
      what the problem is. So, let's go all
      8:07:02
      the way up here, get rid of that, and
      8:07:04
      import the correct button. There we go.
      8:07:07
      Now, that should actually fix the
      8:07:08
      particular problem. And there we go.
      8:07:09
      Now, we can toggle between these. And
      8:07:10
      let's just say that I want to get daily
      8:07:12
      email notifications and I'll save my
      8:07:14
      notification settings. And of course,
      8:07:15
      actually that button doesn't work yet
      8:07:16
      because we aren't doing anything inside
      8:07:18
      of our onsubmit. So inside of our
      8:07:19
      onsubmit, all we're going to do is call
      8:07:20
      a function. That's an action. And if we
      8:07:22
      have an error, we're going to render out
      8:07:23
      that error as a toast message.
      8:07:25
      Otherwise, we're going to render out our
      8:07:26
      success as a toast message as well. So
      8:07:28
      let's create this update user
      8:07:29
      notification settings just like we've
      8:07:31
      been doing with all the rest of our
      8:07:32
      actions. So let's go ahead into our
      8:07:34
      actions section. We of course look like
      8:07:36
      we don't have any actions inside of our
      8:07:37
      users. So let's go ahead and we'll
      8:07:38
      create a brand new file. This one is
      8:07:40
      going to be for our user notification
      8:07:43
      settings.ts.
      8:07:45
      And we'll call this user notification
      8:07:46
      setting actions. There we go. We'll
      8:07:49
      paste down that function. Export async
      8:07:52
      function.
      8:07:54
      We'll make sure that this is use server
      8:07:56
      so we know that this can actually be
      8:07:57
      used. We're going to get the data we're
      8:07:59
      going to use inside of here, which is
      8:08:00
      going to be of this type of that schema
      8:08:02
      that we've already used. Infer that from
      8:08:03
      zod. And now we can go ahead and
      8:08:05
      actually just parse that data. And this
      8:08:06
      is something we've done a million times.
      8:08:08
      First of all, we're going to be getting
      8:08:09
      the current user. And if we're not
      8:08:10
      signed in, obviously, you can't update
      8:08:12
      your notification settings. Then, we're
      8:08:13
      going to be parsing this schema to make
      8:08:15
      sure it's correct. And if there's an
      8:08:16
      error, we'll let them know that there
      8:08:17
      was an error trying to parse their data.
      8:08:19
      This is kind of the security checks we
      8:08:20
      put essentially in front of almost every
      8:08:22
      single action. Finally, we're going to
      8:08:24
      call update user notification settings,
      8:08:27
      and we're going to pass in our user ID
      8:08:29
      and our data. And all we need to do is
      8:08:30
      create this function, and we're going to
      8:08:32
      make sure we prefix this or postix that
      8:08:34
      with the name DB so we know it comes
      8:08:35
      from our database. So now we can go into
      8:08:37
      our database section. So database user
      8:08:39
      notification settings and we need to
      8:08:41
      create that function. I'll just kind of
      8:08:42
      copy what we have up here because it's
      8:08:44
      going to be very similar. So we're going
      8:08:45
      to update user notification settings.
      8:08:47
      User ID is going to be a string. Our
      8:08:50
      settings are going to be a partial
      8:08:52
      version of this. Just like that. And
      8:08:55
      then we just want to call update. So
      8:08:57
      we're going to say update passing in our
      8:08:59
      settings. So we're going to set that to
      8:09:00
      our settings. There's no on conflict we
      8:09:02
      need to worry about. And we have our
      8:09:03
      user ID coming in just like that. So
      8:09:05
      that's all we need to do to do our
      8:09:06
      update for this. Now we can come back to
      8:09:08
      here and we can actually import that. So
      8:09:09
      we can say import
      8:09:12
      and we want to convert the name of that
      8:09:13
      and that's going to be coming from at
      8:09:15
      slash and this is going to be our
      8:09:17
      features slash users slashdb
      8:09:22
      slash and that's our user notification
      8:09:23
      settings. There we go. Now this update
      8:09:25
      function is actually going to be
      8:09:26
      slightly different than I originally
      8:09:28
      wrote it. And the reason for that is
      8:09:29
      because we could get to the point where
      8:09:30
      our user doesn't have any notification
      8:09:32
      settings yet. So, we want to do either
      8:09:34
      an update or an insert. Essentially, we
      8:09:36
      just want to call this insert function,
      8:09:38
      but with our user ID specifically passed
      8:09:40
      in and only the table values that we
      8:09:42
      want to update. What we're going to do
      8:09:43
      here is we're actually going to take
      8:09:44
      this and we're going to emit the user ID
      8:09:46
      from this section.
      8:09:48
      There we go. Just so we don't
      8:09:49
      accidentally have that passed in as
      8:09:50
      something we're updating. And then here,
      8:09:52
      we're actually going to do an insert
      8:09:53
      unlike I had mentioned before. So, we're
      8:09:54
      going to insert into the values and we
      8:09:56
      are going to do an on conflict, but this
      8:09:58
      time it's going to be an onconlict do
      8:09:59
      update. So, you can see we're inserting
      8:10:01
      these setting values on conflict. we're
      8:10:03
      doing an update for when our user ID is
      8:10:04
      the conflicting value. Now, in order to
      8:10:06
      make this work, we need to make sure
      8:10:07
      that we pass along our user ID as one of
      8:10:10
      our setting values here. That way, we
      8:10:12
      have all the values that we need to be
      8:10:13
      able to pass along. So, this is just
      8:10:15
      going to make sure that if we don't have
      8:10:16
      any user values, we actually update them
      8:10:18
      properly because for some reason when we
      8:10:20
      created a user, we didn't actually
      8:10:21
      create settings for them. That could
      8:10:22
      happen. This will make sure that solves
      8:10:24
      any of those problems. So, now we should
      8:10:26
      be able to import this particular
      8:10:27
      function. Make sure we get it from the
      8:10:29
      actions folder. Just like that. And it
      8:10:31
      should be returning us a result. So we
      8:10:32
      want to make sure down here we return a
      8:10:35
      success result. So we'll say error false
      8:10:37
      and give it a success response. And that
      8:10:39
      solved all of our different errors.
      8:10:40
      Looks like we have no errors anywhere.
      8:10:41
      So let's actually test to see if this
      8:10:42
      works. We'll just enable this. Click
      8:10:44
      save notifications. Successfully updated
      8:10:46
      your notifications. And now we know at
      8:10:47
      least we should be receiving daily email
      8:10:49
      notifications. Now all we need to do is
      8:10:51
      implement a system to send out these
      8:10:53
      daily email notifications. So, in order
      8:10:54
      to set up these daily email
    </chapter>
    <chapter title="Send user email notifications" start_time="8:10:55">
      8:10:56
      notifications, this is again something
      8:10:57
      that's really well suited to ingest
      8:10:59
      because they have great cron services.
      8:11:00
      So, we can go into ingest into functions
      8:11:02
      and we'll create a brand new one called
      8:11:04
      email.ts. And this will be for sending
      8:11:06
      out all of our different emails. So,
      8:11:07
      we're going to export a constant
      8:11:08
      variable called prepare
      8:11:11
      daily user job listing notifications.
      8:11:16
      This is going to use that ingest
      8:11:17
      function. We're going to call create
      8:11:19
      function and we just need to pass it in
      8:11:22
      our information and specifically what is
      8:11:23
      the event we want to deal with. Well, in
      8:11:24
      our case, we don't have an event. We're
      8:11:26
      going to be using a cron schedule
      8:11:27
      instead. Now, for this cron schedule, we
      8:11:29
      can set up whatever we want. In my case,
      8:11:31
      I want it to essentially be at 7 a.m.
      8:11:33
      every single day. So, we can say 07 that
      8:11:35
      represents the 7th hour. And then we can
      8:11:38
      say that we want it to happen on every
      8:11:39
      single day by putting stars for the day,
      8:11:41
      month, and the year. So, this is just
      8:11:43
      saying at 7:00 a.m. every single day
      8:11:44
      perform this crown job. We can also
      8:11:46
      specify the time zone by saying that we
      8:11:47
      want it to be America, Chicago, that's
      8:11:50
      going to be central time zone. We can
      8:11:51
      use whatever time zone we want, but
      8:11:53
      since this is like a US-based job board,
      8:11:55
      central time zone makes a lot of sense.
      8:11:56
      Now, we also need to specify an ID and a
      8:11:59
      name. And these are just going to be
      8:12:00
      essentially the same as our function
      8:12:01
      name, so it's not super important what
      8:12:02
      that information is. Now, the next thing
      8:12:04
      we need here is our async property for
      8:12:06
      our function. So, let's come in here
      8:12:07
      with our step and our event. Let's
      8:12:10
      create that function. Now, the first
      8:12:12
      thing we need to do is we need to get
      8:12:13
      all of the users notifications. So we
      8:12:15
      can say const get users and this is
      8:12:18
      going to be a step that we run and this
      8:12:20
      is going to be called get users
      8:12:23
      and this is going to get all of our
      8:12:25
      users that have notifications. So we're
      8:12:27
      going to return calling
      8:12:30
      await db.query. Make sure we import
      8:12:32
      that. We want to query the user
      8:12:34
      notification settings table. We want to
      8:12:36
      find all of them
      8:12:39
      and we specifically want to find the
      8:12:40
      ones where they have their notifications
      8:12:43
      enabled. So we'll say user notification
      8:12:45
      settings table dot new email
      8:12:48
      notifications is true. So for anyone
      8:12:50
      that has their notification set to true,
      8:12:52
      we want to access that. We want to get
      8:12:54
      specific columns. We're going to get the
      8:12:56
      user ID.
      8:12:58
      Set that to true.
      8:13:01
      We're going to get that new job prompt.
      8:13:02
      We're going to set that to true. And the
      8:13:04
      AI prompt, we'll set that to true as
      8:13:06
      well. Also, we're going to get
      8:13:07
      information about the user itself. We
      8:13:09
      can send that along in the email. So
      8:13:11
      we'll say that for the user, we want to
      8:13:12
      get their email. so we know where to
      8:13:14
      send it to and we'll get their name so
      8:13:15
      we can put that inside the email message
      8:13:17
      we send to them. So that's going to be
      8:13:19
      all the information for getting the
      8:13:20
      user. The next thing we need to do is
      8:13:21
      get all the job listings that are posted
      8:13:23
      recently. So we'll call this get job
      8:13:25
      listings which equals step.run
      8:13:28
      get recent job listings.
      8:13:35
      Now for this function we're going to do
      8:13:36
      a very similar thing by querying our
      8:13:38
      database. So, we're going to query that
      8:13:40
      table, the job listing table
      8:13:42
      specifically, and we want to
      8:13:44
      specifically find many of them. And we
      8:13:47
      want to get essentially all the job
      8:13:48
      listings that have been posted in the
      8:13:50
      last day. So, we can put in an and query
      8:13:52
      here. And we want to say greater than or
      8:13:54
      equal to because we want to get things
      8:13:55
      that are greater than equal to the most
      8:13:56
      recent day. So, we can say job listing
      8:13:59
      table.posted
      8:14:01
      at. And what we need to do is we need to
      8:14:03
      figure out what was essentially one day
      8:14:05
      ago. Well, the really nice thing is that
      8:14:06
      our event has this TS property, which is
      8:14:09
      the time stamp. And if we have a cron
      8:14:10
      job, that is essentially the exact time
      8:14:12
      their cron job actually executed. So,
      8:14:14
      this would be 7:00 a.m. every single
      8:14:16
      day. So, all we need to do is get one
      8:14:17
      day before this particular time. So,
      8:14:19
      what we can do is we can say sub days.
      8:14:21
      That's going to be a function that we
      8:14:23
      pull in from date FNS and we can say we
      8:14:26
      want to take that and subtract one day
      8:14:28
      from it. Now, this we need to convert to
      8:14:29
      a date. So, we'll say new date to
      8:14:31
      convert this to a date. But you will
      8:14:32
      notice that this actually could be null.
      8:14:34
      it has the null value for it. So, what
      8:14:36
      we want to do is we want to otherwise
      8:14:37
      default to the current time. If for some
      8:14:39
      reason we don't have a time stamp, it
      8:14:40
      shouldn't occur. But if we do run into a
      8:14:42
      weird scenario where we don't have a
      8:14:43
      time stamp, it'll just default to the
      8:14:45
      current time to get us close enough.
      8:14:47
      Then we want to make sure we're only
      8:14:48
      getting job listings that are published.
      8:14:50
      So, we'll say the status
      8:14:53
      is going to be published. There we go.
      8:14:55
      So, this is going to get us all of the
      8:14:56
      job listings that are published. Make
      8:14:58
      sure I put that in the correct location.
      8:15:00
      There we go. This is going to get us all
      8:15:02
      the job listings posted in the last 24
      8:15:03
      hours that were currently published.
      8:15:05
      Then what we can do is we can get
      8:15:07
      specific columns from that. We want the
      8:15:09
      created at field and actually
      8:15:10
      specifically we don't want the created
      8:15:12
      at field. We're going to be using
      8:15:12
      essentially a negative constraint. So
      8:15:14
      we're going to get all the fields except
      8:15:15
      for the ones that I specify here. So
      8:15:17
      we'll say updated at that's also going
      8:15:19
      to be false. Status is going to be
      8:15:21
      false. And organization ID is going to
      8:15:23
      be false. Then what we can do is we can
      8:15:26
      get information about the organization
      8:15:27
      because we're going to want to put that
      8:15:28
      inside of our email. So we'll say
      8:15:29
      organization
      8:15:31
      and we want to get columns.
      8:15:32
      Specifically, we just want the name
      8:15:34
      column. So at least we can say what
      8:15:35
      organization this job listing is for.
      8:15:37
      Once we get all that information, we can
      8:15:39
      essentially run those queries in
      8:15:40
      parallel and make sure that we have data
      8:15:41
      being returned because if not, obviously
      8:15:43
      we have some type of problem. Now the
      8:15:45
      next thing that we're going to do is
      8:15:46
      instead of doing all of our email
      8:15:47
      sending in this job, we're actually
      8:15:49
      going to spin off jobs for each
      8:15:50
      individual email. And that's so that all
      8:15:52
      these jobs can run in parallel. They can
      8:15:54
      have retry logic built in. All that fun
      8:15:55
      stuff that is part of the job Q and
      8:15:57
      ingest. It's essentially the fan out
      8:15:58
      pattern where we're creating multiple
      8:16:00
      events from one event so that they can
      8:16:01
      all run in parallel and have fall
      8:16:03
      tolerance. So what we want to do is we
      8:16:05
      want to essentially call steps sendevent
      8:16:08
      and this is going to call an event
      8:16:09
      called send emails which we'll create in
      8:16:11
      a little bit and then we can pass in all
      8:16:13
      the events that we want to pass along.
      8:16:15
      So we're going to send all of these
      8:16:16
      different events along with this events
      8:16:18
      property. So we need to create our
      8:16:19
      events
      8:16:21
      which is equal to just looping through
      8:16:23
      our notifications and converting them
      8:16:25
      into this event format.
      8:16:27
      Now, inside this format, we're
      8:16:28
      essentially going to return an object.
      8:16:30
      And this object is going to have a name
      8:16:31
      and then it's going to have some data.
      8:16:34
      And then it's also going to have some
      8:16:35
      user information that we're going to
      8:16:36
      pass along. And you may notice that's
      8:16:38
      actually very similar to what we do in
      8:16:39
      our ingest client. When we define
      8:16:41
      something, you can see we can pass along
      8:16:42
      data or user. So, what I want to do is I
      8:16:44
      want to create an event. We're going to
      8:16:45
      call this app/.duser
      8:16:47
      job listings. So, this is for emailing
      8:16:49
      out all the daily job listings. We're
      8:16:51
      going to specify that it's going to have
      8:16:52
      some data properties as well as some
      8:16:54
      properties for the user information. So,
      8:16:56
      our user is relatively straightforward.
      8:16:57
      We want an email, which is a string, and
      8:17:00
      we're going to have a name, which is a
      8:17:01
      string. And then for our data, this is
      8:17:02
      going to be a little bit more
      8:17:03
      complicated. We're going to have our AI
      8:17:05
      prompt. This is going to be an optional
      8:17:07
      string. Essentially, what is the thing
      8:17:08
      that we want to prompt if they pass in
      8:17:10
      some data right here in our filter?
      8:17:12
      Otherwise, if they don't have that, it's
      8:17:13
      just going to be undefined. And then
      8:17:14
      we're going to have our job listings.
      8:17:16
      And this is essentially going to be a
      8:17:18
      type that is our job listing. I'm going
      8:17:19
      to actually copy over the type for this
      8:17:21
      because it's it's relatively
      8:17:22
      straightforward. Essentially, what we're
      8:17:23
      doing is we're taking our job listing
      8:17:25
      table and we're omitting the created at,
      8:17:27
      posted at, updated at status, and
      8:17:28
      organization ID. Essentially, the exact
      8:17:30
      same thing we did inside of here. We're
      8:17:32
      omitting the properties we don't need.
      8:17:33
      And we're also adding in the
      8:17:34
      organization name and we're saying that
      8:17:36
      this is an array of all the job
      8:17:37
      listings. So, similar to what we did
      8:17:39
      here where we got the organization name
      8:17:40
      and omitted these properties. That's
      8:17:42
      exactly what the type for this is going
      8:17:44
      to be. Now, we can actually use that
      8:17:46
      inside of here where we pass along our
      8:17:47
      data in our user. Now, we already know
      8:17:49
      that the user part is really easy. So we
      8:17:50
      can say email that's notification
      8:17:54
      email.
      8:17:56
      Make sure I spell this correctly. There
      8:17:57
      we go. And this is actually notification
      8:18:00
      do user.mmail. And we can do the exact
      8:18:02
      same thing for name. Just like that. And
      8:18:05
      for the name of this event here, we want
      8:18:06
      to make sure we match the name over to
      8:18:07
      this name right here. So we're going to
      8:18:09
      copy that over and we'll paste that into
      8:18:11
      here. Now to make sure we get nice
      8:18:12
      autocomplete on all of this to make sure
      8:18:13
      we have type safety, we'll make this a
      8:18:15
      constant variable. And we're also going
      8:18:17
      to say that it satisfies the get events
      8:18:19
      property which we get from ingest. And
      8:18:21
      we're going to type in the type of event
      8:18:23
      that we want which is going to be ingest
      8:18:25
      right here. So that's our client. So
      8:18:26
      this is all of our different events. And
      8:18:28
      we want to get just one particular event
      8:18:30
      which is the app email daily user job
      8:18:32
      listings. So now you can see we're
      8:18:33
      getting errors on the jobs that don't
      8:18:35
      have this particular data being returned
      8:18:36
      to us. So for example, we need to pass
      8:18:38
      in our AI prompt which is
      8:18:39
      notification.ai prompt. And our job
      8:18:42
      listings is just going to be our job
      8:18:44
      listings. And we need to map through
      8:18:46
      these to just change them slightly. So
      8:18:48
      what we're going to do is we're going to
      8:18:49
      return all of our listing data. And we
      8:18:52
      want to get the organization name, which
      8:18:54
      is just going to be
      8:18:54
      listing.organization.name.
      8:18:57
      There we go. Now we're getting an error
      8:18:58
      because our AI prompt is a string or
      8:19:00
      null. And we just need to convert null
      8:19:02
      to undefined. And that'll get rid of all
      8:19:03
      those errors. And now we've essentially
      8:19:05
      created a bunch of different events with
      8:19:06
      this specific name that we're going to
      8:19:07
      send off. And we call this event send
      8:19:09
      emails. That's just like the name of the
      8:19:11
      step. So this is the step name. And this
      8:19:12
      step is creating a bunch of events for
      8:19:14
      all the different notifications we have
      8:19:15
      set up. So if we had 10 users with
      8:19:17
      notifications set up, it would send out
      8:19:19
      10 different events. And each of those
      8:19:20
      events would run our email related code.
      8:19:22
      So what we can do is we can create a
      8:19:23
      brand new event down here to send those
      8:19:26
      emails. So we're going to call this send
      8:19:27
      daily user job listing email just like
      8:19:29
      that. And we again need to pass it in
      8:19:31
      all the information that we want to use
      8:19:33
      as well as the function that we're going
      8:19:34
      to run with all of the code inside of
      8:19:36
      it. Let me make sure I get this set up
      8:19:38
      correctly. There we go. So the very
      8:19:40
      first thing we need to specify is our ID
      8:19:42
      and our name. That's going to be
      8:19:43
      relatively straightforward. I'll copy
      8:19:44
      that in because it's just some text that
      8:19:46
      doesn't really matter. Next, we're
      8:19:47
      actually going to set up some
      8:19:48
      throttling. So this is just making sure
      8:19:50
      that if we send out a thousand events to
      8:19:51
      all occur at once, we can throttle them
      8:19:53
      over a period of time. The reason we're
      8:19:55
      doing this is because we're using AI to
      8:19:57
      do this filtering for some of our job
      8:19:58
      listing postings. So we want to make
      8:20:00
      sure that we don't overload our AI with
      8:20:02
      sending too many requests at once and
      8:20:03
      hitting our rate limit. So we're going
      8:20:05
      to put a small throttle here. We're
      8:20:06
      going to limit to 10 requests and we're
      8:20:08
      going to say the period is going to be 1
      8:20:10
      minute. So over a 1 minute period, we
      8:20:12
      can only send 10 requests at a time.
      8:20:13
      This will just make sure we don't
      8:20:14
      overload our AI accidentally, but it sh
      8:20:16
      should respond with these messages
      8:20:18
      relatively quickly to all of our users.
      8:20:20
      Now what we're going to do is we're
      8:20:21
      going to put our email event that we
      8:20:23
      want to listen to, which is app/ daily
      8:20:25
      user job listings. Same exact thing that
      8:20:27
      we used up here. It's the exact same
      8:20:29
      event that we used there. So we just
      8:20:30
      want to make sure we listen for that
      8:20:32
      specific event. Then we're going to take
      8:20:34
      in all of our event and our step data.
      8:20:35
      and I want to use it inside of here. So,
      8:20:38
      we're going to parse out our data. So,
      8:20:40
      we have our job listing and our AI
      8:20:43
      prompt just like that. And that's coming
      8:20:44
      from our data property and we need to
      8:20:46
      get the job listings. Then, next I can
      8:20:48
      get my user information. So, we can say
      8:20:50
      our user is equal to event do user. And
      8:20:52
      now we can actually use this
      8:20:53
      information. First of all, if my job
      8:20:55
      listings.length is equal to zero, this
      8:20:58
      shouldn't happen, but if it did happen,
      8:20:59
      I want to return null. Just a fail safe
      8:21:01
      to have in place. So, we're just going
      8:21:02
      to return out of here in case that's a
      8:21:04
      case. Then what we're going to do is
      8:21:06
      we're going to try to get all the
      8:21:07
      matching job listings. So we'll create a
      8:21:08
      variable called matching
      8:21:11
      job listings. We're going to set that to
      8:21:13
      a type of job listings. There we go. So
      8:21:17
      essentially it just matches the type of
      8:21:18
      this variable that we had up here. And
      8:21:20
      then what we want to do is do a simple
      8:21:21
      if check. If our AI prompt is equal to
      8:21:24
      null or our AI prompt.trim
      8:21:29
      is equal to an empty string, well that
      8:21:30
      means that we don't have a prompt. So we
      8:21:32
      want to match all job listings. So we'll
      8:21:34
      say matching job listings is equal to
      8:21:36
      all of our job listings. Otherwise, we
      8:21:38
      have some type of AI prompt and we want
      8:21:40
      to run that AI prompt. And luckily,
      8:21:41
      we've already created a function to do
      8:21:43
      that. This is the get matching job
      8:21:44
      listings prompt. We can pass it in our
      8:21:46
      AI prompt and all the job listings we
      8:21:48
      want to search for. And in this case, we
      8:21:50
      want to return all the job listings, not
      8:21:52
      just 10 or five or whatever. So, we're
      8:21:54
      just going to say that we want to get
      8:21:55
      the matching IDs, which is equal to that
      8:21:57
      right there. We want to await this
      8:21:59
      function as well. There we go. Now, I'm
      8:22:01
      getting an error if I go into this
      8:22:02
      function. And that's because by default
      8:22:04
      this parameter should be optional. So
      8:22:05
      I'll set it to a default empty object by
      8:22:08
      there. Now we can see that got rid of
      8:22:09
      the error. And then what I want to do is
      8:22:11
      I want to get my matching job listings.
      8:22:13
      I'm just going to set that to filtering
      8:22:14
      my job listing array. So we can say
      8:22:16
      listing where the matching oops matching
      8:22:21
      IDs includes our listing ID. There we
      8:22:24
      go. So now essentially we're just saying
      8:22:26
      only get the jobs that have ids that are
      8:22:28
      returned to us specifically from here.
      8:22:30
      Now we do have an error. That's because
      8:22:31
      I spelled job listings incorrectly. But
      8:22:33
      that cleaned up the rest of our errors
      8:22:34
      here. Now we can move on and we can
      8:22:36
      check to see if our matching job
      8:22:37
      listings length is equal to zero. Well,
      8:22:40
      then there's either no jobs posted or
      8:22:42
      there's no jobs that matches this user's
      8:22:44
      requirements. So obviously we don't need
      8:22:45
      to send them an email or do anything.
      8:22:47
      Now we can go through the actual process
      8:22:48
      of sending the email and we're going to
      8:22:50
      use a step for that again for some fault
      8:22:51
      tolerance. So we'll say send email.
      8:22:55
      Make this an async function just like
      8:22:57
      that. We will await this and we're going
      8:22:59
      to be using resend for sending all of
      8:23:01
      our emails. So it would be something
      8:23:02
      like resend and then we would do our
      8:23:04
      code inside of here. So for emails send
      8:23:07
      and then we'll need to pass along some
      8:23:08
      information. So we'll just mark this as
      8:23:10
      to-do and we'll come back to this
      8:23:11
      because we first need to set up resend.
      8:23:13
      Now to work with resend, all we need to
      8:23:14
      go is create an account on resend. And
      8:23:16
      we can access their API keys by just
      8:23:18
      going to the menu, clicking on API keys,
      8:23:19
      and we'll just create a brand new API
      8:23:21
      key. Jobboard final. Doesn't matter what
      8:23:23
      it is. Generally, you're going to want
      8:23:25
      to have sending access only because we
      8:23:26
      don't need full access to the API. And
      8:23:28
      now you can see we have a brand new API
      8:23:30
      key, which I'll just click copy on. And
      8:23:31
      we can add that into our environment
      8:23:32
      variables. We'll come down here for
      8:23:35
      email. We'll say resend API key. And
      8:23:39
      we'll just paste in whatever that API
      8:23:41
      key is. And we'll make sure we include
      8:23:42
      that in our environment variable as
      8:23:44
      well. So this is going to be Z.string
      8:23:47
      minimum value of one. There we go. So
      8:23:49
      now we have resend capabilities. And now
      8:23:50
      we need to import the library for resend
      8:23:52
      as well. Luckily, this is relatively
      8:23:53
      easy to do. We can just npmi resend.
      8:23:56
      Make sure we force install that. That'll
      8:23:58
      install the resend library for us to
      8:24:00
      use. And we can put it inside of our
      8:24:01
      services folder. So, here we have our
      8:24:03
      services. Let's add resend. And we want
      8:24:06
      to create client.ts. So, we're going to
      8:24:08
      export a function called resend or
      8:24:11
      actually a constant variable called
      8:24:12
      resend. And we're going to call new
      8:24:15
      resend. Just like that. Make sure it's
      8:24:18
      capital. We're going to pass in our
      8:24:20
      environment variable
      8:24:22
      which is our resend API key. Now we need
      8:24:24
      to import resend. Looks like I'll have
      8:24:26
      to do that manually
      8:24:29
      resend from resend. There we go. Now
      8:24:32
      that creates a brand new client for us
      8:24:33
      hooked up to our actual API. Now we can
      8:24:35
      go ahead into our email section here and
      8:24:37
      where we have resend, we can import that
      8:24:38
      from our client that we just created and
      8:24:40
      we can call this send function which is
      8:24:42
      going to take in where the email is
      8:24:43
      coming from, where it's going to, and so
      8:24:44
      on. So for the from email on this one,
      8:24:46
      we're just going to be doing testing. So
      8:24:47
      I'm going to say it's coming from
      8:24:48
      jobboard and then we can specify the
      8:24:50
      email which we're going to put as
      8:24:51
      onboardingresend.dev
      8:24:53
      just so we can have this for testing
      8:24:55
      purposes. Also we're going to pass in
      8:24:57
      the user email that we want to send to.
      8:24:59
      And then we're going to pass in the
      8:25:00
      subject as well which is just going to
      8:25:02
      be daily
      8:25:04
      job listings. And then finally we need
      8:25:07
      to pass in a React component that's
      8:25:09
      going to render out whatever our
      8:25:10
      specific code is. Now in our case we
      8:25:12
      don't have any React component yet. So,
      8:25:13
      I want to create inside of our resend
      8:25:14
      folder, I want to create a section for
      8:25:16
      all of our components. So, we'll say
      8:25:18
      components and then we'll create a brand
      8:25:19
      new file in here called daily job
      8:25:22
      listing email.tsx.
      8:25:24
      Now, the annoying thing about writing
      8:25:25
      out email is that email doesn't have
      8:25:27
      access to a lot of modern CSS features.
      8:25:29
      So, we need to make sure that we take
      8:25:30
      into account that a lot of the modern
      8:25:32
      CSS features are not going to be
      8:25:33
      available. So, we're going to export a
      8:25:35
      function called daily job listing email.
      8:25:38
      It's going to take in some props. For
      8:25:39
      now, we'll just return null. and we're
      8:25:41
      going to come into our actual email
      8:25:42
      function and we'll pass that in as our
      8:25:44
      daily email listing and we'll call that
      8:25:46
      as a function just like that. That's
      8:25:47
      essentially calling our React component.
      8:25:49
      Now, like I said, a lot of features
      8:25:51
      inside of email aren't available that
      8:25:52
      you normally get inside the browser. So,
      8:25:54
      what we're going to do is we're going to
      8:25:55
      use something called React email, which
      8:25:56
      is actually built by the people at
      8:25:58
      Resend to make writing emails in React
      8:26:00
      much easier. So, to set up React email,
      8:26:02
      it's actually relatively
      8:26:03
      straightforward. You can see we just
      8:26:04
      need to run a few install commands. We
      8:26:05
      need to install React email as a
      8:26:07
      development dependency and then we can
      8:26:08
      install React email components. So,
      8:26:10
      let's go ahead and do that. npmi react
      8:26:13
      email. And this is going to be a dev
      8:26:14
      dependency for running our React email
      8:26:17
      locally so we can easily see what's
      8:26:18
      going on. Again, we need to make sure
      8:26:19
      that we force this. There we go. And
      8:26:22
      then we're going to install React email
      8:26:23
      components, which is what we're going to
      8:26:24
      use as components to create our email
      8:26:26
      structure. And this is what we use in
      8:26:27
      actually production. So, this React
      8:26:29
      email component here is purely just for
      8:26:31
      actually rendering out our emails
      8:26:32
      locally to see what they look like, as
      8:26:34
      well as giving us some other features
      8:26:35
      that are really handy. So, we're going
      8:26:37
      to install that React email components
      8:26:39
      and we're going to force that as well.
      8:26:41
      That'll get us the components that we
      8:26:42
      need. And then we want to set up inside
      8:26:44
      of our package JSON. Once this is
      8:26:45
      finished running, there we go. Looks
      8:26:46
      like it finished up. We can run in a
      8:26:48
      section here called email. And this is
      8:26:52
      going to run that React email, which is
      8:26:54
      really just called email. Just like
      8:26:56
      that. We can call dev on this. And then
      8:26:58
      we can specify the directory where all
      8:26:59
      of our components or emails are. So in
      8:27:01
      our case, it's the
      8:27:01
      source/services/resend/components.
      8:27:06
      And by default, it runs on port 3000,
      8:27:08
      which is what our app runs on. So let's
      8:27:10
      change the port to 3001. So now if we
      8:27:13
      run npm run email, what that's going to
      8:27:15
      do is it's going to open up on port
      8:27:17
      3001, essentially a hosting of all of
      8:27:19
      our different emails. Now, right now,
      8:27:21
      our email just renders out null. But if
      8:27:23
      we open this up real quick, we can
      8:27:24
      actually see what our emails would look
      8:27:26
      like. Now, the important thing to note
      8:27:27
      about this is you must make sure you
      8:27:28
      export them as default exports. So
      8:27:30
      that's why we have a default export
      8:27:32
      here. But you can see that I can click
      8:27:33
      on daily job listing email and it
      8:27:35
      renders out my email as well as anything
      8:27:36
      for like LinkedIn with issues,
      8:27:38
      compatibility, spam, you know, all these
      8:27:40
      different things to make sure our email
      8:27:41
      looks good. Right now, we're not
      8:27:42
      rendering anything, but we'll go ahead
      8:27:43
      and make this email. Now, for this
      8:27:44
      email, we're essentially going to take
      8:27:45
      in a few props. I'm going to create a
      8:27:47
      type up here to help with this a little
      8:27:48
      bit by just creating a type that
      8:27:50
      contains all of our job listing related
      8:27:51
      information. And then we can take what
      8:27:53
      we want to be able to pass in. So we're
      8:27:55
      going to pass in a username. So the name
      8:27:57
      of the user, that's the string. We're
      8:27:59
      going to take in our job listings. That
      8:28:01
      is going to be an array of this job
      8:28:03
      listing type, which just picks out the
      8:28:04
      types that we need. And then finally,
      8:28:06
      we're going to pass in a server URL. And
      8:28:08
      this is just the URL where our server
      8:28:10
      is. That way, we can redirect people
      8:28:11
      with a link to our particular server.
      8:28:13
      So, we're just having that in there so
      8:28:15
      we can actually get that information.
      8:28:16
      Then, what we want to do is we want to
      8:28:18
      render out all of our components. And
      8:28:19
      you may be tempted to use components
      8:28:21
      from your app and like our components
      8:28:22
      folder and so on, but like I said, email
      8:28:24
      is so much different than the rest of
      8:28:25
      the web that you really can't get away
      8:28:27
      with doing that. you're going to have
      8:28:28
      lots and lots of errors. So instead,
      8:28:29
      we're going to use all the components
      8:28:30
      built into React email. And the main one
      8:28:32
      we're actually going to use is going to
      8:28:33
      be a Tailwind component. So we can
      8:28:35
      actually style everything using
      8:28:36
      Tailwind. So we can come in here, make
      8:28:38
      sure we install that Tailwind component.
      8:28:40
      Looks like I may have to manually
      8:28:41
      install that real quick. We'll import
      8:28:43
      Tailwind from and that's at react
      8:28:46
      email/component. There we go. And this
      8:28:48
      Tailwind component expects you to pass
      8:28:50
      in some children, but also optionally
      8:28:52
      allows you to pass in a config file. And
      8:28:54
      we're actually going to pass in our own
      8:28:56
      config file because this uses Tailwind
      8:28:58
      version 3 and we're on Tailwind version
      8:28:59
      4. Also, certain things like units don't
      8:29:02
      work in all browsers and by defa or all
      8:29:05
      email clients and by default Tailwind
      8:29:06
      uses. So, we want to pass in our own
      8:29:08
      Tailwind config. So, we'll just call
      8:29:10
      this Tailwind config. And actually, if
      8:29:12
      you go to the React email site, they
      8:29:14
      actually have a recommendation on where
      8:29:15
      you can actually use a Tailwind config
      8:29:17
      with a lot of this stuff for you. So,
      8:29:18
      we're going to pretty much be using
      8:29:19
      their default config. So, I'm going to
      8:29:21
      come into data here. I'm going to type
      8:29:23
      in tailwind config.ts or actuallyJSON.
      8:29:27
      No, we'll keep it at TS actually. And
      8:29:28
      what I want to do is I want to paste in
      8:29:30
      what that Tailwind config is. So you'll
      8:29:31
      notice if we look at the top here, all
      8:29:33
      of our different sizes are using pixels
      8:29:35
      instead of and this is something that
      8:29:36
      the folks at React Email actually do.
      8:29:39
      They give you this exact format for the
      8:29:41
      default Tailwind for font size and
      8:29:42
      spacing. So that I just copied over
      8:29:44
      directly. And then these are the styles
      8:29:46
      directly from our application. So if we
      8:29:48
      look at our global CSS file, we come
      8:29:50
      into here. I essentially took all these
      8:29:52
      styles, converted them from OKLCH
      8:29:54
      because that's not supported in email. I
      8:29:56
      converted all of them to RGB and just
      8:29:57
      pasted them in here using the Tailwind
      8:29:59
      V3 formatting for all of them. So, this
      8:30:01
      just gives us all of our different
      8:30:02
      styles so we can make sure we can use
      8:30:04
      them inside of our application. Now,
      8:30:06
      what we can do once we import that
      8:30:07
      Tailwind config is we can start writing
      8:30:09
      out what our code looks like. And we
      8:30:10
      first need to have an HTML element. So,
      8:30:12
      we'll get that. Next, inside that, we
      8:30:14
      need the head of our container. So,
      8:30:15
      we'll put our head element. We don't
      8:30:17
      have anything to put in there, but we
      8:30:18
      need that to make sure that Tailwind
      8:30:19
      works properly. And then finally, let's
      8:30:21
      create a container where all of our
      8:30:22
      content is going to go. And we'll give
      8:30:24
      this a class name of font sands. So it
      8:30:26
      uses the same font we use throughout the
      8:30:27
      rest of our application. Next up, we're
      8:30:29
      going to have a heading
      8:30:31
      just like this. And our heading is going
      8:30:33
      to be an H1.
      8:30:35
      And it's going to say new job listings.
      8:30:38
      There we go. And then below that
      8:30:40
      heading, we can have some text. And
      8:30:41
      you'll notice here I'm essentially using
      8:30:42
      all components from this React email
      8:30:44
      library because these are going to
      8:30:46
      convert into formats that work well with
      8:30:48
      the actual email templating across
      8:30:50
      pretty much all email providers. So here
      8:30:52
      we're going to say, "Hi, username.
      8:30:56
      Here are all the new job listings that
      8:30:59
      meet
      8:31:02
      your criteria." There we go. And then
      8:31:05
      below that, we want to essentially
      8:31:06
      render out all these different things.
      8:31:07
      So first of all, I need to get my props.
      8:31:08
      So we can say job listing server
      8:31:11
      username. There we go. And then below
      8:31:12
      our text, we can render out a section.
      8:31:15
      And this section is going to contain all
      8:31:16
      of our job listings. So we'll loop
      8:31:18
      through our job listings. We're going to
      8:31:19
      map through each one of them just like
      8:31:22
      this.
      8:31:24
      And we essentially want to render out a
      8:31:25
      component that contains everything. So
      8:31:26
      we'll come in here with a div. We'll put
      8:31:28
      that as a job listing ID. We'll also add
      8:31:32
      some class names to this. And we
      8:31:33
      essentially want this to be a card. So
      8:31:34
      we'll say background card text card
      8:31:36
      foreground rounded large. We'll put a
      8:31:39
      border on it. We'll get a padding of
      8:31:42
      four. The border will be the primary
      8:31:44
      color. It'll be a solid border. And
      8:31:46
      we'll put margin on the bottom of six.
      8:31:49
      So that just gives us a nice little card
      8:31:50
      shape for every single one of these job
      8:31:52
      listings that we have. And you notice
      8:31:53
      we're getting errors because our props
      8:31:54
      are not being passed in. If we want to
      8:31:56
      pass in default props, what we need to
      8:31:58
      do at the very bottom here is we can
      8:31:59
      specify daily joblisting email.review
      8:32:02
      preview props and we can specify all the
      8:32:04
      props we want to use. For example, we
      8:32:06
      can pass in an array of job listings
      8:32:09
      like this. And then that's going to give
      8:32:11
      us all of our job listings. So now if we
      8:32:12
      save this, it should actually work
      8:32:13
      properly. I might need to refresh my
      8:32:15
      page to get it to work. Still not
      8:32:16
      working. That's because I spelled job
      8:32:18
      listings wrong. Now if I get that save,
      8:32:19
      you can see it's working. I can also
      8:32:20
      come in here with a username. For
      8:32:22
      example, John Doe. Now you can see that
      8:32:24
      that name is filling in this section
      8:32:26
      right there. And then we can go on and
      8:32:28
      we can put a server URL which by default
      8:32:30
      is going to be our server localhost
      8:32:33
      3000. And to make sure this satisfies
      8:32:34
      our params, we'll just say satisfies
      8:32:37
      parameters. And we want to get the
      8:32:39
      parameters from this function daily job
      8:32:41
      listing. And we want to get the very
      8:32:43
      first parameter. There we go. So now
      8:32:45
      this gives us all the stuff for our job
      8:32:46
      listings. And I'm actually just going to
      8:32:47
      come in here and copy a few job listings
      8:32:49
      over so we can use them as preview
      8:32:51
      props. So you can see we just have some
      8:32:52
      random job listings with some cities,
      8:32:54
      organization names, and so on. So we can
      8:32:56
      see what these look like. And right now
      8:32:57
      you can see we're just getting the text
      8:32:59
      SDF being printed out. Obviously not
      8:33:01
      quite right. So let's go ahead and
      8:33:02
      actually style what we want. First of
      8:33:04
      all, we're going to want to have a text
      8:33:05
      that has our heading for the thing. So
      8:33:06
      we're going to have a class name leading
      8:33:09
      none, font semibold, text extra large,
      8:33:12
      and we're going to get rid of the margin
      8:33:14
      on the top and bottom. Just like that.
      8:33:17
      Inside of here, we're going to say our
      8:33:19
      job listing.title.
      8:33:21
      And now you can see it's printing out
      8:33:22
      the title of our job. Next, we're going
      8:33:24
      to have some more text, which is going
      8:33:26
      to be kind of similar. This one is going
      8:33:27
      to have some different styles, though.
      8:33:29
      So, we're going to say that the text
      8:33:30
      muted is going to be the foreground
      8:33:32
      color, margin on the bottom two, margin
      8:33:34
      on the top of zero, and this is going to
      8:33:36
      be the organization name. There we go.
      8:33:38
      Now, the next thing that we want to do
      8:33:39
      is we want to render out essentially the
      8:33:40
      different badges for this. So, we'll say
      8:33:42
      class name margin bottom five for this
      8:33:44
      particular section. And in here is where
      8:33:46
      we're going to get our badges. Now, I'm
      8:33:47
      going to create a function for us that
      8:33:49
      just returns all of our badge text. So,
      8:33:50
      we'll say function get badges.
      8:33:54
      This is going to take in a job listing.
      8:33:57
      And what we want to do is we want to get
      8:33:58
      all of our badges. And we have a few
      8:34:00
      default badges we're going to use. For
      8:34:01
      example, the job location requirement.
      8:34:04
      Job
      8:34:06
      location requirement.
      8:34:10
      I think I maybe just called it format
      8:34:12
      location requirement. There we go. I
      8:34:14
      want to pass in my job listing.loation
      8:34:16
      requirement. Then what I want to do
      8:34:18
      below that is I want to get my job type.
      8:34:20
      So we'll format our job type. That's
      8:34:22
      going to be my job listing.
      8:34:25
      Then we can format our experience level.
      8:34:28
      There we go. This is going to be our
      8:34:29
      experience level. And then there's a few
      8:34:31
      badges that are optional. For example,
      8:34:33
      if our job listing city
      8:34:36
      is not equal to null or our job
      8:34:39
      listing.state is not equal to null, well
      8:34:41
      then we know that we want to add the
      8:34:42
      badge for that. So we can say
      8:34:44
      badges.unshift.
      8:34:46
      This is going to put this at the front
      8:34:47
      because we know that we want the
      8:34:49
      location to be towards the start because
      8:34:51
      that's very important for most people.
      8:34:52
      So we'll say format job listing
      8:34:56
      location and we'll pass in our job
      8:34:58
      listing. Finally, we want to do the
      8:34:59
      exact same thing for our wage. So if our
      8:35:01
      wage is not equal to null and the wage
      8:35:04
      interval is not equal to null, then we
      8:35:06
      can format the wage to actually display
      8:35:08
      that information. And this takes in our
      8:35:10
      wage as well as our job listing wwage
      8:35:12
      interval. There we go. And again, we're
      8:35:14
      putting that at the front because most
      8:35:15
      likely people care about the wage, the
      8:35:17
      most important. Now, we can return our
      8:35:20
      badges and we can actually use these up
      8:35:22
      here inside of our code. So, wherever
      8:35:23
      that was at, right here, we can loop
      8:35:26
      through these by calling get badges,
      8:35:28
      passing in our job listing, and then we
      8:35:30
      can map through each one of these
      8:35:33
      and render out some code. Now, you may
      8:35:34
      be tempted just to use the badge
      8:35:36
      component from shad CN, but again, you
      8:35:38
      really don't want to use anything that's
      8:35:39
      not directly written for email
      8:35:41
      specifically because a lot of things are
      8:35:42
      not supported. So, we're going to create
      8:35:44
      our own div. We're going to give it a
      8:35:45
      key, which is the index. So, I'm going
      8:35:47
      to actually get the index property.
      8:35:49
      There we go. And then what I want to do
      8:35:50
      is I want to add our class names. And I
      8:35:52
      took most of these classes from the
      8:35:54
      badge, but essentially I changed them to
      8:35:55
      work specifically with email. So we'll
      8:35:57
      say rounded medium border solid border
      8:36:01
      font medium
      8:36:03
      W is going to be fit. The text
      8:36:06
      foreground
      8:36:08
      and then we're going to have small text
      8:36:09
      inside of here. Some padding on the top
      8:36:12
      and the bottom and the sides. And then
      8:36:14
      we're also going to put in some margin
      8:36:15
      for some spacing because we can't use
      8:36:17
      like gap or flexbox. None of that is
      8:36:19
      supported by this property. Email
      8:36:20
      doesn't have any of that support. So we
      8:36:22
      want to make sure we just manually add
      8:36:23
      all of that. And then we'll put in
      8:36:25
      whatever the badge text is. So if we
      8:36:27
      give that a save, you can see our badges
      8:36:28
      are showing up. Obviously the styles
      8:36:29
      aren't perfect, but we're going to make
      8:36:30
      sure we fix that. The best way for us to
      8:36:32
      fix that is actually by using inline
      8:36:33
      block here. So we use inline block. That
      8:36:35
      way we can have that actual spacing like
      8:36:36
      we want. And then we can move on to the
      8:36:38
      button that's going to bring our user to
      8:36:40
      this particular location. So we're going
      8:36:41
      to come in here with a button and make
      8:36:43
      sure we get this from the React email
      8:36:44
      because we want to make sure we
      8:36:46
      customize this to be exactly what we
      8:36:47
      want and not use anything from shad CN.
      8:36:49
      We're going to specify our href for this
      8:36:52
      which is going to be our server URL
      8:36:54
      followed by job listings
      8:36:57
      followed by our job listing ID. That'll
      8:37:00
      bring us directly to where this job is
      8:37:02
      at. We can also specify a class name on
      8:37:05
      this and this is going to be rounded
      8:37:08
      medium text small
      8:37:10
      font medium focus visible is going to be
      8:37:15
      border ring background is going to be
      8:37:18
      primary text primary foreground and then
      8:37:21
      finally just add some padding in here on
      8:37:23
      the top bottom left and right there we
      8:37:25
      go and this will just say view details
      8:37:29
      and this should direct us to that page.
      8:37:30
      So now you can see we have a button and
      8:37:31
      when we click on this you can see it
      8:37:33
      redirected us it looks like to the not
      8:37:34
      correct location. If I look at my URL my
      8:37:37
      port is set to 300. So I just mistyped
      8:37:39
      down here. Let's change that to 3000.
      8:37:41
      Click on view details. And now it'll
      8:37:43
      redirect us to that exact page. Looks
      8:37:44
      like we have an error saying it's not
      8:37:45
      found. But that's because I'm using
      8:37:47
      random UU IDs. So of course we don't
      8:37:48
      have a page for that. But at least we
      8:37:50
      know it is redirecting us to the correct
      8:37:52
      location. Now that's everything it takes
      8:37:53
      to actually create this email. And it's
      8:37:54
      really nice that we can test all this.
      8:37:55
      And we can go down to this llinter and
      8:37:57
      compatibility section. And this will
      8:37:58
      tell you things that are not supported.
      8:37:59
      For example, border radius is not
      8:38:01
      supported in Outlook, but for our case,
      8:38:03
      we don't care. Border radius is only
      8:38:04
      used on a couple of these borders for
      8:38:05
      stylistic purposes. So, it's okay. It's
      8:38:07
      not supported in those particular
      8:38:09
      browsers or those particular email
      8:38:10
      providers because it'll just have square
      8:38:12
      rounding corners instead of rounded
      8:38:13
      corners. So, that's okay. You can see
      8:38:15
      otherwise we are completely checked off
      8:38:16
      on all the rest of those criteria. Now,
      8:38:18
      let's go ahead and actually pass in our
      8:38:20
      parameters that we need. We know that we
      8:38:22
      need the job listings. We know that we
      8:38:24
      need the username, which we can get from
      8:38:26
      our stuff. So, we have here user.name
      8:38:28
      name. And then we also need to pass in
      8:38:31
      the server URL. And this server URL we
      8:38:33
      should get from our environment
      8:38:34
      variable. So we'll come in here with an
      8:38:35
      environment variable. Server URL.
      8:38:39
      There we go. Let's come in here, make
      8:38:41
      that a string with a minimum size of
      8:38:44
      one. And let's add that to our
      8:38:45
      environment variables. We'll just call
      8:38:47
      this like an other category.
      8:38:50
      And this is going to be localhost
      8:38:54
      3000. There we go. So now that should be
      8:38:56
      everything we need to do to actually
      8:38:57
      send out this email. And the annoying
      8:38:59
      thing most of the time when you're
      8:39:00
      dealing with, for example, cron jobs is
      8:39:02
      you have to wait for the chron job
      8:39:04
      period to be. And in our case, our crown
      8:39:05
      job is only at 7:00 a.m. once a day. But
      8:39:08
      the nice thing with ingest is we can
      8:39:09
      just manually trigger these events
      8:39:10
      whenever we want. So let's make this a
      8:39:12
      little bit larger. We'll go over to our
      8:39:13
      ingest dev server. And of course, we
      8:39:15
      need to make sure we have our functions
      8:39:17
      being placed. So our send email job
      8:39:19
      update function. Let's make sure we add
      8:39:21
      those.
      8:39:22
      So let me just maximize this size. go
      8:39:25
      over to our API ingest route. Those are
      8:39:27
      the function we just created. So we'll
      8:39:28
      send the email function and we have one
      8:39:31
      called prepare emails. There we go.
      8:39:32
      That's the two functions that we just
      8:39:34
      created. Now we can go over to our
      8:39:35
      function sections and you'll see we have
      8:39:37
      this section down here for prepare daily
      8:39:39
      job notifications. I can just click
      8:39:41
      invoke. And what that's going to do is
      8:39:42
      it's a crown job. It's just going to
      8:39:44
      invoke that function. And now you can
      8:39:45
      see it's running a bunch of functions.
      8:39:47
      So first of all, I ran the function for
      8:39:48
      this and it looks like it completed just
      8:39:50
      fine. Got my users and everything. And
      8:39:51
      let's take a look at the data returned
      8:39:53
      from this. So we look over here, the
      8:39:54
      data returned from this step is my one
      8:39:56
      user with my email and my name. Then we
      8:39:59
      can see that we're getting all the
      8:40:00
      different recent jobs. So it looks like
      8:40:01
      there are two jobs that are recently
      8:40:03
      posted. And then finally down here we
      8:40:05
      have our finalization. Now it looks like
      8:40:06
      we had a little bit of a problem though
      8:40:08
      cuz if we go over to our runs, it only
      8:40:10
      prepared our job listing notifications,
      8:40:11
      but it didn't send out any of our
      8:40:13
      emails. Now just to make sure it wasn't
      8:40:14
      a fluke with maybe some caching stuff
      8:40:16
      going on, I'm just going to rerun this
      8:40:17
      to see if it then sends it out. And it
      8:40:19
      looks like it's still not sending it
      8:40:20
      out. So I think we have a problem
      8:40:21
      somewhere in our code. So let's take a
      8:40:23
      look at the code for where we actually
      8:40:24
      create those functions. The prepare
      8:40:26
      function is kind of where we want to get
      8:40:27
      started at. So we can go down here and
      8:40:29
      this is the problem is it's not actually
      8:40:31
      sending out no sorry start sorry start
      8:40:32
      sorry start sorry start sorry start
      8:40:32
      sorry start sorry start sorry start
      8:40:32
      sorry start sorry starting not there up
      8:40:32
      here it's not actually sending out our
      8:40:35
      events. The reason for this is I failed
      8:40:37
      to add in an await here cuz we need to
      8:40:38
      wait for this to actually send out the
      8:40:39
      events. That should hopefully fix our
      8:40:41
      problem. Let's go ahead and test that.
      8:40:43
      We're just going to go ahead and we're
      8:40:44
      going to reinvoke that entirely from our
      8:40:46
      function section. So we're going to come
      8:40:47
      over here prepare dollar daily jobs.
      8:40:49
      Invoke that function. And now you can
      8:40:51
      see, perfect, this worked. So it ran
      8:40:53
      that function and then it saw that we
      8:40:54
      had one user. So it spun off one new job
      8:40:57
      for listing out that user's email
      8:40:58
      related stuff. And you can see it ran
      8:41:00
      that specific function. Now I can
      8:41:01
      actually show you this works because if
      8:41:02
      I open up my email, you can see I got a
      8:41:04
      brand new email in my inbox that says
      8:41:05
      new job listings and it has the two
      8:41:07
      brand new job listings that have been
      8:41:08
      posted. And if I click view details,
      8:41:10
      it's going to open up a new tab. And if
      8:41:11
      I pull that new tab over, you can see
      8:41:13
      that it opened up all this information
      8:41:14
      for the brand new job that I clicked on
      8:41:16
      viewing the details for. Now, we can
      8:41:17
      kind of close out of this because that
      8:41:19
      essentially takes care of all of our
      8:41:21
      user side of things. Now, we need to
      8:41:22
      finish up with the organization side of
      8:41:24
      things because if we come back to here,
      8:41:25
      I of course had my invalid environment
      8:41:27
      variable. That's just cuz I didn't have
      8:41:28
      my environment variables set. What we
      8:41:30
      can do is we can go back to our job
      8:41:31
      board. We have all that done. We have
      8:41:33
      our AI stuff done. We can go to the
      8:41:34
      employer dashboard and we essentially
      8:41:35
      have two main sections to work on. The
      8:41:37
      first is going to be listing out all the
      8:41:39
      applicants down here. And the second is
      8:41:41
      going to be managing our user settings
      8:41:43
      right here. So, as you can see, there's
      8:41:44
      currently no user settings. Another kind
    </chapter>
    <chapter title="Clerk organization membership webhooks" start_time="8:41:45">
      8:41:46
      of minor thing we should probably take
      8:41:47
      care of is when we manage organizations,
      8:41:49
      we can actually invite members to our
      8:41:51
      team and change memberships, delete
      8:41:53
      memberships, and so on. And in our
      8:41:54
      database, we're storing the organization
      8:41:56
      user settings. So when we add a new
      8:41:58
      member, I want to automatically create a
      8:42:00
      membership setting for them. And when we
      8:42:02
      remove a member, I want to remove their
      8:42:04
      settings for that organization just to
      8:42:06
      keep our database overall relatively
      8:42:07
      clean. So we have some clerk web hooks
      8:42:09
      we need to take care of. We need to take
      8:42:10
      care of the user settings, sending out
      8:42:12
      more emails, and the application
      8:42:13
      ranking. So, let's tackle the clerk web
      8:42:15
      hooks first because that's going to be
      8:42:16
      setting us up perfectly for where we
      8:42:18
      want to go next. Let's close out all
      8:42:19
      this. Open up clerk. And essentially, we
      8:42:21
      want to have a create and a delete
      8:42:23
      version for this. So, this is going to
      8:42:24
      be for creating an organization
      8:42:26
      membership. So, clerk
      8:42:29
      org membership
      8:42:32
      and we'll just call this create just
      8:42:34
      like that. And down here, we can give it
      8:42:36
      a name. Create organization user
      8:42:41
      settings because that's what we're going
      8:42:42
      to be doing from this. Create
      8:42:46
      organization user settings. There we go.
      8:42:49
      So, whenever we have a new organization
      8:42:51
      membership, which is an organization
      8:42:53
      membership, just like that. Whenever
      8:42:55
      that's created, it's a web hook sent
      8:42:57
      from clerk, we want to create some
      8:42:58
      organization settings for that user. So,
      8:43:00
      let's go ahead. We need to make sure we
      8:43:02
      copy this event name over since we need
      8:43:03
      to set it up in our ingest client. So
      8:43:06
      all the way up here as one of our clerk
      8:43:07
      web hooks, we'll give it that name clerk
      8:43:10
      slash. This is going to be a clerk
      8:43:14
      web hook. And this is going to take in
      8:43:16
      the object which is an organization
      8:43:19
      membership
      8:43:22
      JSON. There we go. And then we can copy
      8:43:24
      that down for deleted because when we
      8:43:25
      delete a user, it also passes along an
      8:43:27
      organization membership JSON. So now at
      8:43:29
      least we have that information which we
      8:43:31
      can use. We can verify the web hook. And
      8:43:33
      then we finally need to create the
      8:43:34
      organization settings.
      8:43:36
      Whoops. There we go. And it's
      8:43:39
      organization user settings. This step is
      8:43:41
      going to be relatively simple. All we
      8:43:42
      want to do is get our user ID which
      8:43:44
      comes from our event.data.public
      8:43:46
      metadata or public user data. There we
      8:43:49
      go. And then we want to get the user ID.
      8:43:51
      And then we want to get the org ID which
      8:43:53
      is equal to
      8:43:53
      event.data.data.organization.
      8:43:56
      ID. So now we have the two properties
      8:43:57
      that we need. we can insert our
      8:43:59
      organization user settings. And all we
      8:44:03
      need to do is pass in that information.
      8:44:04
      So we have our user ID and our
      8:44:07
      organization ID just like that. And now
      8:44:11
      all we need to do is create this
      8:44:12
      function. So let's go into our code. We
      8:44:14
      can find the section for this inside of
      8:44:16
      features inside of users. And actually
      8:44:18
      this is probably more linked to the
      8:44:19
      organizations. So let's put this in the
      8:44:20
      organizations in the database section.
      8:44:22
      And I should probably rename this file
      8:44:23
      to organizations because this deals with
      8:44:25
      organizations. And now we can create a
      8:44:27
      new file called organization user
      8:44:29
      settings.
      8:44:31
      And this is where we want to export this
      8:44:34
      function which is going to be an
      8:44:35
      asynchronous function. Just like that.
      8:44:37
      Now I'll copy over the code for this
      8:44:38
      because it's essentially what we've done
      8:44:40
      a million times over and over again. As
      8:44:42
      you can see, I'm passing in my infer
      8:44:44
      insert settings. I'm inserting that into
      8:44:46
      the table. I'm getting the values from
      8:44:48
      that on conflict do nothing. Again, the
      8:44:50
      reason that I'm doing this most
      8:44:51
      importantly is because when we first
      8:44:53
      create an organization setting, maybe we
      8:44:55
      get that web hook sent to us twice. I
      8:44:56
      just want to make sure we don't
      8:44:57
      accidentally send it through multiple
      8:44:59
      times. Also, we don't even need to
      8:45:00
      return anything here. We can actually
      8:45:01
      get rid of that and we can just use our
      8:45:03
      settings right here because that's going
      8:45:05
      to give us our ID information. Now, we
      8:45:07
      just need to create the ability to
      8:45:08
      revalidate this. So, what we do is
      8:45:10
      inside of our organizations, inside of
      8:45:11
      our cache, we're going to just copy this
      8:45:13
      organizations one and rename it
      8:45:15
      organization user settings. And instead
      8:45:18
      of making you watch me type all this
      8:45:19
      out, I will paste it in because
      8:45:21
      essentially all we're doing is taking in
      8:45:22
      a global setting and we're taking in our
      8:45:24
      IDs right here and we're making sure we
      8:45:26
      properly revalidate our cache when we
      8:45:27
      need to. Now, if we make sure we just
      8:45:29
      import everything, we should see
      8:45:30
      everything is working. That looks like
      8:45:31
      that's working. And here we can import
      8:45:34
      this. And now we have the ability to
      8:45:35
      create these on insert. Now, doing a
      8:45:37
      delete is going to look almost identical
      8:45:38
      to this. So, we're just going to copy
      8:45:40
      this over. This is going to be for
      8:45:42
      delete
      8:45:44
      or membership. And here we'll say delete
      8:45:48
      delete. And this right here will say
      8:45:50
      deleted. There we go. That should be the
      8:45:52
      event name. Then what we need to do is
      8:45:53
      we just need to call this delete
      8:45:54
      organization user settings. We get the
      8:45:56
      same user or ID just like this. And then
      8:45:58
      we're just going to call the delete
      8:46:00
      function that we're going to create in
      8:46:01
      just a second. So we need to create this
      8:46:02
      function which is in the exact same
      8:46:04
      location as this one. So we can come in
      8:46:06
      here, export the async function,
      8:46:11
      call it delete. It's going to be passing
      8:46:12
      in essentially the exact same data. I'm
      8:46:14
      just going to manually get that passed
      8:46:15
      in like this. So, we're just getting our
      8:46:17
      ID properties and then we call
      8:46:19
      DB.delete.
      8:46:20
      We want to pass it in our organization
      8:46:22
      user setting table. And we specifically
      8:46:24
      want to get it where all of our queries
      8:46:26
      are met. So, we're going to say and and
      8:46:28
      equals organization setting table dot
      8:46:30
      user ID is equal to our user ID. And we
      8:46:33
      want to do the exact same thing where
      8:46:35
      our organization setting table
      8:46:36
      organization ID is equal to our
      8:46:38
      organization ID. So essentially just
      8:46:40
      delete the one that we want to get and
      8:46:42
      then we can revalidate based on our user
      8:46:44
      ID and our organization ID. There we go.
      8:46:47
      So that is revalidating all of our
      8:46:48
      information and it's deleting all the
      8:46:50
      information. And if we import all this
      8:46:51
      properly down here, we should see that
      8:46:54
      everything is working. There we go. So
      8:46:56
      now we just need to make sure we take
      8:46:57
      these two functions and we put them into
      8:46:59
      ingest. So what we can do is we can come
      8:47:01
      all the way over here in our API ingest
      8:47:03
      and let's just add those functions. So,
      8:47:04
      we're going to create the clerk
      8:47:05
      membership and this will be clerk delete
      8:47:08
      org membership. I'm going to actually
      8:47:11
      move these up with the rest of our clerk
      8:47:12
      ones just for some organization
    </chapter>
    <chapter title="Organization user settings page" start_time="8:47:14">
      8:47:14
      purposes. Now, the next thing that we
      8:47:15
      can work on in our application is going
      8:47:16
      to be that settings page. So, we'll go
      8:47:18
      over to user settings just like this.
      8:47:20
      This is the page that I want to work on
      8:47:21
      next. And the nice thing is is it's very
      8:47:23
      very similar to the page we already
      8:47:25
      created for notifications here. So, I'm
      8:47:27
      actually going to copy that entire page
      8:47:28
      and we're going to use it over here. So,
      8:47:30
      we're going to create a file in user
      8:47:32
      settings. Actually, it's going to be a
      8:47:34
      folder.
      8:47:36
      User settings. Whoops, didn't even click
      8:47:38
      folder. There we go. User
      8:47:40
      settings. We're going to paste in that
      8:47:41
      brand new page. And this is going to be
      8:47:43
      our notifications page. And this is
      8:47:44
      actually just our employer user settings
      8:47:47
      page. Let's give it a little bit better
      8:47:49
      name. And all we need to do is make some
      8:47:50
      minor changes to what this page looks
      8:47:52
      like and what form we're rendering and
      8:47:53
      so on. So, I first want to get the
      8:47:55
      organization and the user information.
      8:47:57
      So, we'll say get current organization
      8:47:59
      as well. And if either of those are
      8:48:01
      equal to null, well then we can't update
      8:48:02
      the settings. There we go. So we'll just
      8:48:05
      return not found. Then what we want to
      8:48:06
      do is exactly the same code here, but we
      8:48:08
      want to make sure we pass along our
      8:48:09
      organization information as well to our
      8:48:11
      form. So we'll come in here with our org
      8:48:13
      ID, just like that. And we'll make sure
      8:48:15
      we accept org ID
      8:48:18
      and or ID as a string. Now, our
      8:48:20
      notification settings are going to take
      8:48:22
      in both a user ID and an org ID. And if
      8:48:24
      we scroll all the way down to where
      8:48:26
      that's going to be and we might as well
      8:48:27
      call this organization ID to be a little
      8:48:29
      bit more with our names and here
      8:48:32
      organization ID. Now if we scroll down
      8:48:33
      to this function, we'll make it accept
      8:48:35
      those properties. So we'll come in here.
      8:48:37
      Organization ID is a string as well.
      8:48:42
      And we'll say it's organization and user
      8:48:44
      ID. And instead of getting this from the
      8:48:46
      user table, we want to get the
      8:48:48
      organizations from the organization
      8:48:50
      table. So we'll get organization user
      8:48:52
      settings global tag. And this one we
      8:48:54
      actually want the ID tag. There we go.
      8:48:56
      And we're going to pass in our ID which
      8:48:58
      is our user ID and it's going to be our
      8:49:00
      organization ID. Then again changing the
      8:49:02
      table here that we work with. We want
      8:49:03
      the organization table specifically.
      8:49:06
      Same thing here. Organization table. And
      8:49:08
      we want to do a double query. So we're
      8:49:10
      going to put an and right here. There we
      8:49:12
      go. And we want to just copy this query
      8:49:15
      because we're going to do essentially
      8:49:16
      the exact same thing, but this one is
      8:49:18
      going to be for the organization ID.
      8:49:21
      There we go. Now, when it comes to
      8:49:22
      selecting the columns that we want,
      8:49:23
      we'll just keep all the columns. It
      8:49:24
      doesn't really matter. Actually, I guess
      8:49:25
      we might as well limit it. So, we're
      8:49:27
      going to get the new application column,
      8:49:29
      and then we're going to get the minimum
      8:49:30
      rating column because those are the only
      8:49:31
      two things we're using. Now, we can just
      8:49:33
      scroll up a little ways and we can make
      8:49:34
      sure that we're rendering the correct
      8:49:36
      notifications form. So, where we're
      8:49:38
      importing notifications form, I want to
      8:49:40
      just get rid of that. So, come up here,
      8:49:42
      notifications form, get rid of that
      8:49:43
      input completely, and we're going to
      8:49:44
      create a brand new notifications form
      8:49:46
      specifically for our organization, for
      8:49:48
      our user settings. So, we're going to
      8:49:50
      come all the way down to our features.
      8:49:51
      We're going to put this inside of
      8:49:52
      organizations. Create a brand new folder
      8:49:54
      or file. We're going to call it
      8:49:55
      notifications form.tsx and make sure
      8:49:58
      that's in our components folder. Now,
      8:49:59
      this notifications form is going to
      8:50:00
      share a lot in common with the
      8:50:02
      notifications form we created over here.
      8:50:03
      So, I'm going to copy and paste this in
      8:50:05
      so that we can do all the different
      8:50:06
      changes that we need directly inside of
      8:50:07
      here. So, the very first thing is
      8:50:09
      obviously our schema is going to be
      8:50:10
      different and our update function is
      8:50:11
      going to be different. So, we can get
      8:50:12
      rid of those, but the rest is going to
      8:50:14
      be very similar. So, first of all, this
      8:50:16
      is going to come from our organization
      8:50:17
      user settings table. And we specifically
      8:50:20
      only care about the props here and
      8:50:22
      minimum rating here. Now, while we're at
      8:50:24
      it, we can go ahead and change out this
      8:50:26
      schema with a new one. So, we're going
      8:50:27
      to use an organization user settings
      8:50:30
      schema. Same thing here. We're going to
      8:50:31
      use the exact same new schema. So, let's
      8:50:33
      go ahead and create that schema. We're
      8:50:35
      going to go into the action section for
      8:50:37
      our organizations. So, new folder,
      8:50:39
      actions, and we're going to create a
      8:50:41
      file called schema.ts. And we'll
      8:50:43
      actually call it schemas.ts ts to be
      8:50:45
      consistent. We're going to export a
      8:50:47
      constant variable with that name. We're
      8:50:49
      going to use a zod object. We're going
      8:50:51
      to get the new application email
      8:50:53
      notification.
      8:50:55
      That is going to be a boolean.
      8:50:58
      And then the next one that we're going
      8:51:00
      to have is our minimum rating.
      8:51:04
      This is going to be a number.
      8:51:06
      It's going to be a minimum value of one.
      8:51:12
      We're going to have a maximum value of
      8:51:14
      five. And we're also going to make that
      8:51:16
      nullable. So they don't have to pass
      8:51:18
      this in if they don't want to. So now we
      8:51:19
      can actually use and import that schema.
      8:51:22
      Just like that. And we can make sure
      8:51:24
      that we have here our minimum rating. By
      8:51:26
      default, we'll set that to null. And
      8:51:28
      then we're going to have our
      8:51:28
      notification settings down here, which
      8:51:30
      we're going to set to false by default.
      8:51:32
      Now for our update setting, we're going
      8:51:33
      to call this update organization user
      8:51:35
      settings. We'll come back and fix this
      8:51:37
      in a little bit. We can get rid of this
      8:51:38
      notification part right there. And then
      8:51:39
      what I want to do is here I want to
      8:51:41
      listen for the new application email
      8:51:43
      notifications instead. So there we go.
      8:51:45
      That's the new field that we're going to
      8:51:46
      be listening to. We can copy down that
      8:51:48
      exact same name because we're going to
      8:51:49
      use that here. This will still say daily
      8:51:51
      email notifications, but we're going to
      8:51:53
      essentially change what this says. It'll
      8:51:54
      say receive a summary emails of all new
      8:51:57
      job listing applications. There we go.
      8:52:01
      And then down here, we're going to have
      8:52:02
      a section that's going to be
      8:52:03
      specifically for our minimum rating. And
      8:52:05
      this one's going to be a little bit
      8:52:06
      different because we're not going to be
      8:52:08
      using a text field. We're going to be
      8:52:09
      using a select field for this. So, I'm
      8:52:11
      going to kind of get rid of a lot of the
      8:52:12
      stuff that we have inside this form item
      8:52:14
      and start from the scratch. So, the very
      8:52:15
      first thing I want to do is put a form
      8:52:17
      label. This form label is going to say
      8:52:19
      minimum rating.
      8:52:22
      Then after that label, we're going to
      8:52:23
      render out our select component. Make
      8:52:25
      sure we import the correct one. The
      8:52:27
      value for this is going to be field
      8:52:29
      value or if we well, if we have a field
      8:52:31
      value, it's going to be our field value
      8:52:33
      to string.
      8:52:35
      So, we can convert essentially from a
      8:52:36
      number to a string. Otherwise, we're
      8:52:38
      going to use the any value just like
      8:52:40
      this, which is a value that I'm going to
      8:52:41
      create. So, let's just close off this
      8:52:43
      select, scroll all the way to the top,
      8:52:45
      and we can just say const
      8:52:48
      any value is equal to any. Then, let's
      8:52:52
      get rid of some of these imports we
      8:52:53
      don't need just to clean up a little
      8:52:54
      bit. And if we scroll all the way back
      8:52:56
      down to where we are working, we can
      8:52:57
      come in here with an onv valueue change
      8:52:59
      and we can specify that when our value
      8:53:01
      changes, we're going to call
      8:53:02
      field.onchange.
      8:53:05
      And if our value is equal to the any
      8:53:07
      value, then we want to return null.
      8:53:09
      Otherwise, we want to convert our string
      8:53:11
      into an integer. So, we're going to
      8:53:12
      parse this into an integer just so we
      8:53:14
      can make sure when we store this in our
      8:53:15
      database, it's an integer. While we
      8:53:17
      store it in our select, it's going to be
      8:53:18
      a string. Then, inside of our select, we
      8:53:21
      want to render out our form control. And
      8:53:23
      our form control will have our select
      8:53:24
      trigger inside of it. And that is going
      8:53:27
      to have our select value. And the select
      8:53:30
      value here is going to be an as child
      8:53:32
      value because we essentially want to
      8:53:33
      render out not the number 1 2 3 4, but
      8:53:35
      we want to render out some stars so it's
      8:53:37
      a little easier for people to look at.
      8:53:39
      So if the field value is equal to null,
      8:53:41
      then we're going to render out a span
      8:53:44
      that just says any rating just so they
      8:53:46
      know that it's literally any value.
      8:53:47
      Otherwise, we're going to render out our
      8:53:49
      rating icons. And this is a component
      8:53:50
      we're going to create to render out what
      8:53:52
      our icons should look like. And we'll
      8:53:53
      make sure the class name on this is text
      8:53:55
      inherit so that it inherits the proper
      8:53:57
      text color. We'll also pass in the
      8:53:59
      rating, which is a field value, which is
      8:54:01
      just going to be a number between 1 and
      8:54:02
      five. Now, we can go ahead and give that
      8:54:04
      a quick save, but we need to create this
      8:54:05
      rating icons component. So, let's go
      8:54:07
      ahead into our job listing section, cuz
      8:54:09
      that's kind of where this makes sense to
      8:54:10
      put, and we'll put it inside of our
      8:54:12
      components. Actually, it's going to be
      8:54:13
      an application section because it's
      8:54:14
      specifically related to an application.
      8:54:16
      We'll say that we want our rating
      8:54:18
      icons.tsx.
      8:54:20
      We're going to export a function called
      8:54:21
      rating icons. It's going to take in our
      8:54:23
      rating and our class name.
      8:54:27
      Rating is going to be a number or it
      8:54:30
      could be null. And then finally our
      8:54:31
      class name.
      8:54:34
      This is going to be an optional string
      8:54:36
      just like that. Now if our rating oops
      8:54:41
      if our rating is equal to null or it's
      8:54:44
      not within our range of 1 to 5. So if
      8:54:46
      it's less than one or it's greater than
      8:54:48
      five, we'll then just want to return
      8:54:50
      unrated because it's either unrated or
      8:54:52
      we have a rating outside of our range
      8:54:53
      which we don't want to take into
      8:54:54
      account. Then we want to render out a
      8:54:56
      number of stars. So we're going to say
      8:54:58
      that these are an array of React nodes
      8:55:00
      which by default will be empty. And we
      8:55:02
      want to render out five stars where the
      8:55:04
      ones that are filled are equal to our
      8:55:06
      rating. So like the first three stars
      8:55:07
      are filled and the second two are empty.
      8:55:10
      So we can just do a simple for loop for
      8:55:12
      this. Let I equal 1. I is less than or
      8:55:15
      equal to five and I ++.
      8:55:18
      There we go. Make sure I put a comma
      8:55:20
      here. And actually, I should have
      8:55:21
      semicolons, not commas. Don't know what
      8:55:23
      I was thinking. There we go. Now, inside
      8:55:25
      this loop, all I want to do is add a new
      8:55:26
      element into our array. I want it to be
      8:55:28
      a star icon. Just like that. And the key
      8:55:31
      is going to be my index. And then
      8:55:33
      finally, I can come in here with a class
      8:55:35
      name. And this is where I can specify
      8:55:36
      what this is going to look like. So,
      8:55:37
      we'll use CN for this. We'll say the
      8:55:40
      size is going to be four. And then,
      8:55:42
      whoops, four. There we go. And then if
      8:55:44
      our rating is greater than or equal to
      8:55:46
      the current number that we're on, well
      8:55:47
      then we want it to be filled in. So
      8:55:49
      we're going to say that our fill is
      8:55:51
      going to be current. That is going to
      8:55:53
      fill in our text or fill in our star
      8:55:55
      with whatever the current text color is.
      8:55:57
      Then finally, we want to pass in any
      8:55:59
      additional class names. So we'll say
      8:56:00
      class name just like that. And that'll
      8:56:02
      close all that off. Let me make sure I
      8:56:04
      have all my parentheses in the right
      8:56:05
      places. There we go. So that's just
      8:56:07
      going to add that star icon for us.
      8:56:09
      Finally, we want to return those star
      8:56:11
      icons. We're going to put them inside a
      8:56:12
      div with a flex gap of one. We're going
      8:56:16
      to render out our stars. And then we're
      8:56:17
      going to have a span for our screen
      8:56:19
      readers. So we'll say screen reader
      8:56:20
      only. That is just going to say rating
      8:56:24
      out of five. So that way they know it's
      8:56:26
      like, hey, a three out of five, two out
      8:56:27
      of five, and so on. So now here we have
      8:56:29
      our rating icons just like that. Now the
      8:56:31
      next thing we need to specify is going
      8:56:32
      to be our select control. So we're going
      8:56:35
      to come in here with our select content.
      8:56:38
      We want to get all of our different
      8:56:39
      items. So, select item.
      8:56:42
      There we go. And this first select item
      8:56:44
      is going to be the any option. So, I'll
      8:56:46
      say any value just like that. This is
      8:56:49
      going to say any rating. And then
      8:56:51
      finally, we can move down below that and
      8:56:52
      loop through all of our different rating
      8:56:54
      options. So, we'll come in here with
      8:56:55
      rating options
      8:56:57
      and we'll filter those down. Now, this
      8:56:59
      rating options variable is something
      8:57:00
      that I want to create so I can use it
      8:57:01
      across my application for what all my
      8:57:03
      different rating options are. So, inside
      8:57:04
      my job listing section, I'm just going
      8:57:06
      to create a new folder called data. Make
      8:57:08
      sure that's in the correct folder here.
      8:57:10
      I'm going to create a new file called
      8:57:11
      constants.ts.
      8:57:14
      And we're going to export a constant
      8:57:16
      with that rating options name. And it's
      8:57:18
      just going to be null 1 2 3 4 5 as
      8:57:21
      const. So those are just our options for
      8:57:23
      the different ratings we could possibly
      8:57:25
      have. So now I can import that rating
      8:57:26
      options. And I want to just filter out
      8:57:28
      the null option cuz that's not allowable
      8:57:30
      in this context. So r is not equal to
      8:57:32
      null. So it'll only give me 1 2 3 4 5.
      8:57:34
      Then for each one of those I want to map
      8:57:36
      over the rating. So we'll just call this
      8:57:38
      rating.
      8:57:40
      And inside of here for that rating, I
      8:57:42
      want to render a select item. And this
      8:57:44
      select item, we'll have a key, which is
      8:57:46
      just my rating value. 1 2 3 4 or 5. The
      8:57:49
      value will be my rating to string since
      8:57:51
      it must be a string based value. And
      8:57:53
      then finally, we're going to render out
      8:57:54
      the rating icons. So we have a visual
      8:57:56
      indicator of what this looks like. Same
      8:57:57
      thing. I'm going to make sure my text is
      8:57:59
      inheriting. My rating is going to be
      8:58:01
      equal to the rating value. And then we
      8:58:03
      can just close that off like this. So
      8:58:05
      that's going to render out all of our
      8:58:06
      rating icons. And finally, underneath of
      8:58:08
      all of this, we want to add a
      8:58:09
      description and error message. So, we'll
      8:58:12
      say form description, and we'll come
      8:58:14
      down below that with our form message.
      8:58:16
      Just like that. And the description on
      8:58:18
      this is going to be pretty long, so I'll
      8:58:19
      just copy it over because it's just text
      8:58:20
      for the user. Only receive notifications
      8:58:22
      for candidates that meet or exceed the
      8:58:24
      rating. Candidates three to five stars
      8:58:25
      should meet all job requirements and are
      8:58:27
      likely a good fit for the job. Just to
      8:58:28
      give a little bit of context on what is
      8:58:30
      a good or bad rating. So, now let's go
      8:58:32
      ahead. We need to make sure we implement
      8:58:34
      this function and we need to make sure
      8:58:35
      we import things here. So, if we import
      8:58:37
      the notification form and we get the
      8:58:38
      correct one, that was the wrong one. Get
      8:58:40
      the correct one, we should at least be
      8:58:42
      able to render stuff on our page over
      8:58:43
      here. And you can see we have our daily
      8:58:45
      email notifications. If we turn that on,
      8:58:46
      we can check one of these five ratings.
      8:58:48
      And that's how we created our rating
      8:58:49
      stars. You can see we filled in the
      8:58:51
      stars up to the rating number, which is
      8:58:52
      really useful. So now they can come in
      8:58:54
      here and change this to whatever star
      8:58:55
      rating they want. So now let's go ahead
      8:58:56
      and actually implement this function on
      8:58:58
      update organization user settings. So,
      8:59:00
      inside of our actions, we can come in
      8:59:02
      here and we're going to say organization
      8:59:05
      user settings setting actions.
      8:59:09
      Actions.ts. There we go. This is going
      8:59:12
      to be a server section. So, use server
      8:59:15
      export.
      8:59:17
      This is going to be an async function
      8:59:18
      with that name. And we know that we want
      8:59:20
      to pass in our unsafe data
      8:59:24
      just like that. Z.infer.
      8:59:28
      And we want to infer the type of our
      8:59:30
      organization settings
      8:59:33
      schema. There we go.
      8:59:37
      We'll just make sure we close that off.
      8:59:38
      And then inside this function, we just
      8:59:40
      need to make our two checks we make
      8:59:41
      inside every single function. The first
      8:59:43
      is going to be getting our current
      8:59:44
      authentication. So our user and
      8:59:46
      organization, if those are null, return
      8:59:48
      an error. And then we're going to be
      8:59:49
      making sure that our data is also
      8:59:50
      correct. Otherwise, again, return an
      8:59:52
      error. Then finally what we can do is we
      8:59:54
      can await calling update organization
      8:59:57
      user settings and we want to make sure
      9:00:00
      this is the database version and we're
      9:00:01
      going to pass in our user ID our
      9:00:03
      organization ID which is our org ID and
      9:00:06
      then finally all the data that we passed
      9:00:08
      in. If this is successful we can just
      9:00:09
      return a message saying hey you
      9:00:11
      successfully updated that and now we can
      9:00:12
      go ahead and implement this function
      9:00:13
      inside of our database. So we'll go into
      9:00:15
      our database for organization user
      9:00:17
      settings and we can essentially add in a
      9:00:19
      function for update.
      9:00:21
      Now, the props for this function look
      9:00:23
      really confusing, but really all we're
      9:00:24
      doing is passing in our user ID and
      9:00:26
      organization ID. So, that's our ID. And
      9:00:28
      then for our settings, we're just
      9:00:29
      removing our organization and user ID.
      9:00:31
      So, we only take in the settings we
      9:00:32
      particularly want, which are essentially
      9:00:34
      our created at, updated at, new
      9:00:36
      application, and minimum rating. Those
      9:00:37
      are the only fields we can pass in.
      9:00:39
      Then, inside of here, we essentially
      9:00:41
      want to do almost the exact same thing
      9:00:42
      we did in insert. So, I'm actually going
      9:00:44
      to copy this and I'm going to paste it
      9:00:45
      down, including this revalidate. We
      9:00:47
      might as well get that as well. So,
      9:00:48
      we'll come in here with that. And this
      9:00:50
      is going to take in our user ID and our
      9:00:51
      organization ID. There we go. So, what I
      9:00:53
      want to do inside of here is take all my
      9:00:55
      current settings.
      9:00:57
      I want to take my user ID and my
      9:00:59
      organization ID. And essentially, I want
      9:01:01
      to do an update on that. But instead of
      9:01:02
      on conflict do nothing, I'm going to
      9:01:04
      have an onconlict do update. I'm going
      9:01:07
      to have my target be an array this time,
      9:01:09
      which is our organization user settings
      9:01:11
      table user ID. And the exact same thing,
      9:01:14
      but for our organization ID. So in the
      9:01:16
      case where we have a conflict on that
      9:01:17
      ID, then I want to take our settings and
      9:01:21
      I want to set them to that. So what this
      9:01:22
      little bit of code essentially is doing
      9:01:24
      is we're saying, okay, try to insert a
      9:01:25
      new row into this table. If one already
      9:01:27
      exists, just update it instead. And
      9:01:29
      again, the reason we're doing this is in
      9:01:30
      case our web hook fails or we didn't
      9:01:32
      actually save our notification settings,
      9:01:34
      this will just add a brand new one or
      9:01:35
      update. Either case, it doesn't really
      9:01:36
      matter. But that should take up care of
      9:01:38
      pretty much everything. We just need to
      9:01:39
      make sure we import this function
      9:01:40
      directly into here. So all the way at
      9:01:42
      the top of our page where we're
      9:01:43
      importing our insert function, which I'm
      9:01:45
      not sure where it's at.
      9:01:48
      Of course, I don't think we actually
      9:01:48
      have an insert function. So of course,
      9:01:50
      we don't have one. So we'll just import
      9:01:52
      this from. Actually, I can just do an
      9:01:54
      import like this. There we go. Whoops,
      9:01:57
      that's not the right one. Import that
      9:01:58
      from the actions, not the database.
      9:02:00
      There we go. So now we do have the
      9:02:01
      correct thing being imported inside of
      9:02:03
      our actions. This is where we need to do
      9:02:04
      the manual import. So we'll scroll up to
      9:02:06
      the top here and we'll just do an
      9:02:08
      import.
      9:02:10
      We'll import that from and it's going to
      9:02:13
      be at slash and it's going to be
      9:02:15
      features organizations
      9:02:17
      database organization user settings. And
      9:02:20
      of course I spelled that wrong. So let
      9:02:21
      me fix the name on that file.
      9:02:25
      There we go. Might take a little bit for
      9:02:27
      it to process through on everything. Of
      9:02:29
      course probably need to redo a few
      9:02:31
      things there. There we go. Now let's try
      9:02:33
      to refresh our page. See if that
      9:02:34
      actually processed through. And it looks
      9:02:36
      like it's trying to miss something
      9:02:37
      because it's trying to import from the
      9:02:38
      wrong location. So, let's just see where
      9:02:40
      we still have that at in our code. Looks
      9:02:42
      like we don't have it anywhere. So, it
      9:02:43
      might be cached. I'm just going to clear
      9:02:45
      out my cache because sometimes this
      9:02:46
      happens when you rename files. Sometimes
      9:02:48
      it gets a little stuck on what's what.
      9:02:51
      Going to retry that real quick.
      9:02:54
      Let's do another retry. I was just
      9:02:56
      having a hard time deleting that
      9:02:57
      information.
      9:03:00
      Looks like Oh, because I failed to set
      9:03:02
      shut down the correct location. This was
      9:03:03
      our email server that was running. We
      9:03:04
      can keep that running. That's not a big
      9:03:06
      deal. So now we can come over here,
      9:03:07
      refresh our page, hopefully to rebuild
      9:03:09
      entirely from scratch, and that'll
      9:03:10
      actually solve our problem. That still
      9:03:12
      didn't solve the problem. It looks like
      9:03:13
      it's in our clerk file. So let's just
      9:03:14
      close out of all this. Oh, and of course
      9:03:16
      here it looks like it just hasn't saved
      9:03:17
      this file. So if we give that a save,
      9:03:18
      that should solve it. Actually, it does
      9:03:20
      not solve it. So let's go back into that
      9:03:22
      file. That was the clerk file right
      9:03:23
      here. Okay, it did. It just had to build
      9:03:25
      this system. So now, if we give this a
      9:03:27
      refresh, we shouldn't have any errors.
      9:03:28
      We can enable this. We can set a minimum
      9:03:30
      rating. Let's say a minimum rating of
      9:03:31
      three is what we want to use. And we'll
      9:03:33
      click save. And that successfully
      9:03:34
      updated our notifications. And if we
      9:03:36
      come over here to the organization user
      9:03:38
      settings, refresh this page, we should
      9:03:40
      see we have a brand new setting in here
      9:03:41
      for that user. And we do. And the
      9:03:43
      minimum rating is set to three, just
      9:03:44
      like what we want. Now we can go ahead
      9:03:46
      and work on sending out an email using
      9:03:48
      ingest and resend for all of our email
      9:03:50
      services. Just like we did when we were
      9:03:52
      doing our daily job listing emails, we
      9:03:53
      can essentially do the same exact thing.
    </chapter>
    <chapter title="Send organization email notifications" start_time="9:03:54">
      9:03:55
      So to get started, I'll just kind of
      9:03:56
      copy over the name of the function that
      9:03:58
      we're going to be creating. So you can
      9:03:59
      see here it's prepare daily organization
      9:04:01
      user application notifications. really
      9:04:03
      lengthy name, but I wanted to be as
      9:04:04
      explanatory as I could. Same exact cron
      9:04:07
      7 am on essentially every single day.
      9:04:09
      And we just gave it some names inside of
      9:04:11
      here. Now, we're going to have a bunch
      9:04:12
      of different steps inside of this
      9:04:13
      system. The first step is going to be
      9:04:15
      for getting all of our different user
      9:04:16
      information. And this is very similar to
      9:04:18
      the get user step up above in our
      9:04:20
      previous one, but we're getting our
      9:04:21
      organization user settings instead of
      9:04:23
      our user notifications. So, that's the
      9:04:24
      only difference between these two. And
      9:04:26
      again, we're selecting only the columns
      9:04:28
      that we care about and only when they
      9:04:29
      have the new application email set to
      9:04:31
      true. So that gets us all of our user
      9:04:33
      information. Next, we need to get our
      9:04:35
      applications. So we'll call this step.r
      9:04:37
      run. And we'll call get
      9:04:41
      recent applications. And this is going
      9:04:44
      to be pretty similar to what we did for
      9:04:45
      the job listing section above as well.
      9:04:47
      So I'm actually just going to copy this
      9:04:48
      over. And you can see here all we're
      9:04:50
      going to do is go into our job listing
      9:04:52
      application table for anything that
      9:04:54
      happened within the last 24 hours. So
      9:04:56
      any new application in the last 24
      9:04:57
      hours, we're going to get those. and
      9:04:59
      we're just specifically selecting only
      9:05:00
      the columns we want for we want the
      9:05:02
      rating column, we want the user's name,
      9:05:04
      we want the job ID and title, and we
      9:05:05
      want the organization ID and name. So,
      9:05:07
      we're just getting the specific columns
      9:05:09
      for all of our recent applications and
      9:05:11
      our users in our database that's
      9:05:12
      selected that they want to be updated.
      9:05:15
      Then, we're going to check to make sure
      9:05:16
      that this data is being returned from
      9:05:18
      us. So, again, here we're just doing a
      9:05:19
      promise all waiting for all the data and
      9:05:21
      then we can come through and we can
      9:05:22
      check, hey, is this data there? If it's
      9:05:24
      not, just do a quick return. Now, one
      9:05:26
      thing that's important to understand is
      9:05:27
      that one user could have multiple
      9:05:29
      different organization user settings
      9:05:31
      because they could be a part of multiple
      9:05:32
      different organizations. So, we want to
      9:05:34
      essentially only send them one email
      9:05:36
      even if they're in 10 different
      9:05:37
      organizations. So, we're going to try to
      9:05:39
      group all these settings by the actual
      9:05:41
      user themselves. So, we can come into
      9:05:43
      here, we can say we want to get our
      9:05:45
      grouped notifications
      9:05:47
      that is object.group by and we want to
      9:05:50
      group our user notifications by the user
      9:05:53
      ID. So we can just say n do user
      9:05:56
      ID. There we go. So what this is going
      9:05:58
      to do is it's going to group all the
      9:05:59
      settings for each individual user all in
      9:06:01
      one setting. So we can say okay this
      9:06:03
      user has four organization settings and
      9:06:05
      now we have all of those under one
      9:06:06
      single ID. Then we can essentially get
      9:06:09
      the events that we want to fan out. Same
      9:06:11
      exact thing up here when we got our
      9:06:13
      events right here. We're going to be
      9:06:14
      doing the exact same thing down here.
      9:06:16
      But it's going to be a little bit more
      9:06:17
      complicated because we have a lot more
      9:06:18
      code to go through. So we're going to go
      9:06:20
      object.ent entries. We're going to take
      9:06:22
      our groups notifications just like that.
      9:06:24
      We're then going to map through these
      9:06:26
      just like this. And specifically, we
      9:06:28
      only care about the second property. The
      9:06:30
      first property's user ID. We don't even
      9:06:32
      care about that. All we care about are
      9:06:33
      the array of settings. So, we'll just
      9:06:35
      put a comma here to denote that we only
      9:06:37
      want the second property. And we're
      9:06:39
      going to get just the second property
      9:06:40
      from here. And then for some reason,
      9:06:42
      object. It has some weird interaction.
      9:06:45
      So, like with with group by and
      9:06:46
      everything, it thinks that settings
      9:06:47
      could be null for some reason. So if
      9:06:50
      it's null or the settings.length
      9:06:53
      is equal to zero,
      9:06:56
      we're just going to return null. This
      9:06:57
      should physically be impossible, but for
      9:06:59
      some reason object.ent entries is not
      9:07:01
      the greatest API. So it doesn't really
      9:07:02
      know that. Next, I want to get my
      9:07:04
      username. That's just settings uh the
      9:07:07
      first one user.name because we know it's
      9:07:10
      the same user for all of these. So the
      9:07:11
      username is going to be the same for all
      9:07:12
      of them. And same thing here, the user
      9:07:14
      email.
      9:07:16
      This is going to be exactly the same for
      9:07:18
      all of them because we grouped by that
      9:07:19
      user ID and then we can get the
      9:07:21
      applications that fall under their
      9:07:22
      filter. So we can say filtered
      9:07:24
      applications equals applications.filter
      9:07:28
      and we want to filter all the
      9:07:29
      applications that fall under our setting
      9:07:31
      criteria. So we can say return
      9:07:33
      settings.find
      9:07:36
      where the s.organization organization ID
      9:07:38
      is equal to the job listing organization
      9:07:41
      ID just like that and the minimum rating
      9:07:45
      is either equal to null or we have the a
      9:07:49
      rating which could be a null value. So
      9:07:52
      by null value we'll default that to
      9:07:54
      zero. We want to check that that's
      9:07:55
      greater than or equal to the minimum
      9:07:57
      rating. There we go. And I want to clean
      9:07:59
      up my parentheses a little bit because
      9:08:00
      this should be grouped with the section
      9:08:02
      below it right here. There we go. And of
      9:08:05
      course, it looks like I need another
      9:08:06
      parenthesy in here. So, what this code
      9:08:08
      is doing is it's saying, okay, all of
      9:08:09
      the applications that have been applied
      9:08:10
      for, I want to only get applications
      9:08:13
      that either that both match the
      9:08:15
      organization I'm a part of. So, if I'm
      9:08:17
      not a part of an organization that had
      9:08:18
      an application, obviously, don't send
      9:08:20
      that to me. So, only organizations I'm a
      9:08:22
      part of and only ones that are at least
      9:08:23
      my minimum rating or higher. Then, once
      9:08:25
      we're done with that, we can map this
      9:08:27
      into the exact format we want for
      9:08:28
      sending out our emails. So, we can just
      9:08:30
      do a quick map here for all of our
      9:08:31
      applications. And we want to return our
      9:08:33
      organization
      9:08:35
      ID, which is going to be
      9:08:37
      joblisting.organization.
      9:08:38
      ID. I want to do the exact same thing
      9:08:40
      with my organization name. And this is
      9:08:43
      just kind of collapsing this down into a
      9:08:44
      single format, which is easier to pass
      9:08:46
      around. We're going to do our job
      9:08:48
      listing ID, which is job listing ID. Do
      9:08:51
      the exact same thing with our job
      9:08:52
      listing title.
      9:08:55
      Down here, we can get our title. And
      9:08:58
      then finally our username which we
      9:08:59
      already know is our username and our
      9:09:02
      rating which is our rating. And actually
      9:09:05
      this username is different because this
      9:09:07
      is the name of the person applying. So
      9:09:08
      we want to get that specifically and we
      9:09:10
      also want to get the rating
      9:09:11
      specifically. This username up here is
      9:09:13
      the person that's receiving the email.
      9:09:14
      This down here is the person applying
      9:09:15
      for the job. Then once that's done,
      9:09:17
      let's minimize this and minimize this.
      9:09:19
      We can come down here and we can say
      9:09:21
      that if our filtered applications.length
      9:09:23
      length is equal to zero. Well, nobody
      9:09:25
      has applied that meet your requirements.
      9:09:28
      So, we'll just return null. And then
      9:09:29
      with all of that out of the way, we can
      9:09:31
      finally actually map this down to the
      9:09:33
      value we want cuz we're still inside
      9:09:34
      this giant map up here. And this is
      9:09:36
      where we return essentially the events
      9:09:38
      that we want to run. So, we need to give
      9:09:39
      it the name of our event as well as the
      9:09:41
      user property and the data property for
      9:09:43
      our event. And we know that that's going
      9:09:44
      to be a constant that satisfies
      9:09:47
      the get events property where we pass in
      9:09:50
      our ingest type. And we specifically
      9:09:52
      want a get event type, but we need to
      9:09:54
      create the event for this. So this event
      9:09:56
      name, I might as well just copy over
      9:09:58
      because it's quite long, is essentially
      9:09:59
      just going to be email daily
      9:10:00
      organization user applications. So we
      9:10:03
      want to create that inside of here. So
      9:10:04
      we can come right down here, create that
      9:10:07
      email or create that type and we need to
      9:10:09
      give it a data type and we need to give
      9:10:11
      it a user type. So for our specific
      9:10:13
      data, I'm going to copy this over
      9:10:15
      because we've kind of already looked at
      9:10:16
      this data right here. There we go. This
      9:10:19
      data is essentially just what we typed
      9:10:20
      into that field when we were doing our
      9:10:22
      map. You can see we have our username,
      9:10:23
      user organization ID, the organization
      9:10:25
      name, job listing ID, job listing title,
      9:10:26
      and then all of our application related
      9:10:28
      data. We're essentially we're just
      9:10:29
      getting the rating portion only. So
      9:10:30
      whatever the rating property is, we're
      9:10:32
      using that for our application. Then for
      9:10:33
      our user, it's the same exact thing,
      9:10:35
      email and name cuz we need that to be
      9:10:36
      able to send them an email. So we'll
      9:10:38
      paste that down into here. So
      9:10:39
      essentially, we're just making sure that
      9:10:40
      it matches up with this filtered
      9:10:42
      applications type. So now we can use all
      9:10:44
      that information inside of here. So we
      9:10:45
      know the name. I'll just copy that over
      9:10:47
      just like that. Then we can specify the
      9:10:49
      email and the name of the user. So this
      9:10:51
      is going to be user name and email is
      9:10:54
      user email. This is who we're sending
      9:10:55
      that to. And then here we're going to
      9:10:58
      have our applications which is our
      9:11:00
      filtered applications. Make sure I put a
      9:11:02
      comma here. And that gives us all of our
      9:11:03
      different events that we want to be
      9:11:04
      returning from this. Now I'm going to
      9:11:06
      minimize this down to our events right
      9:11:07
      here because there's a few cases where
      9:11:09
      we're returning null from this if we
      9:11:10
      don't have any data. So I want to do a
      9:11:12
      quick filter to make sure we get rid of
      9:11:14
      all those null values. So we're just
      9:11:15
      going to get rid of the null values just
      9:11:17
      like that. Then finally all the way down
      9:11:19
      here we can call step.ende event. We'll
      9:11:21
      call it send emails and we're going to
      9:11:23
      send along all those different events.
      9:11:25
      And now we just need to create the
      9:11:26
      listener for those events similar to
      9:11:28
      what we did up here where we created
      9:11:29
      that listener for this one. So I'm going
      9:11:31
      to copy over this top section of this
      9:11:33
      function. So we can come down here. We
      9:11:35
      can paste that down and make sure we
      9:11:37
      close this off. And as you can see we
      9:11:39
      just gave it a specific name and ID
      9:11:41
      name. This one again we are throttling.
      9:11:43
      Now we probably don't have to throttle
      9:11:44
      as aggressively on this one. we might as
      9:11:46
      well just bump it up to maybe like a
      9:11:47
      thousand a minute because all we're
      9:11:49
      doing is sending out emails. We're not
      9:11:50
      doing any AI stuff, but we'll still put
      9:11:52
      the throttle in there just so we don't
      9:11:53
      massively overload our email system.
      9:11:55
      Then inside of here, we're going to kind
      9:11:56
      of do the exact same thing that we did
      9:11:58
      up here. So, we're just going to pretty
      9:12:00
      much do that exact same code. We're
      9:12:01
      going to paste it down over here. You
      9:12:02
      can see we're getting our applications
      9:12:04
      from our event. We're getting our user
      9:12:05
      information. And if we have no
      9:12:06
      applications, just don't do anything.
      9:12:08
      Then, we're going to call step.run,
      9:12:10
      which is going to send our email out.
      9:12:13
      This is going to be an async function.
      9:12:16
      And this is going to essentially call
      9:12:18
      resend
      9:12:20
      that emails send. And it's going to pass
      9:12:23
      along pretty much the same information
      9:12:25
      we used up here. So I'm just going to
      9:12:26
      copy that, paste it down into here, and
      9:12:28
      change it slightly. So this is our daily
      9:12:30
      joblisting
      9:12:31
      applications.
      9:12:33
      And this is our daily job listing
      9:12:35
      application. So we're going to call this
      9:12:36
      daily application email. There we go.
      9:12:40
      And instead of passing in job listings,
      9:12:42
      we're going to pass in applications. And
      9:12:44
      then we don't even need the server URL
      9:12:46
      because we're not going to actually be
      9:12:47
      putting links to any of these specific
      9:12:48
      pages. There we go. Now we just need to
      9:12:50
      create that email and the rest of this
      9:12:51
      should all work just fine. So for this
      9:12:53
      email, what I'm going to do is I'm going
      9:12:54
      to go over to where we have our resend
      9:12:56
      component. I'm going to copy this
      9:12:57
      particular email over. I'm going to make
      9:12:59
      sure I get the name of it properly. So
      9:13:01
      we'll come in here, paste that down,
      9:13:03
      change the name of this right there, and
      9:13:04
      then I'm just going to change around
      9:13:05
      what our props are. Now I'm going to
      9:13:07
      copy over the prop for our application
      9:13:08
      because we've already looked at this
      9:13:10
      prop. It's the exact same thing that we
      9:13:11
      used in ingest. So I'm just copying it
      9:13:13
      over from there essentially. So we know
      9:13:15
      that we want to have applications the
      9:13:18
      username and that's it. We don't have
      9:13:19
      any server URL. So we just want these
      9:13:21
      two properties being passed into our
      9:13:23
      application. And this should say
      9:13:24
      application. There we go. Now also we're
      9:13:26
      going to scroll way down here to where
      9:13:27
      our default props are being defined.
      9:13:29
      Make sure we use the correct parameters
      9:13:30
      there. And we just want to make sure
      9:13:32
      instead of job listings, this should say
      9:13:34
      applications. And for now we'll just
      9:13:36
      pass it in an empty array. And we'll
      9:13:37
      come back and fill that in with real
      9:13:38
      data in just a little bit. Let's scroll
      9:13:40
      all the way back up to the top here so
      9:13:41
      we can loop through our applications.
      9:13:43
      So, this should say new
      9:13:46
      applications. Just like that. This
      9:13:48
      should say here are all the new
      9:13:49
      applications
      9:13:54
      for your job
      9:13:57
      listings. And then this is where we're
      9:13:59
      going to be getting to the confusing
      9:14:00
      part. So, we're going to close out of
      9:14:01
      this section. We don't need get badges
      9:14:02
      anymore. We can get rid of that. Now, we
      9:14:04
      can work on the actual code inside of
      9:14:05
      here because we have nesting. For
      9:14:07
      example, a user can have multiple
      9:14:09
      organization settings. They can have
      9:14:10
      multiple organizations. Each
      9:14:12
      organization can have multiple job
      9:14:13
      listings and each job listing can have
      9:14:15
      multiple applications. So, we have three
      9:14:17
      different levels of nesting. We have the
      9:14:18
      user, we have their settings, we have
      9:14:20
      the organization, and then we have the
      9:14:22
      actual applications for those uh job
      9:14:24
      listings. So, what we want to do is just
      9:14:26
      break this down into each one of those
      9:14:28
      different levels. So, we're going to say
      9:14:29
      object.
      9:14:31
      And we're going to also group by the
      9:14:33
      specific thing we want to check. So in
      9:14:34
      our case, we're going to be grouping our
      9:14:35
      applications by organization to start
      9:14:38
      with. That's kind of our top level right
      9:14:40
      here. So for each organization, we want
      9:14:41
      to group it down by a level. Then we're
      9:14:43
      going to map over the entries that we
      9:14:45
      got from that. And the entries are going
      9:14:47
      to be our org ID followed by our org
      9:14:49
      applications. There we go. And this is
      9:14:51
      going to be called org ID. There we go.
      9:14:56
      Let's get that finished off there. And
      9:14:57
      then we can actually return some value
      9:14:59
      from here. And we want to also get the
      9:15:01
      index value from this. There we go. So
      9:15:03
      here I'm going to say if my org
      9:15:04
      applications is equal to null or my org
      9:15:08
      applications.length is equal to zero
      9:15:11
      then I'm just going to return null. This
      9:15:12
      shouldn't happen but again like I said
      9:15:14
      for some reason group by entries just
      9:15:16
      don't work super well with Typescript.
      9:15:18
      Then we can kind of get to the actual
      9:15:19
      meat and potatoes here where we're going
      9:15:21
      to return our organization section.
      9:15:23
      And our organization section is going to
      9:15:25
      have a key which is going to be our org
      9:15:28
      ID. We also want to have our org name.
      9:15:31
      That's going to be our org applications.
      9:15:33
      Get the very first one and the name
      9:15:34
      because we know they all should have the
      9:15:36
      exact same name because they're all
      9:15:37
      grouped by that particular ID. Give that
      9:15:40
      quick save. So it moves on to another
      9:15:42
      line. Then we can get our applications
      9:15:44
      which is just our org applications. So
      9:15:46
      these are the applications grouped by
      9:15:47
      particular organizations. And then we're
      9:15:49
      going to have this fancy little no
      9:15:50
      margin property. We're going to say if
      9:15:52
      our index is zero, we're going to have
      9:15:54
      no margin. And that's because we can't
      9:15:55
      use the gap property. So we have to use
      9:15:57
      margin top or margin bottom. And we want
      9:15:59
      to make sure we don't put margin on the
      9:16:00
      top of the very first element. Again,
      9:16:02
      this is an issue purely with email and
      9:16:04
      not necessarily with actual CSS because
      9:16:06
      we can't use fancy CSS with emails. So
      9:16:09
      now let's create that organization
      9:16:11
      section.
      9:16:12
      We know that this is going to have an
      9:16:14
      org name.
      9:16:16
      Let's make sure we get those props in
      9:16:18
      there.
      9:16:20
      There we go. We're going to have an org
      9:16:21
      name. That's a string. We're going to
      9:16:22
      have our applications. That's an
      9:16:24
      application array. And then finally, no
      9:16:27
      margin. And that's going to be an
      9:16:28
      optional parameter which is going to be
      9:16:30
      a boolean. There we go. Now up here we
      9:16:32
      can get those values. Org name
      9:16:34
      applications and no margin which by
      9:16:38
      default we'll set to false. Now inside
      9:16:40
      of here we want to render out a section.
      9:16:42
      The section is going to have a class
      9:16:44
      name of no margin undefined. And if
      9:16:47
      there is margin we'll put margin on the
      9:16:49
      top of eight to give it a nice large
      9:16:51
      amount of space between these elements.
      9:16:53
      Then we're going to give a heading. And
      9:16:54
      this is going to be an H2 heading
      9:16:55
      because it's kind of the second level of
      9:16:57
      nesting in our application. We'll say
      9:16:59
      leading is none. Font is semibold. Text
      9:17:03
      is 3XL. Margin on top and bottom are
      9:17:06
      going to be four. So we'll use my4 just
      9:17:08
      like that. Let's close that off. Put our
      9:17:10
      org name directly inside of here and
      9:17:12
      make sure that we return this. There we
      9:17:14
      go. Then below our heading, what we can
      9:17:16
      do is another set of object entries and
      9:17:18
      object grouping. So object.ent entries
      9:17:21
      and we can put that inside of an
      9:17:23
      object.group group by. We want to group
      9:17:25
      our applications
      9:17:28
      where a joblisting ID is what we group
      9:17:30
      by. So now we're grouping by the job
      9:17:32
      listing as the next level of nesting.
      9:17:34
      And again, inside of here, we want our
      9:17:36
      job listing ID and we want our listing
      9:17:41
      applications.
      9:17:43
      And we also want to get our index so we
      9:17:44
      can make sure we can remove the margin
      9:17:46
      in certain cases. There we go.
      9:17:49
      Now, what we want to do is the exact
      9:17:51
      same if check that we were doing before.
      9:17:52
      So, if I scroll up here, we're
      9:17:53
      essentially going to do this exact same
      9:17:55
      thing. I'm just going to copy that down
      9:17:56
      because it's very similar to what we're
      9:17:58
      going to be doing. I just need to make
      9:17:59
      sure it looks like I'm missing a
      9:18:00
      parenthesy. Actually, I see the problem.
      9:18:01
      I have an extra parenthesy where I don't
      9:18:03
      need it right there. And I need to move
      9:18:05
      that parenthesy to here. There we go.
      9:18:06
      That fixed all my formatting. And now,
      9:18:08
      pretty much my listing applications, if
      9:18:10
      those are null, return null. And then we
      9:18:12
      need to render out a job listing card as
      9:18:14
      our next particular thing. So, our key
      9:18:16
      is our job listing ID. We want to get
      9:18:19
      our listing application.
      9:18:21
      the first element in it and we want to
      9:18:23
      get the job listing title. So we can
      9:18:25
      pass this along as our job listing
      9:18:28
      title. Again, we're just doing this
      9:18:30
      level of nesting essentially. And then
      9:18:31
      we can pass along all of our listing
      9:18:32
      applications. And now this job listing
      9:18:34
      card is just going to be another
      9:18:35
      component very similar to what we did
      9:18:37
      for this organization select. So we
      9:18:39
      might as well just copy it over and make
      9:18:40
      changes as needed. So up here we're
      9:18:42
      going to have our job listing title and
      9:18:46
      that's going to be in place of our org
      9:18:47
      name. Applications is going to be the
      9:18:48
      same. No margin is going to be exactly
      9:18:50
      the same here. Here, instead of
      9:18:51
      rendering out a section, we're going to
      9:18:52
      render out a div. We're going to add in
      9:18:54
      some class names. We're going to use
      9:18:55
      that CN function. And this is because we
      9:18:57
      want this to look like a card. So, we'll
      9:18:59
      use all of our different card styling.
      9:19:01
      Rounded large border. We're going to add
      9:19:04
      some padding onto this. Border primary
      9:19:07
      border solid.
      9:19:09
      And of course, we want to make sure we
      9:19:11
      do the no margin properly. So, if we
      9:19:14
      don't have no margin, then we'll add a
      9:19:15
      margin on the top of six. There we go.
      9:19:18
      Close off that div. And now what we want
      9:19:20
      to do is we want to put a heading inside
      9:19:21
      of here. And we're going to use H3
      9:19:22
      because we're on our next level of
      9:19:24
      sizing. We want to change around our
      9:19:26
      font a little bit. So we're going to
      9:19:27
      change this to a text XL. And our margin
      9:19:29
      on the bottom is going to be three for
      9:19:31
      this particular element. And margin top
      9:19:33
      of zero. Then we're going to put our job
      9:19:35
      listing title into this heading. Then
      9:19:37
      the next thing we can do is we can loop
      9:19:38
      through our applications. And finally,
      9:19:40
      we don't need to do any other layers of
      9:19:41
      nesting. So here we can just get our
      9:19:43
      applications. We can map through each
      9:19:45
      one of our applications as well as the
      9:19:47
      index for them.
      9:19:49
      and we can render out some content. So,
      9:19:51
      we're going to render a text element.
      9:19:53
      The key is going to be our index. Our
      9:19:55
      class name here is margin on the top of
      9:19:57
      two, margin on the bottom of zero. And
      9:20:00
      inside here for our text, it's going to
      9:20:02
      be pretty straightforward. We're going
      9:20:03
      to have a span that has the
      9:20:04
      application's username. So, we'll say
      9:20:06
      application. Looks like I want to remove
      9:20:08
      an s from that. There we go. Username.
      9:20:12
      We're going to put a colon and a space
      9:20:13
      after that. And then below that, we're
      9:20:14
      going to get our rating icons. So, we're
      9:20:16
      going to say rating icons. pass in our
      9:20:18
      rating which is our application.rating
      9:20:21
      just like that. But we can't use our
      9:20:23
      rating icons component. The reason for
      9:20:25
      that is our rating icons component uses
      9:20:26
      SVG which don't work very well inside of
      9:20:29
      emails. So we need to create our own
      9:20:30
      rating icons component which is going to
      9:20:32
      look almost exactly the same. You'll
      9:20:33
      notice we have the same if check. We
      9:20:35
      have the same for loop but instead of
      9:20:36
      using an icon we're just using the font
      9:20:39
      of a star or a non-filled star. So this
      9:20:41
      is just using this specific font. Also
      9:20:43
      for some reason the height property
      9:20:45
      doesn't work in some email clients. So
      9:20:46
      instead of specifying a height, I'm
      9:20:48
      specifying a width. And then I'm using
      9:20:49
      margin bottom of negative to be able to
      9:20:51
      get my centering perfectly right, which
      9:20:53
      what I would normally do using height.
      9:20:55
      So as you can see, we have some weird
      9:20:56
      email tricks going on here just to make
      9:20:58
      sure this works with an email properly.
      9:21:00
      Now let's go down here and actually put
      9:21:01
      in some placeholder applications. I'm
      9:21:03
      just going to copy these over cuz this
      9:21:04
      part doesn't really matter. You can just
      9:21:05
      see some of these are for the same
      9:21:06
      organization, some are for different
      9:21:08
      organizations, some are for the same job
      9:21:10
      listing, some are for different job
      9:21:11
      listings. So you can see that it kind of
      9:21:12
      maps between all that different stuff.
      9:21:14
      And what we want to do is go over here
      9:21:15
      where our actual emails are loaded up.
      9:21:17
      So we can click on this page. We can
      9:21:19
      open up the section for our daily
      9:21:20
      application email. And you can see what
      9:21:22
      this looks like. You can see here's our
      9:21:23
      new applications person's name. And you
      9:21:25
      can see here's the applications for this
      9:21:27
      job. You can see we grouped it by
      9:21:28
      organization, by job listing. And then
      9:21:31
      we have all the applicants. Same thing
      9:21:32
      here. This person's unrated. And then
      9:21:34
      finally, we have another job down here
      9:21:35
      for a completely different organization
      9:21:36
      that this person's a part of. Now, we
      9:21:38
      just need to test to make sure that this
      9:21:39
      actually works within our actual system.
      9:21:41
      So go over to email. Let's make sure we
      9:21:42
      import this properly. There we go. We
      9:21:44
      then need to take these two functions
      9:21:46
      and we need to make sure we put them in
      9:21:47
      our ingest server. So, go all the way up
      9:21:49
      to app API ingest right here.
      9:21:53
      So, let's paste down this one. And then
      9:21:56
      we also have one called prepare. There
      9:21:58
      we go. That's all of our different
      9:21:59
      emails. We might as well group these
      9:22:01
      together. We'll put those ones together.
      9:22:02
      Put these ones together. So, now
      9:22:04
      hopefully that's everything that we need
      9:22:05
      to actually have the emails be sending
      9:22:06
      to someone. So, let's go ahead and test
      9:22:08
      this out. We'll go to our ingest dev
      9:22:09
      server again. Looks like we're having an
      9:22:11
      error syncing with our application. Let
      9:22:13
      me just try refreshing. That still
      9:22:14
      doesn't look like it's working. So, what
      9:22:16
      I want to do is make sure everything is
      9:22:17
      good inside of here. Says that we're
      9:22:19
      having an issue with trying to get a
      9:22:20
      command duplicate function ID. Looks
      9:22:22
      like we're maybe importing the same
      9:22:24
      function multiple times. Yeah, we are
      9:22:25
      importing this one multiple times. Let's
      9:22:27
      get rid of that. That should hopefully
      9:22:29
      fix the problem once it syncs up. We may
      9:22:30
      need to restart our server. Actually,
      9:22:32
      let's try that. And actually, I'm
      9:22:34
      importing this one multiple times, too.
      9:22:36
      So, I want to prepare my organization
      9:22:37
      ones. There we go. That should fix the
      9:22:39
      error completely. Now, we don't have any
      9:22:40
      duplicates. I don't think at least. So,
      9:22:42
      we have delete org membership. I don't
      9:22:44
      see my create org membership on here.
      9:22:45
      So, let's make sure we put that clerk
      9:22:47
      create organization membership.
      9:22:50
      Actually, I called it or membership.
      9:22:52
      There we go. So, now we should have all
      9:22:53
      of our different functions hooked up.
      9:22:54
      You can see that they're all found
      9:22:55
      properly. Let's go over to them. Make
      9:22:57
      this a little bit bigger. What I want to
      9:22:59
      do is I want to send my daily user
      9:23:00
      application email. So, let's go over
      9:23:02
      here. We're going to invoke that.
      9:23:03
      Actually, no, not that one. I'm sorry.
      9:23:04
      We want to prepare our daily
      9:23:06
      organization application email. So,
      9:23:08
      let's go ahead and prepare that. You can
      9:23:09
      see it's running and you can see it
      9:23:11
      actually spun off an event for sending
      9:23:12
      that email to me. So you can see here it
      9:23:14
      sent along all this information to me
      9:23:16
      about the new applicants because I
      9:23:17
      signed up to receive those emails and I
      9:23:19
      only wanted to receive people that were
      9:23:21
      three stars and above which is why it
      9:23:22
      didn't send us the person that was under
      9:23:24
      three or under three stars. And if I
      9:23:25
      pull up my email real quick, you can
      9:23:26
      actually see this sent along the email
      9:23:28
      with that specific user that applied for
      9:23:30
      the job as well as their rating. So we
      9:23:31
      can see that that is working as we
      9:23:32
      expect. Now with that done, we're
    </chapter>
    <chapter title="Job listing application management" start_time="9:23:33">
      9:23:34
      dangerously close to being done with
      9:23:35
      this entire application. But we have one
      9:23:37
      quite major section of our application
      9:23:39
      to finish. If we go over to one of our
      9:23:41
      job listings, you'll notice that we have
      9:23:42
      no way to view which users have actually
      9:23:44
      applied for the job or not. There should
      9:23:46
      be a section down here that has a table
      9:23:48
      for all the users that have applied for
      9:23:49
      our job. And that's the section I want
      9:23:51
      to work on next. Not only a full table
      9:23:53
      to view all of that, but it's going to
      9:23:54
      have proper pageionation, sorting,
      9:23:55
      filtering, and the ability to update the
      9:23:57
      user information, view their resume, and
      9:23:59
      so much more. It's going to be packed
      9:24:00
      full of information. So, what we can do
      9:24:02
      is we can come all the way over here to
      9:24:04
      our application and we can go back to
      9:24:06
      the page for this. So, let's just close
      9:24:07
      out of everything that we have open.
      9:24:09
      We're going to go into our source app,
      9:24:10
      the employer section, and we want to go
      9:24:12
      specifically to the job listing page.
      9:24:14
      And at the bottom here below our
      9:24:15
      markdown partial, this is where I want
      9:24:16
      to render this out. I'm going to put a
      9:24:18
      separator component. So, we got our
      9:24:20
      separator. We're going to make sure we
      9:24:22
      import that from the correct location.
      9:24:23
      That'll just add a nice little line at
      9:24:24
      the bottom here for us to be able to
      9:24:26
      separate this content. And then what we
      9:24:28
      can do below that is we can add in a div
      9:24:30
      here with a class name of space Y6.
      9:24:34
      Then we're going to put a heading and
      9:24:36
      this is going to have a text of
      9:24:37
      applications.
      9:24:39
      And this is going to have a class name
      9:24:40
      of text extra large font semibold. There
      9:24:43
      we go. So now we should hopefully see
      9:24:45
      that showing up on our screen over here.
      9:24:46
      Now below that we can come in here with
      9:24:48
      a suspense component because we want to
      9:24:50
      essentially wrap a page that's going to
      9:24:51
      do a lot of suspense stuff for us. So
      9:24:53
      we're going to come in here. This is
      9:24:55
      going to say applications and we're
      9:24:57
      going to have a job listing ID that's
      9:24:58
      going to pass in whatever the job is
      9:25:00
      going to be. So there we go. That's the
      9:25:02
      job we're getting the applications for.
      9:25:03
      And for this I want to have a fallback
      9:25:05
      and the fallback is going to be a
      9:25:06
      skeleton loader. So we're going to say
      9:25:08
      skeleton application table which we're
      9:25:10
      essentially going to create when we
      9:25:12
      create our application table. So we can
      9:25:13
      have a loading state and a non-loaded
      9:25:15
      state. Now let's go all the way down
      9:25:17
      here quite a ways below all this and
      9:25:19
      we'll create that function for our
      9:25:20
      applications. It's taking in just a job
      9:25:22
      listing ID. And inside of here, we want
      9:25:24
      to return essentially an application
      9:25:26
      table. But first of all, before we do
      9:25:27
      that, we want to get our applications.
      9:25:29
      That's just going to be calling get job
      9:25:32
      listing applications. It's going to take
      9:25:34
      in a job listing ID. And this function
      9:25:36
      is relatively straightforward, but a
      9:25:37
      little bit long. So, I'm going to paste
      9:25:38
      it in. And I'll explain exactly what
      9:25:40
      every line is doing for you. But if we
      9:25:42
      take a look at this function,
      9:25:43
      essentially all we're doing is making
      9:25:44
      sure we cache everything properly. We're
      9:25:46
      querying our database table specifically
      9:25:48
      where the job listing ID is equal to
      9:25:49
      that ID. So, we're getting all of the
      9:25:51
      applications for a particular ID. And
      9:25:53
      then this entire section down here is
      9:25:55
      just me only returning the exact columns
      9:25:57
      I need of data. That way, I don't return
      9:25:59
      extra data that I don't need.
      9:26:00
      Essentially, you could remove this
      9:26:02
      entire section and your function would
      9:26:03
      still work the same. This just makes it
      9:26:04
      work a little bit better with our code.
      9:26:06
      Now, finally, down here, I'm also doing
      9:26:08
      some additional cache tagging. So, as
      9:26:10
      you can see, I'm using user information
      9:26:12
      and resume information. So, I'm also
      9:26:14
      making sure I cash tag on those as well.
      9:26:16
      That way, if a user updates their name
      9:26:17
      or they update their resume, this is
      9:26:19
      going to update that information as
      9:26:21
      well. Now, if we scroll all the way back
      9:26:22
      up here, we can return an application
      9:26:24
      table, which is a function that we're
      9:26:26
      going to create, just a component to
      9:26:27
      render all of our table related stuff,
      9:26:29
      but this is going to be a client
      9:26:30
      component. So, we need to make sure we
      9:26:31
      pass down anything we need from the
      9:26:33
      server. So, for example, we're going to
      9:26:34
      pass in our applications
      9:26:37
      just like that. We're also going to be
      9:26:39
      passing in the can update rating. So, we
      9:26:41
      need to know can they update the rating?
      9:26:43
      And this is something we need to get
      9:26:44
      from the server because we need to check
      9:26:45
      their organization permissions for if
      9:26:48
      they can update this. So we can see here
      9:26:49
      that is for changing the rating. Let's
      9:26:51
      make this a little bigger so it's easier
      9:26:53
      to see. There we go. And then what we
      9:26:55
      want to do all the way down here is we
      9:26:56
      want to do another check. Whoops, copied
      9:26:59
      the wrong code. Copy this code. There we
      9:27:01
      go. We want to check can they update the
      9:27:03
      stage. Can update stage. And this is
      9:27:06
      going to be change stage. There we go.
      9:27:09
      So this just has our permissions set up.
      9:27:11
      So now we need to create this
      9:27:12
      application table as well as the
      9:27:14
      skeleton for it. Now for this
      9:27:15
      application table we can create a
      9:27:17
      component for it. So we'll go into our
      9:27:18
      features into the job listing
      9:27:20
      application section and components and
      9:27:22
      we'll call this our application
      9:27:25
      table.tsx
      9:27:27
      export a function application table just
      9:27:31
      like that. And we need to make sure that
      9:27:32
      this is a client component. Now we can
      9:27:34
      at least return null from here and we
      9:27:37
      can hopefully import that up here to at
      9:27:39
      least get rid of some of those errors.
      9:27:40
      We'll get errors on our imports here for
      9:27:42
      our props because we haven't defined
      9:27:43
      those yet. But that's fine. Now, for
      9:27:45
      this application table, we're actually
      9:27:46
      going to be using the data table from
      9:27:48
      shad CN which com binds together tan
      9:27:50
      stacks table along with their own table
      9:27:52
      component. So, let's make sure that we
      9:27:53
      run these different commands. So, we're
      9:27:55
      going to come down here and we're going
      9:27:56
      to make sure we get a brand new terminal
      9:27:58
      to do this. And we're going to paste in
      9:27:59
      the command for shad cen to install the
      9:28:01
      table. And then we're also going to be
      9:28:02
      installing our tan stack library for the
      9:28:04
      React table. So, we're going to add the
      9:28:05
      table component which is going to be
      9:28:07
      really useful for our styling purposes.
      9:28:09
      And then this tan stack library is
      9:28:10
      really really powerful and there's tons
      9:28:12
      of different stuff we can do with it.
      9:28:13
      And there's a lot of other components
      9:28:15
      built into here that we can use as well.
      9:28:17
      So let's make sure that this is React
      9:28:19
      table. Want to force that. And I believe
      9:28:21
      yes, React Table. There we go. And this
      9:28:24
      should see npm at the start. There we
      9:28:26
      go. So that's going to install that for
      9:28:28
      us. And as you can see, there's a ton of
      9:28:29
      different stuff about how to make all of
      9:28:31
      this work. I'll be explaining most of it
      9:28:32
      in depth and going through exactly how
      9:28:34
      everything works. But essentially, we're
      9:28:35
      going to be using some of the base
      9:28:36
      boilerplate components from here. For
      9:28:38
      example, they have this data table
      9:28:40
      component and so on that we can use. So,
      9:28:42
      what I want to do to get started is just
      9:28:43
      to copy over their starting point data
      9:28:45
      table. We're going to make quite a bunch
      9:28:46
      of heavy modifications to it to make it
      9:28:48
      work with our application. We're going
      9:28:49
      to come in and we're going to put that
      9:28:50
      inside of our components folder. So,
      9:28:52
      we're going to find where our components
      9:28:53
      folder is. We're going to create a brand
      9:28:54
      new folder for our data table related
      9:28:56
      stuff and we'll create a brand new
      9:28:58
      component called data table.tsx. We're
      9:29:01
      just going to paste all the code from
      9:29:02
      the data table that they gave us
      9:29:04
      directly into there. So we have all of
      9:29:05
      that code working just fine in our
      9:29:07
      application table. We can actually use
      9:29:08
      that data table. Now in order to render
      9:29:10
      out a data table, we need columns. So
      9:29:12
      we're going to create a function that
      9:29:13
      gets us all of our different column
      9:29:15
      data. So we're going to say get columns.
      9:29:17
      This is going to take can update rating
      9:29:19
      and it's going to take can update stage
      9:29:22
      as some booleans that we pass in and
      9:29:24
      it's going to return to us a column
      9:29:26
      defaf and we're going to have it be for
      9:29:28
      our application. Now, this application
      9:29:30
      is a type that I'm going to paste in and
      9:29:32
      then go through line by line because
      9:29:33
      it's a little bit of a complicated type,
      9:29:34
      but essentially it's all the stuff that
      9:29:36
      we're able to pass into our particular
      9:29:37
      table. So, if we take a look at this
      9:29:39
      code real quick, you can see the very
      9:29:41
      first thing that we're getting is all of
      9:29:42
      these columns from our application
      9:29:44
      table. So, the cover letter created at
      9:29:45
      stage, rating, job listing, and then
      9:29:47
      we're combining that together with our
      9:29:48
      cover letter as markdown. And actually,
      9:29:50
      since we're already getting our cover
      9:29:51
      letter as markdown, we don't need it up
      9:29:53
      here, which is great. So, we're getting
      9:29:54
      our cover letter as markdown. We're
      9:29:55
      getting our user information, the ID,
      9:29:57
      the name, the URL. We're also getting
      9:29:58
      the resume information and specifically
      9:30:00
      we're getting the ré fire URL and we're
      9:30:02
      getting the markdown summary as a react
      9:30:04
      node. Now the reason that we're having
      9:30:06
      to pass down these values as markdown as
      9:30:08
      opposed to as a string is because the
      9:30:10
      markdown renderer that we use only works
      9:30:12
      on the server and this is a client
      9:30:14
      component. So we have to pass down those
      9:30:16
      server components pre-rendered into our
      9:30:18
      code. So really this is just mapping up
      9:30:20
      pretty much one to one to our
      9:30:22
      applications component here because it's
      9:30:23
      just taking all this information and
      9:30:25
      putting it in a JSON version that we can
      9:30:26
      use as a type. So we're using that as
      9:30:28
      the type for our particular column. So
      9:30:30
      each of our columns is going to get
      9:30:31
      information from this particular type
      9:30:33
      which is what's passed into here. So for
      9:30:35
      example, our applications are passed
      9:30:37
      into here
      9:30:39
      and it has that type of application
      9:30:41
      array. Now for our columns, I'm just
      9:30:42
      going to start by showing you the most
      9:30:43
      basic type of column that we can do. So
      9:30:45
      here we're going to return an array and
      9:30:47
      this array is going to give us a few
      9:30:48
      different things. We have our accessor
      9:30:50
      key or function. For example, the
      9:30:51
      accessor key we could pass in like title
      9:30:53
      and it'll get us like title. But in our
      9:30:55
      case, most often we're going to have to
      9:30:56
      use an accessor function which is going
      9:30:58
      to take in whatever our row is and it's
      9:31:00
      going to return us some data. So our row
      9:31:02
      is just an application. So we can use
      9:31:03
      our row user.name just like that. Now we
      9:31:06
      are getting an error because I need to
      9:31:07
      make sure that this is an array of
      9:31:09
      values. And now you can see that this is
      9:31:10
      actually giving us a new error. But at
      9:31:11
      least it's working. Next, we can specify
      9:31:13
      the header. In our case, the header is
      9:31:15
      going to be name. That's like the string
      9:31:16
      text that we're going to be using. And
      9:31:18
      this name value here is the value in our
      9:31:20
      column. So this is the value for each
      9:31:22
      cell. And this is the header for our
      9:31:23
      entire column. Next, we're going to
      9:31:25
      specify the cell, which is essentially
      9:31:27
      like the value that we're going to be
      9:31:28
      rendering out on the screen. This is the
      9:31:30
      React node. So, this accessor function
      9:31:31
      is great for like sorting and filtering.
      9:31:33
      And this is great for actually showing
      9:31:35
      what our content will look like. Now, in
      9:31:36
      our particular case, this is going to
      9:31:38
      take in our row, which is all of our
      9:31:39
      data that we want. And what we can do
      9:31:41
      inside of here is we can say row.or
      9:31:44
      user.name. And that's going to give us
      9:31:46
      whatever essentially the name of our
      9:31:48
      user is. This original just asks us what
      9:31:50
      the current cell value is. So I can just
      9:31:52
      say const user is equal to that and get
      9:31:54
      my information like this. And then we
      9:31:56
      can do different things like getting the
      9:31:57
      initials of that user. So I can say I
      9:31:59
      want to get the initials of that user
      9:32:00
      from that user object that I created
      9:32:02
      just like that. And then we can come
      9:32:03
      down here and return some information
      9:32:05
      for our user. So I'm going to again copy
      9:32:07
      over the code for this because we've
      9:32:08
      done this avatar stuff a million times.
      9:32:10
      So I want to get those avatar components
      9:32:12
      installed. Just like that. We're getting
      9:32:15
      those from that user object that we just
      9:32:16
      created. So essentially what I'm doing
      9:32:18
      is I'm taking my user's image and I'm
      9:32:20
      rendering that out. Otherwise, I'm
      9:32:21
      showing their name, initials, and then
      9:32:22
      I'm showing their name right next to it.
      9:32:24
      This is very similar to what we did on
      9:32:25
      our sidebar. So, if we maximize this a
      9:32:27
      little bit, and of course, it looks like
      9:32:28
      it's not going to render because we need
      9:32:30
      to make sure everything is importing
      9:32:31
      properly. Looks like if we scroll all
      9:32:33
      the way up, it's because of this
      9:32:34
      skeleton table right here. So, let me
      9:32:36
      just make sure we create this skeleton
      9:32:38
      table so we at least can get our page to
      9:32:39
      render. So, I'm going to come all the
      9:32:41
      way down here,
      9:32:43
      export function skeleton table, and this
      9:32:46
      will just return null, just so we have
      9:32:48
      something showing up. And we'll just put
      9:32:49
      a nice little to-do above that so we
      9:32:51
      know to come back. Then we can import
      9:32:53
      this table here. There we go. And
      9:32:55
      hopefully that'll get rid of the errors
      9:32:56
      and at least we have something
      9:32:57
      rendering. So in our application table,
      9:32:58
      we can render out some content. But
      9:33:00
      essentially what I'm trying to say is
      9:33:01
      that avatar section is just this. It's
      9:33:03
      just this section with a name at the
      9:33:04
      top. We've done that a million times. So
      9:33:06
      now we can go back into our application
      9:33:08
      table and we can try to write out what
      9:33:10
      this column will look like. Now that we
      9:33:11
      have our columns, we can render it out
      9:33:12
      in a data table. So we can say data
      9:33:15
      table just like this. And we want to get
      9:33:17
      our columns for this. So we can say
      9:33:19
      columns is equal to get columns. And
      9:33:22
      we'll just pass along true for now for
      9:33:23
      both of those properties. Also, our data
      9:33:25
      table requires us to pass in data, which
      9:33:27
      is going to be our applications. Just
      9:33:29
      like that. And now that'll actually
      9:33:30
      render out a table. And as you can see,
      9:33:31
      it has a name property with that image
      9:33:33
      as well as the name of the particular
      9:33:34
      user. And if we had multiple people that
      9:33:36
      applied to this job, we'd have multiple
      9:33:38
      listings inside of here. Now, we know
      9:33:39
      for a fact here that we have can update
      9:33:41
      rating that we can get. So we have these
      9:33:43
      values that we know for a fact are being
      9:33:45
      passed in. So we might as well use
      9:33:46
      these. So this first value for get
      9:33:48
      columns is the can update rating. So let
      9:33:50
      me just pass in can update rating and
      9:33:53
      can update stage. So at least we get
      9:33:54
      those values being passed in. So we kind
      9:33:56
      of have our data table set up. Now I
      9:33:58
      just want to render out the data that's
      9:33:59
      going to go into my table before we
      9:34:00
      start adding on all of the additional
      9:34:02
      features on top of this. So let's go up
      9:34:04
      and start working on some of our more
      9:34:05
      complicated columns that we have to deal
      9:34:07
      with. And the first complicated column
      9:34:08
      that we have to deal with is the stage
      9:34:10
      column. So we can say our accessor key
      9:34:12
      for this one is going to be stage. Just
      9:34:14
      like that. because we know that that is
      9:34:15
      going to be a column directly from our
      9:34:17
      table. There we go. Next thing that we
      9:34:18
      can do is we can specify what the header
      9:34:20
      is going to be. And the header for this
      9:34:21
      is actually going to be a sortable
      9:34:23
      column header, which is something that
      9:34:25
      comes from shad CN. If we just expand
      9:34:27
      this quite a bit, so we have full screen
      9:34:28
      view of this. And we come and actually
      9:34:30
      make it even bigger. There we go. We can
      9:34:33
      see over here on the side that we
      9:34:34
      actually have some cell formatting, some
      9:34:36
      row action, some pageionation, some
      9:34:37
      sorting and so on. And if we look, we
      9:34:39
      actually have the ability to update our
      9:34:40
      table. And then at the very bottom here
      9:34:42
      have some different reusable components
      9:34:44
      we can use. So for example, if we want a
      9:34:46
      data column that is sortable, we can
      9:34:48
      just copy over this component and it'll
      9:34:49
      give us a sortable hidable version of
      9:34:51
      this. So I'm going to go ahead and I'll
      9:34:52
      copy that over and we're going to use
      9:34:54
      that component inside of our
      9:34:55
      application. So I'll come over here and
      9:34:57
      inside of my data table section, I will
      9:35:00
      create a data table sortable
      9:35:03
      column header.tsx
      9:35:06
      and I'll paste in this exact component
      9:35:08
      right here. Now we're going to have to
      9:35:09
      make some pretty major changes. For
      9:35:10
      example, these imports are broken. So,
      9:35:11
      let's go ahead and fix those imports
      9:35:13
      ourself. For example, drop down menu we
      9:35:15
      want to get from here. Same thing with
      9:35:17
      this one. Our button we want to get from
      9:35:19
      the correct location. And same thing
      9:35:21
      down here. Let's get these imported. So,
      9:35:23
      at least that looks like it fixes all of
      9:35:25
      our import issues. Next thing that we
      9:35:27
      need to do is we need to name this the
      9:35:29
      same thing we named ours. We called it a
      9:35:30
      sortable column header. There we go.
      9:35:32
      This is going to be our sortable column
      9:35:34
      header props just to make sure our names
      9:35:36
      are consistent. Next thing we need to do
      9:35:38
      to make some changes is they have the
      9:35:39
      ability to hide columns inside of here.
      9:35:41
      You'll scroll down, you can see that
      9:35:42
      they have this hide section. We don't
      9:35:43
      actually care about hiding things. So
      9:35:45
      instead of having this be a hide
      9:35:46
      section, we're going to have it be the
      9:35:47
      ability to clear our sorting. So we're
      9:35:49
      going to add clear sorting to this
      9:35:51
      because they don't actually have a
      9:35:52
      button for clearing your sorting. They
      9:35:53
      just have the ability to hide. So we're
      9:35:54
      going to change this to an X icon. And
      9:35:56
      this will say clear just like that. So
      9:35:58
      now we have the ability to sort
      9:35:59
      ascending, descending, and clear. And
      9:36:01
      that uses this column. Sorting, toggle
      9:36:03
      sorting, toggle sorting. It's all built
      9:36:05
      into that React table from tan stack.
      9:36:07
      Now, the next thing that we need to do
      9:36:08
      to be able to make sure that this
      9:36:09
      actually functions properly is we need
      9:36:11
      to modify our data table to make sure
      9:36:13
      that it has the ability to be sorted cuz
      9:36:15
      right now we don't have any sorting
      9:36:16
      built in. So, we're going to say that we
      9:36:18
      want to have some sorting functionality.
      9:36:19
      So, we're going to say get sorted ro
      9:36:21
      model is equal to get sorted ro model
      9:36:23
      which is the default behavior. We're
      9:36:25
      also going to have an on sorting change
      9:36:26
      function that we need to pass in and
      9:36:28
      that's going to be using some state. So,
      9:36:30
      we're going to come up here by saying
      9:36:31
      sorting set sorting is equal to use
      9:36:35
      state and that's going to use the
      9:36:37
      sorting state.
      9:36:39
      There we go. And that's just a type
      9:36:41
      again built into React table. So, we can
      9:36:44
      use that. We can make sure we put a
      9:36:45
      comma there. Also, we need to be able to
      9:36:47
      pass in some state. So, below all this,
      9:36:49
      we're going to pass in state. And the
      9:36:52
      state contains our sorting state. So,
      9:36:54
      we'll say sorting just like that. And
      9:36:56
      that's going to take our sorting state.
      9:36:57
      So this is just telling React Table,
      9:36:59
      hey, here's all the information you need
      9:37:00
      to be able to sort out our information.
      9:37:02
      So now we can give all of this a save.
      9:37:03
      We can make sure inside of here we're
      9:37:05
      getting our header information from that
      9:37:06
      sortable table. So we can say column,
      9:37:10
      we want to render out a data
      9:37:13
      table, sortable column, pass it in our
      9:37:16
      title, which is just going to be stage,
      9:37:19
      and we can pass it in all of our column
      9:37:20
      information. So it can do that sorting
      9:37:22
      for us. So at least now we have that
      9:37:24
      information. And hopefully if we come
      9:37:26
      back over here, we should see now we
      9:37:27
      have our stage showing up. Obviously
      9:37:28
      nothing's formatted properly, but we
      9:37:30
      have the ability to sort it ascending,
      9:37:31
      descending, or to clear our sorting.
      9:37:34
      Next up, we need to create a sorting
      9:37:35
      function so it knows how to sort
      9:37:37
      properly because we actually are sorting
      9:37:38
      this a little bit differently than you
      9:37:39
      would normally expect. So we have our
      9:37:41
      original, which we're going to call A.
      9:37:44
      There we go. And then we're going to get
      9:37:46
      our second property, which is original
      9:37:47
      here, which we're going to rename to B.
      9:37:49
      So we essentially have an A and a B
      9:37:50
      property. And then we want to return
      9:37:54
      call sort applications by stage which is
      9:37:57
      a function we're going to create which
      9:37:59
      is going to take in our stage for both
      9:38:00
      of these. This is going to be very
      9:38:02
      similar to how we did our sorting on our
      9:38:04
      other one. So inside of our job listing
      9:38:06
      applications we're going to create a new
      9:38:07
      folder called lib. And inside of here
      9:38:09
      we're going to create a utils function
      9:38:11
      or a utils file. And I'm just going to
      9:38:13
      paste in what that sort is. You can see
      9:38:15
      it's exactly the same as how we sorted
      9:38:16
      before. I want my applied interested
      9:38:19
      interviewed and hired to be all on top.
      9:38:20
      and denied shows up at the very bottom
      9:38:22
      as the last option because if you denied
      9:38:23
      someone, you probably want to sort them
      9:38:25
      at the very bottom. So, let's just sort
      9:38:26
      it in the most logical order possible.
      9:38:28
      Next up, we can make sure we import that
      9:38:30
      properly. There we go. And looks like I
      9:38:33
      spelled original wrong here.
      9:38:35
      There we go. So, now we have our sorting
      9:38:37
      function done. We also need to be able
      9:38:38
      to do some filtering. We'll be doing
      9:38:40
      that in a little bit. We don't have
      9:38:41
      filtering implemented, but we need to
      9:38:42
      make sure that we filter things
      9:38:44
      properly. So, this is going to take in
      9:38:45
      original. It's also going to take in a
      9:38:46
      property that we don't care about. And
      9:38:48
      then finally, it's going to take in a
      9:38:49
      value. So what we can do with this is
      9:38:51
      we're going to return to see if our
      9:38:53
      value includes
      9:38:55
      the original.stage. So this value is
      9:38:58
      essentially what we're sorting by. It's
      9:38:59
      going to be an array. Original is the
      9:39:01
      actual value of our cell. So we're just
      9:39:02
      saying, hey, does our value of arrays
      9:39:04
      match whatever we're sorting by. So
      9:39:06
      we're just matching this cell to see if
      9:39:07
      it's in that value. Finally, we get to
      9:39:09
      the complicated part here, which is
      9:39:11
      going to be rendering out our cell. And
      9:39:12
      we're going to be taking in the row
      9:39:14
      information. And then we're going to
      9:39:16
      come down here and we're going to return
      9:39:17
      a stage cell which is a component that
      9:39:19
      we're going to create and we're going to
      9:39:20
      pass in all the information we need such
      9:39:22
      as can we update this which we'll call
      9:39:25
      can update stage. There we go. We're
      9:39:28
      also going to take in the stage value
      9:39:29
      which is row.or original.stage.
      9:39:32
      Next we're going to get the job listing
      9:39:34
      ID so that we can actually call some
      9:39:35
      actions to update this row.listing
      9:39:39
      ID. Then finally the user ID which is
      9:39:41
      for our users row. So like whoever is
      9:39:43
      applying and again we need that to
      9:39:45
      update their information. So we're just
      9:39:46
      going to get all that information like
      9:39:47
      this and pass it down. So now we can
      9:39:49
      create that function. We'll do it down
      9:39:51
      here. Stage cell and we're just going to
      9:39:54
      return null. So at least we get rid of
      9:39:55
      all of our errors. Now we already know
      9:39:57
      what the props of the stage cell are.
      9:39:58
      We'll just paste those in because we
      9:40:00
      already typed those out. So we know
      9:40:01
      exactly what those are. And the next
      9:40:02
      thing I want to do is I want to render
      9:40:03
      out this information. And essentially I
      9:40:05
      want to create a drop down that when I
      9:40:06
      change the value, it's going to update
      9:40:08
      that on my database and so on. And this
      9:40:10
      is going to be almost identical to how
      9:40:12
      we do ratings. So the nice thing is once
      9:40:13
      we finish it for stage, the rating
      9:40:15
      section is going to be relatively
      9:40:16
      simple. So the very first thing that I
      9:40:18
      want to do, it just want to come in
      9:40:19
      here. I'm going to create an optimistic
      9:40:23
      stage and set optimistic
      9:40:26
      stage. We're going to set that equal to
      9:40:28
      the use optimistic hook because we're
      9:40:30
      going to be using optimistic updates for
      9:40:31
      this section to give us the best user
      9:40:33
      experience. Also, we're going to need to
      9:40:35
      have a transition. So we'll say is
      9:40:37
      pending and start transition. There we
      9:40:40
      go. That'll be equal to use transition.
      9:40:43
      Now the next thing I want to do is I
      9:40:44
      want to check to see hey can the user
      9:40:46
      update? If they can't make an update
      9:40:48
      well then we just want to return
      9:40:49
      whatever our stage details are. So we'll
      9:40:51
      create a component called stage details.
      9:40:53
      Pass it in our stage and we'll pass it
      9:40:55
      in whatever the actual optimistic stage
      9:40:58
      is. Just like that. There we go. Now
      9:41:00
      before we get any further let's just
      9:41:02
      create this simple component. So we'll
      9:41:04
      say function stage details. This we know
      9:41:07
      is taking in a stage. So we can say that
      9:41:10
      the stage is an application stage
      9:41:14
      and inside of here we just want to
      9:41:15
      return some code. So we'll say we've got
      9:41:16
      a div which is going to be flex gap of
      9:41:18
      two items in the center. And then we're
      9:41:22
      going to render out a stage icon. So
      9:41:24
      each one of our stages is going to have
      9:41:25
      their own custom icon. We're going to
      9:41:27
      create we're just going to create a
      9:41:28
      component that allows us to easily
      9:41:30
      generate those icons. So we're going to
      9:41:31
      pass in the stage as well as some class
      9:41:34
      names for that. So we'll say here size
      9:41:36
      five text inherit. There we go. And then
      9:41:40
      we're going to render out a div with our
      9:41:42
      formatted name. Make sure I spell that
      9:41:44
      properly. So this will say format job
      9:41:47
      listing application stage and we'll pass
      9:41:50
      it in the stage. Very similar to how we
      9:41:52
      did with our job listing like location
      9:41:53
      and so on. This is just going to be a
      9:41:55
      formatter for that. Now let's create our
      9:41:56
      stage icon. First we'll go into our
      9:41:58
      components. We'll say stage
      9:42:01
      icon.tsx.
      9:42:03
      I'm going to paste in the code because
      9:42:04
      for the most part this isn't too
      9:42:05
      difficult to understand. Our stage icon
      9:42:07
      is going to take in our application
      9:42:09
      stage as well as all of the other props
      9:42:11
      for an icon. And then all we're doing is
      9:42:13
      we're just calling get icon and for each
      9:42:15
      one of these different stages we're
      9:42:16
      returning a different icon. So for
      9:42:18
      example, the help icon if they applied,
      9:42:19
      the interested icon is a check mark. You
      9:42:21
      can see an X for denied, the speech icon
      9:42:23
      for interviewed and a handshake for the
      9:42:24
      hired interview icon. So, as you can
      9:42:26
      see, it's just a different icon for a
      9:42:28
      different stage. So, we can import that
      9:42:30
      right here. And the next thing we can
      9:42:32
      work on is this format function, which
      9:42:33
      is going to be quite a bit simpler to
      9:42:34
      work on. So, we can go into our lib
      9:42:36
      folder here. We can create our
      9:42:37
      formatterers.ts.
      9:42:39
      And we can paste in our formatter
      9:42:41
      because again, it's relatively simple.
      9:42:42
      We just loop through each one of our
      9:42:43
      stages. And for each one, we return a
      9:42:45
      human readable string for what it should
      9:42:46
      look like. We can then import that
      9:42:48
      function over here. And now we at least
      9:42:50
      have a function of what our stage should
      9:42:52
      look like. And if we just return this no
      9:42:54
      matter what, you'll see exactly what
      9:42:55
      that looks like. You can see we have the
      9:42:56
      question mark since we're in the applied
      9:42:58
      stage. Now I can change what stage we're
      9:43:00
      in. For example, denied has the X mark.
      9:43:02
      You can see hired has the handshake.
      9:43:04
      Interested has the check mark. And then
      9:43:06
      finally, interviewed has that speaking
      9:43:07
      voice. So you can see we can change
      9:43:09
      around whatever it looks like. But in
      9:43:10
      our case, we're just going to have it be
      9:43:12
      the current stage it's supposed to be
      9:43:13
      on. Now, if the user is able to update
      9:43:14
      the stage, we essentially want to make a
      9:43:16
      drop down that's going to allow them to
      9:43:17
      select different options. So we'll come
      9:43:19
      in here with a drop-own menu. The
      9:43:21
      drop-own menu is going to have a
      9:43:22
      drop-down menu trigger.
      9:43:26
      We want this to be as child because we
      9:43:28
      just want to render out a button. This
      9:43:30
      button is going to be a ghost button.
      9:43:32
      So, we'll change the variant here to
      9:43:34
      ghost. We'll change some class names on
      9:43:36
      this. And generally when I work with
      9:43:38
      ghost buttons, I very often remove my
      9:43:40
      margin on the side. So, we can say
      9:43:42
      negative margin on the left to get rid
      9:43:43
      of that margin. And then we'll say if in
      9:43:45
      the pending state, we're just going to
      9:43:47
      give this some opacity so they know that
      9:43:48
      it's currently in the process of
      9:43:50
      working. So, we'll say like 50% opacity.
      9:43:52
      Then, finally, we can close off our
      9:43:54
      button. And inside here is where I want
      9:43:55
      to render out my stage details. So, I
      9:43:58
      can pass in my optimistic stage. And I
      9:44:00
      also want to make sure I render out a
      9:44:02
      chevron so they know that this is
      9:44:03
      interactable. So, we'll say chevron.
      9:44:06
      Whoops. Chevron down icon. There we go.
      9:44:11
      So, now you can see we have that showing
      9:44:13
      up. But it looks like I need this to say
      9:44:15
      variant. There we go. So now you can see
      9:44:17
      that when I hover over this, it looks
      9:44:18
      like a button, but I have no drop-own
      9:44:20
      menu content. So let's work on that.
      9:44:22
      Next, we can say drop-own menu content.
      9:44:25
      Want to loop through all my application
      9:44:27
      stages. There we go. I want to get them
      9:44:30
      sorted. So we'll application stages.
      9:44:32
      Sorted. I want to sort them. So we'll
      9:44:34
      sort our applications by stage. And then
      9:44:37
      we're going to map through each one of
      9:44:38
      these stage values.
      9:44:41
      For each value, I essentially want to
      9:44:43
      render out a drop-own menu item. So we
      9:44:44
      can say dropown menu item. This dropown
      9:44:48
      menu item is going to have a key which
      9:44:49
      is my stage value.
      9:44:52
      There we go. Make sure I close this off.
      9:44:57
      There we go. And then I want to have a
      9:44:58
      simple on click that is going to run our
      9:45:00
      function for us. So we can come in here
      9:45:02
      and this is going to call start
      9:45:04
      transition. And this start transition is
      9:45:06
      going to take an asynchronous function
      9:45:07
      that's going to do all of our
      9:45:08
      behind-the-scenes code for updating
      9:45:10
      this. So we'll call a function called
      9:45:11
      set optimistic stage. pass it in our new
      9:45:14
      stage value. That way we automatically
      9:45:15
      get our update right away for the
      9:45:16
      optimistic portion. Then we'll get a
      9:45:18
      response from calling await update job
      9:45:22
      listing application stage which is a
      9:45:24
      function we're going to create. It's
      9:45:25
      going to take in a job listing ID as
      9:45:28
      well as a user ID. So what is the
      9:45:30
      application we're updating and then what
      9:45:32
      is the new stage value we're updating
      9:45:34
      to. Then we can take this response and
      9:45:36
      if we have an error we can render that
      9:45:37
      out. So we can come down here and we can
      9:45:39
      say if we have a response error then we
      9:45:41
      want to render that out as a toast
      9:45:43
      message just like that. Finally in our
      9:45:45
      drop-own menu we want to render out the
      9:45:46
      stage detail and we want to render out
      9:45:48
      the stage detail for that specific stage
      9:45:50
      value. So now we should have a drop-own
      9:45:52
      menu with all of our different options
      9:45:54
      inside of it. Now clicking this will
      9:45:55
      fail our application because we don't
      9:45:56
      have this update job listing application
      9:45:59
      stage done. So let's work on
      9:46:00
      implementing that function. So we're
      9:46:02
      going to go into our action section
      9:46:03
      right here. This is where we're going to
      9:46:05
      define our action for this. and we'll
      9:46:06
      come down here. Export an async function
      9:46:10
      update job listing application stage.
      9:46:12
      And this is going to take in some
      9:46:13
      information. We know it's going to take
      9:46:14
      in a job listing ID and so on. So I'll
      9:46:16
      just copy over what we know it's going
      9:46:18
      to take in. If we come in here, it's
      9:46:21
      going to take in our job listing ID, our
      9:46:22
      user ID, as well as an unsafe stage,
      9:46:24
      which is going to be an application
      9:46:26
      stage because we don't know what this
      9:46:27
      is. It comes from the client. It could
      9:46:28
      be anything. So the first thing I want
      9:46:29
      to do is to make sure that this is
      9:46:30
      successful data. So I can get my success
      9:46:32
      and my data which we're going to call
      9:46:34
      stage and that's going to come from
      9:46:36
      Z.enum. We're going to create our own
      9:46:38
      here. It's an application stages. So
      9:46:40
      it's going to be an enum for any of our
      9:46:41
      stages. And we're just going to parse to
      9:46:42
      make sure our unsafe stage is one of
      9:46:44
      those stages. Essentially all this code
      9:46:46
      does is says, hey, is the thing I passed
      9:46:48
      in a valid stage. So if we don't have a
      9:46:51
      success, then we're going to return an
      9:46:52
      error.
      9:46:54
      And this will just say error
      9:46:57
      true message
      9:47:00
      invalid stage.
      9:47:03
      There we go. Then the next thing I want
      9:47:04
      to do is I want to check to make sure
      9:47:05
      that the user has permission to actually
      9:47:07
      perform this action. We kind of already
      9:47:09
      checked this before by showing the
      9:47:10
      dropdown, but we also always want to
      9:47:12
      check on the server as well. So we're
      9:47:13
      checking to make sure they have
      9:47:14
      permission to change this specific
      9:47:16
      thing. And then we can actually go about
      9:47:17
      and make the changes. So first let's see
      9:47:20
      if we have an organization ID. So we'll
      9:47:22
      say await get current organization.
      9:47:26
      There we go. Also, we want to get the
      9:47:28
      job listing associated with this. So
      9:47:31
      we'll wait get job listing.
      9:47:35
      This is going to take in a job listing
      9:47:37
      ID. And we're going to need to create a
      9:47:39
      function for this. So we'll say get job
      9:47:41
      listing. And this get job listing
      9:47:43
      function is essentially going to be the
      9:47:45
      same as this. But we're not going to
      9:47:46
      check to see if it is specifically a job
      9:47:48
      listing that is public. Then what we can
      9:47:50
      do is we can do a simple if check to
      9:47:51
      make sure that we have an org ID. So if
      9:47:53
      it's equal to null that's bad. Also we
      9:47:55
      can check to make sure we have a job
      9:47:56
      listing. If that's equal to null it's
      9:47:58
      bad. And then finally what we can do is
      9:47:59
      we can make sure our org ID is equal to
      9:48:03
      our job listing.org organization
      9:48:06
      ID. And we want to make sure that we
      9:48:08
      check that that's not equal because if
      9:48:09
      it's not equal we have a problem. And
      9:48:11
      also down here we should return the
      9:48:13
      organization ID from this. There we go.
      9:48:15
      So now we have that if check and if
      9:48:16
      there's a problem we'll just return an
      9:48:18
      error saying that they don't have
      9:48:19
      permission to update that stage. Finally
      9:48:21
      we can actually do our update. So we can
      9:48:23
      say update job listing application.
      9:48:26
      We want to pass in our job listing ID.
      9:48:30
      We want to pass in our user ID and we
      9:48:32
      want to pass in our data which is just
      9:48:34
      going to be our stage. And then we need
      9:48:36
      to create this specific function which
      9:48:38
      isn't going to be too hard. That'll just
      9:48:39
      be in our database folder right here.
      9:48:41
      And we essentially want to create update
      9:48:42
      joblisting application which we actually
      9:48:44
      already have. So, we can just import
      9:48:45
      this function. There we go. And now it
      9:48:48
      looks like it's working just fine. So,
      9:48:49
      now we should have have the ability to
      9:48:51
      update this job listing. And let's
      9:48:52
      actually test to see if that works.
      9:48:54
      We'll come over here. We'll update them
      9:48:55
      to interested. And we're getting an
      9:48:57
      error because I forgot to import the
      9:48:58
      code. So, let's make sure we import this
      9:49:00
      right there. There we go. So, now I'm
      9:49:02
      going to update them to interested. You
      9:49:03
      see, it immediately grayed out itself
      9:49:05
      for a second while it was in the pending
      9:49:06
      status and then it updated. Same thing
      9:49:08
      here. Go back to interested. And if I
      9:49:10
      refresh my page, they stay at that new
      9:49:11
      stage. So, at least I do know that this
      9:49:13
      property is working. So, now let's move
      9:49:15
      on to our next cell that we want to work
      9:49:17
      on. Like I said, that one was one of the
      9:49:18
      more complicated. And the nice thing
      9:49:19
      about this next one, which is rating, is
      9:49:21
      it's going to be nearly identical. So,
      9:49:23
      we're going to come in here with our
      9:49:24
      rating. The title for this is rating.
      9:49:26
      So, that's pretty much the same. We
      9:49:27
      don't need a sorting function cuz we're
      9:49:29
      just going to use the default sort. If
      9:49:30
      like numbers, a smaller number is
      9:49:32
      smaller than a bigger number. That's the
      9:49:33
      default behavior. That's working just
      9:49:34
      fine. This one, we want to sort to see
      9:49:36
      if the rating is included. So, our
      9:49:38
      filter function is based on rating. And
      9:49:40
      then finally here we want to render out
      9:49:41
      a rating cell. And the rating cell is
      9:49:44
      going to use the can update rating for
      9:49:46
      its rating purpose. We want to pass in a
      9:49:48
      rating which is our row original rating.
      9:49:50
      Otherwise everything else is the same.
      9:49:52
      And the nice thing about this rating
      9:49:53
      cell is it's so similar to our actual
      9:49:55
      stage cell. We're going to copy our
      9:49:57
      stage cell and just make some minor
      9:49:58
      modifications to what this looks like.
      9:50:00
      So we're going to come in here, call
      9:50:02
      this our rating cell. And obviously the
      9:50:03
      biggest difference is that here we're
      9:50:05
      going to have a rating and here we're
      9:50:07
      going to have a rating. And this
      9:50:08
      specific rating is going to be
      9:50:10
      essentially a type of rating just like
      9:50:12
      this. And actually, we might as well
      9:50:13
      just make it number or null because
      9:50:15
      that's the actual type that's coming
      9:50:16
      from our database. So there we go. We're
      9:50:17
      matching that type perfectly. And we
      9:50:19
      pass in our rating as our use
      9:50:21
      optimistic. Now here we're going to
      9:50:22
      render our rating icons which is a
      9:50:24
      component we've already created. So
      9:50:25
      we'll say rating icons. Pass in our
      9:50:28
      rating. And this is going to be
      9:50:30
      optimistic
      9:50:32
      rating and set optimistic rating. Just
      9:50:35
      like that. Make sure we update that in
      9:50:37
      all the places we use it. Same thing
      9:50:39
      here. Update that down there. Perfect.
      9:50:41
      So now we at least have that set up. If
      9:50:43
      they can't update, it just shows the
      9:50:44
      rating icon. Otherwise, we're going to
      9:50:46
      move on and actually show them the drop
      9:50:47
      down. So here, this is going to be our
      9:50:49
      rating icons where we pass in our
      9:50:51
      optimistic rating with that chevron.
      9:50:53
      Same thing as before. Next, we're going
      9:50:55
      to move through all of our rating
      9:50:56
      options and we're going to be sorting
      9:50:58
      them, but we don't need to actually cuz
      9:50:59
      they're already sorted. So we can remove
      9:51:00
      that sorting. And then here we have our
      9:51:02
      rating
      9:51:04
      value. So, we'll make sure our key is
      9:51:05
      our rating value. Set optimistic rating,
      9:51:08
      just like that. Same thing here, rating
      9:51:10
      value. We'll need to change this
      9:51:11
      function. So, I'll just put a giant
      9:51:12
      to-do there because we need to update
      9:51:14
      that. And then down here, this is our
      9:51:16
      rating icon for our rating value and
      9:51:18
      pass in our rating. Otherwise, it's very
      9:51:20
      similar to what we had before. Now,
      9:51:21
      there is one minor thing we need to do.
      9:51:23
      Our rating value could be null. So, we
      9:51:24
      want to make sure if our rating value is
      9:51:26
      null, we just pass a key of none. That
      9:51:28
      way, we have a key for that specific
      9:51:29
      value. Then what we want to do here is
      9:51:31
      we want to update our job listing
      9:51:34
      application rating. Just like that. Pass
      9:51:37
      it in all the information for our
      9:51:38
      rating. And we'll create that function
      9:51:39
      in just a little bit. But otherwise,
      9:51:41
      everything else inside of this function
      9:51:42
      is essentially done. We just want to
      9:51:44
      make sure here our class name is text
      9:51:46
      inherit for this cuz for some reason in
      9:51:48
      drop downs the SVGs change color. So now
      9:51:50
      let's go ahead and look at this. You can
      9:51:51
      see when we click down here, we can
      9:51:52
      toggle between these different options.
      9:51:54
      When I click on one of them, it'll fail
      9:51:55
      cuz we don't have this function defined
      9:51:56
      yet. But let's go ahead and define that
      9:51:58
      function. And it's actually going to be
      9:51:59
      rather simple. We can essentially copy
      9:52:00
      this function because it's going to be
      9:52:01
      very similar to what we did for the
      9:52:03
      rating version. So we'll change this to
      9:52:05
      rating and this will say unsafe rating.
      9:52:08
      Now we need to be be able to make sure
      9:52:09
      we parse what our rating is. So I'm
      9:52:11
      going to come in here to parse that
      9:52:12
      rating. We can get it's a number between
      9:52:14
      1 and five and it could also be a null
      9:52:16
      value. And we just want to do a safe
      9:52:17
      parse of our unsafe rating to be able to
      9:52:20
      get a rating for that. And we'll rename
      9:52:21
      this to rating. Then down here we can
      9:52:23
      say it's an invalid rating if there's a
      9:52:25
      problem. This is all about changing the
      9:52:28
      rating. you don't have permission to
      9:52:29
      update the rating. There we go. Now we
      9:52:32
      can move on down here. You don't have
      9:52:33
      permission to update the rating again.
      9:52:35
      And then finally, we can update the
      9:52:37
      rating portion down here. So, as you can
      9:52:38
      see, pretty much all of the code that we
      9:52:40
      wrote for this section is exactly the
      9:52:42
      same. We just had to change it from
      9:52:43
      stage to rating. And now with that done,
      9:52:45
      we can come into here, import this, and
      9:52:47
      we should see that all of our code is
      9:52:49
      working fine. So, here we have a
      9:52:51
      problem. This should be inside of
      9:52:52
      brackets, I believe, and it should be
      9:52:54
      rating. Rating value is No, no, no.
      9:52:57
      That's not right. It should definitely
      9:52:58
      be rating value like this. So we have an
      9:53:00
      error showing up here. It says type null
      9:53:02
      is not assignable to oh looks like our
      9:53:03
      typing for this. I forgot to update this
      9:53:06
      to number or null. Now if we give that a
      9:53:09
      save, you can see that removed our
      9:53:10
      errors here. We do have a erroneous
      9:53:12
      import we don't need. Let's get rid of
      9:53:14
      that. And now let's see if this works.
      9:53:15
      We're going to update our rating to
      9:53:16
      three stars. And you can see it looks
      9:53:17
      like it worked. When I refresh my page,
      9:53:19
      it still has the three star rating. So
      9:53:20
      that is now updating properly. Now we
      9:53:22
      can finally move on to another easy
      9:53:24
      column. So I'll just copy this column
      9:53:25
      over. So we have a starting place. This
      9:53:27
      is going to be our created at column.
      9:53:29
      The header for this should say applied
      9:53:32
      on. So when they wanted to apply for the
      9:53:34
      job. In our case, we're going to have an
      9:53:35
      accessor function for this as well. So
      9:53:38
      we're going to say row and row.created
      9:53:40
      at.
      9:53:42
      There we go. Just to be able to get the
      9:53:43
      correct property from all of this. We're
      9:53:45
      also not going to have to worry about
      9:53:46
      filtering on this because we're not
      9:53:47
      going to add any filtering for this. And
      9:53:49
      for our cell, this one is going to be
      9:53:50
      super straightforward. We almost don't
      9:53:52
      need to do anything complicated at all.
      9:53:53
      We're just going to come in here
      9:53:54
      row.create.
      9:53:56
      created at whoops created at dot to
      9:53:59
      local date string. There we go. It's as
      9:54:02
      simple as that. And now you can see
      9:54:03
      right here we have the applied on
      9:54:04
      property for when they actually applied
      9:54:05
      for the job. Lastly, we're going to add
      9:54:07
      an actions column. And this isn't really
      9:54:09
      tied to any of our actual columns. So,
      9:54:10
      we're going to give this an ID instead
      9:54:12
      to just give it a unique identifier to
      9:54:14
      denote that it's not attached to any of
      9:54:15
      our other columns. And this one is going
      9:54:17
      to have a cell just like this with a
      9:54:20
      row. It's not going to have any sorting
      9:54:21
      or anything, so at least that's going to
      9:54:22
      be simpler. We're going to get our job
      9:54:24
      listing which is equal to row.or
      9:54:26
      original. We're going to get our resume
      9:54:29
      which is equal to joblisting do
      9:54:31
      user.res.
      9:54:32
      And then we want to return an action
      9:54:34
      cell which is what we're going to create
      9:54:35
      in a little bit.
      9:54:37
      This action cell is going to take in our
      9:54:39
      cover letter markdown specifically which
      9:54:41
      is our job listing.colet markdown. We're
      9:54:44
      also going to get our resume markdown
      9:54:47
      which is our resume. Markdown. And we
      9:54:50
      want to get this as markdown summary.
      9:54:52
      Yep. There we go. That's fine. Then
      9:54:54
      we're going to get our résé URL that is
      9:54:57
      equal to résé.resume fo file URL. And
      9:55:01
      then our username. This comes from our
      9:55:03
      job listing do user.name. There we go.
      9:55:06
      Now we just want to create this action
      9:55:07
      cell. So we'll scroll all the way down
      9:55:09
      below these.
      9:55:11
      And we'll create an action cell. Now we
      9:55:13
      already know the types for the things
      9:55:14
      we're importing. We have essentially a
      9:55:16
      string null or undefined for our resume.
      9:55:17
      Username is a string. And then these
      9:55:19
      markdowns could also both be null. Now
      9:55:20
      this action dropdown is essentially
      9:55:22
      going to have two buttons and each one's
      9:55:23
      going to open a modal that shows the
      9:55:24
      markdown component. So I'm going to
      9:55:26
      create some state to handle that. We're
      9:55:27
      going to say open
      9:55:30
      modal and set open modal. And this is
      9:55:33
      going to be a use state variable. And
      9:55:34
      this use state variable is either going
      9:55:36
      to be the resume modal which is open.
      9:55:38
      It's going to be the cover letter modal
      9:55:40
      that's open or null if no modal at all
      9:55:43
      is open. And by default we're going to
      9:55:44
      set it to null. So by default no modal
      9:55:46
      is going to be open. Then what we want
      9:55:48
      to do is we want to return all of this
      9:55:50
      content. So we're going to return a
      9:55:51
      drop-own menu followed by our modals. So
      9:55:53
      let's start with our drop-own menu and
      9:55:55
      we want to get our drop-own menu
      9:55:56
      trigger. That's going to be a child
      9:55:58
      trigger again because it's going to use
      9:55:59
      that same exact button that we kind of
      9:56:01
      used before. So let's get a button. This
      9:56:03
      is going to be a variant of ghost.
      9:56:07
      We want the size of this to be icon
      9:56:08
      because it's going to be a small little
      9:56:10
      button.
      9:56:11
      The span inside of here is going to be
      9:56:13
      purely for our screen readers. So we'll
      9:56:15
      say screen reader only. It's going to
      9:56:17
      say open
      9:56:19
      menu. And then we're going to come in
      9:56:21
      here with the more horizontal icon. Just
      9:56:24
      like that. Class name is going to be
      9:56:26
      size 4. There we go. So now if we just
      9:56:29
      expand this a little bit, you can see
      9:56:31
      over here we have this nice little icon
      9:56:32
      that shows up for opening up that
      9:56:33
      drop-own menu. Let's add in the content
      9:56:35
      for the drop-own menu. Drop-own menu.
      9:56:38
      Content. We want to align this on the
      9:56:40
      end. There we go. Makes sense since it's
      9:56:42
      a right-sided thing. And then we want to
      9:56:44
      check do we have a résé URL
      9:56:47
      or if that's null or a réé markdown if
      9:56:50
      that is not equal to null then we want
      9:56:52
      to render out a button for viewing the
      9:56:54
      ré content. So we can come in here and
      9:56:56
      render out that button. Otherwise we
      9:56:58
      want to render out essentially a button
      9:56:59
      that says there's no rés. So first of
      9:57:01
      all we'll do the no résé version. That's
      9:57:02
      going to be a drop-own menu label. So
      9:57:05
      we'll say label just like that. Close
      9:57:07
      that off. And this should say not equal
      9:57:09
      to null. There we go. That fixed that
      9:57:10
      potential problem.
      9:57:13
      There we go. And inside this drop-own
      9:57:14
      menu label, we want to actually close
      9:57:16
      that off. And inside of here, actually,
      9:57:18
      let's make sure. There we go. We close
      9:57:20
      that off. And up here, let's return null
      9:57:22
      just to get our typing properly back.
      9:57:23
      There we go. So, now our label, we can
      9:57:25
      add in a class name text muted
      9:57:27
      foreground. And then finally, we can
      9:57:29
      just say no resume. So, if the user
      9:57:31
      doesn't have a resume, it's going to
      9:57:33
      show up as no resume. This shouldn't be
      9:57:34
      the case, but if they like delete their
      9:57:36
      resume after they upload and apply for
      9:57:37
      the job, this could show up as no
      9:57:39
      resume. Now, if they do have a resume,
      9:57:41
      which is the much more likely option,
      9:57:43
      we're going to have a drop-own menu item
      9:57:46
      that is going to render out. This
      9:57:47
      drop-own menu item is going to say view
      9:57:50
      resumeé. And when we click on this, it's
      9:57:52
      going to open the proper modal. So, on
      9:57:53
      click,
      9:57:55
      it's going to open the modal for our
      9:57:59
      resume. There we go. So, now we at least
      9:58:02
      have that showing up. If we open this
      9:58:03
      section up, we click here, you can see
      9:58:05
      we have a m view ré button, which
      9:58:06
      changes the state of this variable up
      9:58:08
      here to be true. Now, we're going to
      9:58:10
      essentially do the exact same thing with
      9:58:11
      our cover letter. So, I'm going to paste
      9:58:12
      this down. If we have cover letter
      9:58:13
      markdown, view cover letter and open the
      9:58:15
      cover letter. Otherwise, just say no
      9:58:16
      cover letter. So, we come over here. We
      9:58:18
      can click on this. And you can see this
      9:58:20
      person doesn't have a cover letter. So,
      9:58:21
      it just says no cover letter and we
      9:58:22
      can't click on the button. Now, with
      9:58:23
      that done, we can actually render out
      9:58:25
      the dialogue component. So, if our cover
      9:58:26
      letter markdown exists, then we're going
      9:58:28
      to render out the dialogue for it. So,
      9:58:30
      we'll say dialogue. The open case for
      9:58:32
      this dialogue is going to be open modal
      9:58:35
      is equal to cover letter. There we go.
      9:58:37
      Then what I want to do is on open change
      9:58:41
      I want to say that we're going to
      9:58:43
      essentially close our modal. So we're
      9:58:44
      going to say set open modal. If open is
      9:58:47
      what we're doing. So if we're changing
      9:58:49
      from closed to open we're essentially
      9:58:50
      opening this then I want to set this to
      9:58:52
      cover letter. Otherwise I want to set
      9:58:54
      this to null. So essentially I want to
      9:58:55
      translate this from a boolean into our
      9:58:57
      own format that we're using for our
      9:58:59
      dialogue. There we go. And it looks like
      9:59:01
      I need to import this component. There
      9:59:02
      we go. Now, what I want to do is I want
      9:59:04
      to put our dialogue content
      9:59:06
      inside of here. For the dialogue
      9:59:08
      content, we can come in with a large max
      9:59:11
      width of 5XL, medium, max width of 3XL.
      9:59:18
      We want our max height to be essentially
      9:59:21
      a calculation of 100% minus 2mm. So, we
      9:59:25
      want it to essentially fill the full
      9:59:27
      screen overflow of hidden flex and flex
      9:59:31
      column just so it'll scroll if we need
      9:59:32
      it to. Next, we can come in with our
      9:59:34
      header and our description. So, we can
      9:59:36
      come in here, our dialogue header and
      9:59:38
      our dialogue title and our dialogue
      9:59:41
      description. And all this is going to
      9:59:42
      say is cover letter and username so we
      9:59:44
      know who actually uploaded this. Then,
      9:59:46
      we want to just render out our markdown
      9:59:48
      as the next thing. So, you can see we're
      9:59:49
      rendering that and making sure it
      9:59:50
      scrolls properly. And I believe I may
      9:59:52
      have imported one of my dialog
      9:59:53
      components from the wrong section. Looks
      9:59:55
      like I did not. So that's properly good.
      9:59:57
      There we go. So then I want to copy this
      9:59:58
      down because we're going to do
      9:59:59
      essentially the exact same thing for
      10:00:01
      their resume as well. So if the user has
      10:00:03
      a ré markdown or they have a ré URL,
      10:00:06
      then we want to render the content
      10:00:07
      inside of here. This is going to say ré
      10:00:10
      and ré just like that. We want our modal
      10:00:12
      to essentially be exactly the same for
      10:00:14
      the size.
      10:00:16
      This is going to say ré. And then we
      10:00:18
      want to essentially render out a button
      10:00:19
      to view their resume. So, we're going to
      10:00:20
      say if they have a resume URL, then what
      10:00:23
      we want to do is we want to render out a
      10:00:25
      button specifically for showing that
      10:00:27
      content. So, we'll do an as child button
      10:00:30
      class name right here, self start. That
      10:00:33
      way, it doesn't fill the full screen
      10:00:34
      size.
      10:00:36
      And in here, we're going to have a link
      10:00:39
      href is going to be our ré URL.
      10:00:42
      There we go. Our link is going to say
      10:00:44
      original résé. And then we want to have
      10:00:47
      a target. Whoops.
      10:00:49
      target that is going to be the blank
      10:00:52
      target and our re
      10:00:55
      is going to be no opener,
      10:00:57
      no refer. There we go. Then finally,
      10:01:00
      we're going to have some more dialogue
      10:01:01
      description which has a little bit of
      10:01:02
      margin on it that essentially just says,
      10:01:04
      "Hey, this is AI generated summary of
      10:01:05
      the application." And then we're going
      10:01:07
      to render out the resume markdown down
      10:01:09
      here so they can see the AI generated
      10:01:10
      version or the actual version they
      10:01:12
      uploaded. Now, what we need to do to
      10:01:13
      make sure that this works is we need to
      10:01:14
      make sure in our page here, we're
      10:01:16
      actually passing down the correct
      10:01:17
      information because our applications
      10:01:18
      need to be slightly modified. We need to
      10:01:20
      pass down markdown instead of passing
      10:01:22
      down a string. So, we're going to take
      10:01:24
      this map over our application and
      10:01:26
      essentially we're just going to do a
      10:01:27
      very small conversion. So, we're going
      10:01:29
      to take our object, keep it the same,
      10:01:30
      but we want to modify our user. So,
      10:01:32
      we're going to take our user and we want
      10:01:34
      to specifically dive into the résé
      10:01:35
      section. So, if the user has a resume,
      10:01:38
      then we want to modify that resume.
      10:01:40
      Otherwise, we just return null because
      10:01:42
      they don't have a resume. Now, if they
      10:01:43
      do have a resume, we're going to come in
      10:01:45
      here and keep everything exactly the
      10:01:46
      same. So, we're going to keep all the
      10:01:48
      properties we had before, but we're
      10:01:49
      going to add our own markdown summary,
      10:01:51
      which is just our user.res.ai
      10:01:54
      summary. And if they have an AI summary,
      10:01:56
      we want to render that out as content.
      10:01:58
      Otherwise, we want to return null. And
      10:02:00
      this content we're going to be rendering
      10:02:01
      is markdown render. So, get the markdown
      10:02:04
      render. Pass in our source as our user
      10:02:07
      resume AI summary. Just like that. And
      10:02:10
      there we go. So essentially what this
      10:02:12
      little bit of code is doing is it's
      10:02:13
      taking our resume and converting it to
      10:02:15
      markdown before we send it down. Then
      10:02:17
      the next thing that we need to do is
      10:02:18
      also do the same thing with our cover
      10:02:20
      letter. So we're going to come in here
      10:02:21
      with our cover letter markdown. If we
      10:02:23
      have a cover letter, then we want to
      10:02:25
      convert that to markdown. I'll just copy
      10:02:26
      the code that does that. There we go.
      10:02:28
      And instead of here, we're just going to
      10:02:30
      be passing our cover letter. And then
      10:02:32
      what we want to do is if we don't have
      10:02:33
      that information, we just return null.
      10:02:35
      Just like that. So, all this code did is
      10:02:37
      essentially convert our resume to a
      10:02:39
      rendered version of markdown. And same
      10:02:41
      thing with our cover letter. Now, we
      10:02:42
      should hopefully be able to see that
      10:02:44
      information. So, if we click on this and
      10:02:45
      we click on view ré, we can see all the
      10:02:47
      information for the user's resume. Now,
      10:02:49
      for some reason, my styling is a little
      10:02:50
      bit off. So, I need to make sure I fixed
      10:02:52
      that. So, let's go ahead and find the
      10:02:53
      style. This max H should have a dash
      10:02:55
      right here. I believe that's the only
      10:02:57
      thing wrong with my style. So, let's go
      10:02:58
      ahead and see if that fixes it. View RS.
      10:03:00
      And as you can see, now we can actually
      10:03:01
      see the full RS. If we click original
      10:03:03
      resume, it brings up the file of the
      10:03:05
      original resume. Also, we can come in
      10:03:06
      here and we can view their cover letter.
      10:03:08
      And you can see here's the cover letter
      10:03:09
      information they submitted. Now, to be
      10:03:10
      able to showcase the rest of the
      10:03:11
      features on our table a little better, I
      10:03:13
      want to just create a brand new
      10:03:14
      application for this job. So, I'm going
      10:03:16
      to log out of this user in particular,
      10:03:17
      we'll just log into another user and
      10:03:18
      make a bogus application. So, we'll do a
      10:03:20
      quick signin here with a user. We'll do
      10:03:23
      test.com.
      10:03:24
      And we'll enter in that password that we
      10:03:26
      created for them. And now we can go
      10:03:28
      ahead. We can apply for this exact same
      10:03:30
      role. We'll actually probably need to
      10:03:31
      upload our resume. So, let's make sure
      10:03:32
      we do that because I believe yeah, we'll
      10:03:34
      upload our resume. So, that'll redirect
      10:03:35
      us to this page. We'll make sure that we
      10:03:37
      pull over this file, drag it into here,
      10:03:39
      just like that, and we'll click the
      10:03:40
      upload button. That should upload that
      10:03:42
      resume exactly where we want it to be,
      10:03:44
      which is great. Now, we can go back to
      10:03:45
      our job board, and we can actually apply
      10:03:46
      for this job. And if for some reason, it
      10:03:49
      says we don't have a resume, which is
      10:03:50
      definitely not correct. The only thing
      10:03:52
      that I can think of that would be
      10:03:53
      causing that particular problem is
      10:03:55
      inside of our route. Let's go to our
      10:03:57
      source. We're going to go to our
      10:03:59
      services upload thing inside of our
      10:04:01
      router. We want to make sure that when
      10:04:03
      we upsert our user resume, we are
      10:04:05
      revalidating our user resume cache which
      10:04:08
      we are calling that function. So that
      10:04:10
      does seem correct. This is getting the
      10:04:11
      user resume and the user resume tag.
      10:04:13
      User résumés believe that is what I used
      10:04:16
      is user rums. Okay. Now what I want to
      10:04:19
      do is make sure that all looks good.
      10:04:21
      Now, where we're fetching our user
      10:04:22
      resume, we'll just call get user
      10:04:26
      resume.
      10:04:28
      Here is where we're calling that
      10:04:29
      function. Now, that's not the one we
      10:04:32
      care about, is it? Let's see. Maximize
      10:04:35
      this out. That's just our action
      10:04:36
      section. Get user resume is getting that
      10:04:39
      tag from our cache. That is properly
      10:04:41
      good. That also looks like it's fine.
      10:04:44
      And here, yeah, that also looks like
      10:04:46
      it's fine. So, I'm not sure why it's not
      10:04:48
      getting it. Maybe it just wasn't quite
      10:04:50
      updated yet. Let's try it again. Okay,
      10:04:52
      it looks like maybe there was just some
      10:04:54
      caching. So, it looks like it's fine. We
      10:04:55
      can apply for our job. There's nothing
      10:04:57
      actually wrong with our code. Now, if we
      10:04:59
      just log out and log back in as the
      10:05:00
      person that has access to the employer
      10:05:02
      dashboard, we should be able to go over
      10:05:03
      to that section and actually mess around
      10:05:05
      with multiple different applications to
      10:05:07
      the same job. So, as you can see here
      10:05:09
      now, there are two applications for the
      10:05:10
      job and this user was a five out of five
      10:05:12
      star rating by the AI in the background,
      10:05:14
      which is nice. So, let's test our
      10:05:15
      filtering to make sure that works. We're
      10:05:16
      going to change this to interested. And
      10:05:18
      now hopefully if we change the order of
      10:05:19
      this, you can see that does actually
      10:05:21
      change the order which is great. We can
      10:05:22
      change the order of this. Then that
      10:05:24
      looks like it's also working perfectly.
      10:05:26
      And we can even change the order of
      10:05:27
      this. And again, that is properly moving
      10:05:29
      our users around. Now, one thing we want
      10:05:30
      to do is we want to pageionate this
      10:05:32
      table cuz showing hundreds and hundreds
      10:05:33
      of applications on the same page.
      10:05:35
      Definitely not ideal. Luckily, we have
      10:05:36
      this pageionation component built into
      10:05:38
      Shadan. We can just copy that into our
      10:05:40
      application and modify it as we want.
      10:05:42
      So, let's go ahead and find our
      10:05:43
      components for the data table. We'll
      10:05:45
      call this data table pageionation.tsx.
      10:05:50
      Make sure we import that. We're probably
      10:05:52
      going to have to fix the imports up
      10:05:53
      here. We are definitely going to have to
      10:05:55
      fix those. We'll just manually import
      10:05:56
      those ourselves. Actually, I believe we
      10:05:58
      can just change this to be dot dot. And
      10:06:00
      that'll work.
      10:06:02
      There we go. That is actually importing
      10:06:04
      from the correct location. And we'll
      10:06:05
      just import our button from the same
      10:06:07
      exact correct location. And there we go.
      10:06:08
      That did work. So now we should at least
      10:06:10
      see we have pageionation if we add this
      10:06:12
      to our table. So, we're going to come
      10:06:13
      over to our data table. And we're just
      10:06:15
      going to add that to the very end of our
      10:06:16
      table. Essentially, that's going to be
      10:06:17
      the very last thing inside of here. So,
      10:06:19
      we can just render out our data table
      10:06:22
      like that. And we'll just wrap this
      10:06:24
      entire thing in a div because we are
      10:06:26
      going to add some extra content here.
      10:06:28
      So, we'll just put a div around this for
      10:06:29
      now. I know that we're going to have
      10:06:31
      extra content. So, that why is why I'm
      10:06:32
      not using a fragment. And we'll pass in
      10:06:35
      our table to this. And that should be
      10:06:37
      everything we need to do. If we just
      10:06:38
      import that component, we should see it.
      10:06:40
      And then we'll make the changes we want.
      10:06:41
      So, as you can see, we have that showing
      10:06:43
      up on the bottom. We have this thing
      10:06:44
      about selected rows, which we don't care
      10:06:46
      about. So, we're going to kind of remove
      10:06:47
      that content. So, let's come into here.
      10:06:49
      We'll go through this whole section
      10:06:50
      right here for dealing with the actual
      10:06:51
      selected rows. We don't need any of
      10:06:53
      that. And also, we're going to set this
      10:06:54
      to justify end to push our content as
      10:06:56
      far right as possible. Also, it looks
      10:06:58
      like this is just pushed up a little bit
      10:06:59
      too much. So, we'll just like add a
      10:07:01
      little bit of margin on the top just to
      10:07:02
      push it down a little bit. And now you
      10:07:03
      can see we have our pageionation
      10:07:04
      perfectly set up. And obviously, if we
      10:07:06
      like changed it to be like one item per
      10:07:08
      page or something like that. For
      10:07:09
      example, we can come in here, put a one.
      10:07:11
      That allows us to put one item per page.
      10:07:13
      And now you can see that we have
      10:07:14
      multiple pages, but it looks like we're
      10:07:15
      not filtering things yet because in our
      10:07:17
      table, we need to make sure we support
      10:07:18
      pageionation as well. So, back in our
      10:07:20
      table at the very, very top here, we
      10:07:23
      have the option to get pagenation row
      10:07:26
      model. And we'll use the default
      10:07:27
      pageionation row model. That should
      10:07:29
      hopefully fix that problem. And now you
      10:07:31
      can see it's properly pagenating between
      10:07:32
      our different rows. Obviously, it
      10:07:34
      doesn't make sense to be able to have
      10:07:35
      pagionation by one single item. So we
      10:07:38
      will remove the ability for that and
      10:07:39
      just take it back to 10 as the minimum.
      10:07:41
      Now the next thing we're going to be
      10:07:42
      implementing is some filtering on our
      10:07:44
      table because we want to be able to
      10:07:45
      filter based on users and we need to add
      10:07:46
      in some different details for that. So
      10:07:48
      we're going to say we want to get the
      10:07:49
      filtered row model which is get filtered
      10:07:53
      row model. That's the default. We also
      10:07:54
      want to get the faceted unique row
      10:07:56
      model. So we can say faceted unique
      10:07:58
      values. Get faceted unique values just
      10:08:01
      like that. And then we need to create
      10:08:02
      our own state for the filter. So we'll
      10:08:04
      say column filters.
      10:08:09
      There we go.
      10:08:11
      set column filters.
      10:08:14
      And this column filters is going to use
      10:08:16
      the column filters state.
      10:08:21
      There we go. And by default, we're just
      10:08:23
      going to pass in either an empty array
      10:08:25
      or our initial filters because we want
      10:08:27
      to have some initial filters that we
      10:08:29
      could pass in. So we'll say initial
      10:08:30
      filters just like that. Then down here
      10:08:32
      we can pass in our column filters. There
      10:08:35
      we go. And we want to make sure up here
      10:08:38
      we have initial filters that we can pass
      10:08:39
      in. So all the way up here we can say
      10:08:42
      initial filters.
      10:08:46
      That's going to be an optional property
      10:08:48
      which is a column filter state. Also,
      10:08:50
      while we're here, we might as well add
      10:08:51
      in the no results message, which is
      10:08:54
      going to be a React node. This is what
      10:08:56
      we render when we have no results. So if
      10:08:57
      we scroll all the way down here, you'll
      10:08:59
      see this section that says no results.
      10:09:01
      We're going to render out our own custom
      10:09:02
      message in that case if we want to. So
      10:09:04
      we can make sure we accept that as a
      10:09:06
      parameter. And then also by default we
      10:09:08
      want to specify it as the text no
      10:09:11
      results. There we go. So that way it at
      10:09:13
      least has some default behavior. Finally
      10:09:16
      we're going to add in a toolbar
      10:09:17
      component.
      10:09:19
      This toolbar component is going to be a
      10:09:21
      component type just like this. And this
      10:09:23
      component type is going to take in a
      10:09:24
      table as a prop and it's going to be
      10:09:27
      based on that t data component. There we
      10:09:29
      go.
      10:09:31
      And this is a property that we can use.
      10:09:33
      So let me make sure I get all these
      10:09:34
      imported. And table type, we want to
      10:09:37
      make sure we import that. And this table
      10:09:38
      type, we'll have to manually import
      10:09:39
      because it comes from here. And it's
      10:09:41
      going to be table. And we're going to
      10:09:43
      rename that as table type. And it's just
      10:09:44
      going to be a type. There we go. So to
      10:09:46
      use this toolbar component, we'll come
      10:09:48
      down here directly above. And if we have
      10:09:50
      a toolbar component,
      10:09:53
      component. There we go. Make sure I
      10:09:55
      actually have that as a prop up here. If
      10:09:57
      we have a toolbar component, then I want
      10:09:59
      to render that toolbar component and
      10:10:01
      pass along our table to it. There we go.
      10:10:04
      And then to make sure everything is
      10:10:05
      spaced out properly, we'll just come in
      10:10:06
      here with some class names. Flex flex
      10:10:09
      column gap of four. And by adding that
      10:10:11
      gap of four, we actually can remove the
      10:10:12
      margin on the top of this. There we go.
      10:10:15
      So now if we give that a save and we
      10:10:16
      give our other table here a save, you
      10:10:18
      can see that spaced everything out
      10:10:20
      properly. And now we have this data tab
      10:10:21
      or this toolbar that we can add in if we
      10:10:23
      want as well as this no results message.
      10:10:25
      Also we need to use this set column
      10:10:27
      filters. So we can do that really easily
      10:10:29
      where we have our filtering going on. We
      10:10:30
      can just say on column filter changes
      10:10:33
      and that is set column filters. So this
      10:10:35
      will allow us to change our filters in
      10:10:36
      our columns. And of course this isn't a
      10:10:37
      function. We just want to pass it along
      10:10:39
      like that. So now let's go ahead and
      10:10:40
      actually deal with our data table for
      10:10:42
      all these additional properties that we
      10:10:43
      just created. So let's minimize this
      10:10:45
      down inside of our features folder for
      10:10:48
      the job listing. That's where our
      10:10:49
      application table is at. So inside of
      10:10:51
      our application table, we can kind of
      10:10:53
      minimize all these action cells down. Uh
      10:10:55
      we can minimize that down because we're
      10:10:56
      really focused on this particular
      10:10:57
      section right here. And we want to first
      10:10:59
      of all have a no results message. And
      10:11:01
      this no results message is going to be
      10:11:03
      passed in actually. So this will say no
      10:11:05
      results message. So we can pass this in
      10:11:08
      no results message. It's going to be an
      10:11:11
      optional string just like that. Actually
      10:11:13
      it'll be a React node. And by default
      10:11:15
      we're just going to have this say no
      10:11:18
      applications.
      10:11:19
      There we go. So if this is completely
      10:11:20
      blank, there's no applications. It'll
      10:11:22
      say no applications. Also, we're going
      10:11:24
      to be implementing our skeleton table
      10:11:26
      now because we pretty much have
      10:11:27
      everything we don't need done for that.
      10:11:29
      So, we're just going to render out an
      10:11:30
      application table. The applications is
      10:11:32
      going to be an empty array because we
      10:11:33
      have no data yet. We can have a can
      10:11:35
      update rating is going to be false. Our
      10:11:38
      can update this is going to be false as
      10:11:40
      well. Our ability to have no results.
      10:11:43
      This is going to be our loading state.
      10:11:44
      So, since our array is empty, we always
      10:11:46
      will render out this no results message.
      10:11:48
      So, this will just be loading spinner.
      10:11:50
      Class name on this is going to be size
      10:11:52
      12. There we go. So, we're going to
      10:11:54
      render out a nice little loading
      10:11:55
      spinner. And then we're going to also
      10:11:56
      disable our toolbar because we don't
      10:11:58
      want to be able to interact with
      10:11:59
      sorting, which makes sense. So, we'll
      10:12:00
      say disabled toolbar, which is a prop
      10:12:02
      that we're going to add. There we go.
      10:12:04
      Disable toolbar. We'll add that directly
      10:12:06
      into here. By default, that will be
      10:12:08
      false. And it'll be an optional boolean
      10:12:10
      parameter. Now, the next thing we can
      10:12:12
      work on is adding in our toolbar. So,
      10:12:14
      we'll say toolbar component is equal to
      10:12:16
      disabled toolbar. If it's disabled, we
      10:12:18
      will render the disabled toolbar.
      10:12:22
      Otherwise, we'll render out our normal
      10:12:23
      toolbar. So, now let's go ahead and
      10:12:24
      actually render out our toolbar related
      10:12:26
      content. It's going to be a generic
      10:12:28
      component because that's what Shadsen
      10:12:29
      and this data table component are
      10:12:31
      expecting. And it's going to take in a
      10:12:32
      table and as well as this disabled
      10:12:35
      property. Then what we're going to do is
      10:12:36
      we're going to have our components.
      10:12:38
      We're going to have table which is going
      10:12:39
      to be a table of type T. And this comes
      10:12:42
      from that tan stack table library. So
      10:12:45
      make sure we get that imported from the
      10:12:46
      correct location. And we also have this
      10:12:49
      disabled property which is an optional
      10:12:51
      boolean to disable all of our loading
      10:12:53
      states or all of our filtering. Now I
      10:12:55
      want to render out how many rows are
      10:12:57
      hidden based on our filtering. We can
      10:12:58
      actually pretty easily do that by saying
      10:13:00
      hidden rows is equal to table.get core
      10:13:02
      row model dot rows.length. This is going
      10:13:06
      to give us the total number of rows in
      10:13:08
      our table. Then we can subtract that by
      10:13:10
      the table.get row count which is going
      10:13:12
      to give us the number of rows that are
      10:13:13
      actually able to be shown in our table.
      10:13:15
      So this will essentially take us all the
      10:13:17
      rows in our table minus the ones we have
      10:13:19
      showing will give us the number of rows
      10:13:20
      that we have left. Then what we can do
      10:13:22
      is we can return all the information
      10:13:23
      that we want. So we're going to have a
      10:13:25
      div right here with a class name flex
      10:13:27
      items in the center gap of two and this
      10:13:29
      is where all of our different filters
      10:13:31
      are going to go. So we're going to have
      10:13:32
      one filter here, another filter here,
      10:13:34
      and then finally below that we're going
      10:13:35
      to render out our hidden rows. So if our
      10:13:37
      hidden rows is greater than zero, then
      10:13:39
      we want to just have some text that
      10:13:40
      says, hey, you have some hidden rows. So
      10:13:43
      we'll say div class name text small text
      10:13:46
      muted foreground margin on the left of
      10:13:48
      two and this will say
      10:13:52
      whoops
      10:13:55
      hidden rows which is our number of
      10:13:56
      hidden rows. Make sure I spell that
      10:13:58
      properly.
      10:14:01
      Close off our div. And we also want to
      10:14:03
      put some additional text. And we'll say
      10:14:04
      if our hidden rows is greater than one
      10:14:06
      then it'll say rows. Otherwise it'll say
      10:14:09
      row. Close that off.
      10:14:12
      Give that a quick save and make sure I
      10:14:14
      put my question mark syntax in there.
      10:14:16
      And there we go. We now have our text
      10:14:17
      that'll tell us how many hidden rows we
      10:14:18
      have. Now we can go ahead and render out
      10:14:20
      our toolbar for our different stages and
      10:14:22
      ratings which are what we want to filter
      10:14:23
      on. So first I'm going to make sure that
      10:14:25
      we have a column for that. So I'm going
      10:14:27
      to make sure we have a column for stage.
      10:14:29
      If we do then I want to run the code
      10:14:30
      inside of here. This is just a fail safe
      10:14:32
      to make sure we have data for that
      10:14:33
      column. Then I'm going to render a
      10:14:35
      component that I'm going to create
      10:14:36
      called table faceted filter. Faceted
      10:14:40
      filter. There we go. And this is going
      10:14:42
      to be a component we're going to create
      10:14:43
      with the help of Shad CN because they
      10:14:45
      kind of have some faceted filters for
      10:14:47
      us. If we kind of expand this a little
      10:14:48
      bit and we actually make it full screen
      10:14:51
      and we look over here, we have the
      10:14:53
      ability to actually do specific things
      10:14:54
      with the row action. So, let me make
      10:14:57
      sure I find it. Self formatting
      10:14:58
      filtering. Here we go. And you can see
      10:15:00
      inside this section, if we scroll down a
      10:15:02
      little ways, actually I don't see it in
      10:15:03
      here. It's somewhere in here. I know
      10:15:04
      that they have these faceted table
      10:15:06
      columns. I maybe actually had to go
      10:15:08
      through a block example. Either way,
      10:15:09
      it's somewhere in the Shadan code. We'll
      10:15:11
      be going through it, but don't worry.
      10:15:12
      But this is kind of something that I
      10:15:13
      took from the Shadan code and then very
      10:15:15
      heavily modified to work with my use
      10:15:17
      case. So, we're going to render one of
      10:15:18
      these for each of our different columns.
      10:15:20
      So, I'm going to come down here. This is
      10:15:21
      going to be the rating version. And
      10:15:22
      we're going to render one of these as
      10:15:24
      well. So, let's go ahead and we're going
      10:15:25
      to create that exact component. So, in
      10:15:27
      our components data table, this is going
      10:15:28
      to be data table faceted
      10:15:32
      filter.tsx.
      10:15:35
      There we go. And the very first thing I
      10:15:37
      want to get started with is just the
      10:15:38
      interface that's coming directly from
      10:15:39
      this. So I'm going to be just getting
      10:15:41
      this directly from the code that I got
      10:15:42
      from shad CN. So we're going to be
      10:15:44
      passing in our column data. That is
      10:15:46
      essentially our column here. So we can
      10:15:47
      say column.
      10:15:49
      Make sure I import this properly.
      10:15:51
      Actually I need to export something.
      10:15:53
      Export data
      10:15:55
      function
      10:15:58
      data table faceted filter. And the props
      10:16:01
      are going to be equal to those props
      10:16:03
      right there. and return null. That way
      10:16:06
      we can just import it over here so we
      10:16:07
      can see what this looks like. There we
      10:16:09
      go. So our column is going to be
      10:16:10
      table.get
      10:16:12
      column
      10:16:15
      and it's going to be getting that stage
      10:16:16
      column. That's what that column property
      10:16:18
      is working at right here. Then we have a
      10:16:20
      title which is a string. We have our
      10:16:21
      disabled state if we want to disable it.
      10:16:23
      And then we have an option and I pretty
      10:16:24
      heavily modified what these look like.
      10:16:26
      But our option takes in a key. It takes
      10:16:28
      in some type of generic value. Doesn't
      10:16:30
      matter what it is. It could be a string,
      10:16:31
      a number, a boolean, whatever. and then
      10:16:32
      a label which is some type of React
      10:16:34
      node. Now, this table must or this
      10:16:36
      faceted filter must be a generic prop
      10:16:38
      and we can pass in those generics
      10:16:39
      directly to here. So, at least we have
      10:16:40
      all of our generic values for us. And
      10:16:42
      then inside here, what I want to do is I
      10:16:44
      want to get our facets like this. That's
      10:16:46
      going to be column.get
      10:16:48
      faceted unique values just like that.
      10:16:51
      And this should come from our props. So,
      10:16:53
      we can say column just like that. Now
      10:16:55
      these faceted unique values essentially
      10:16:57
      just return to us all the possible
      10:16:59
      permutations of what the values could be
      10:17:01
      inside of our table. That's essentially
      10:17:02
      the whole idea behind this. So it's a
      10:17:04
      really great way for filtering on like
      10:17:05
      enum values. Then we want to get the
      10:17:07
      selected values. So I can say const
      10:17:09
      selected values is equal to a new set.
      10:17:12
      And this comes from our column again.
      10:17:15
      And we want to get the filter value
      10:17:18
      just like this. And we want to convert
      10:17:19
      this to the O value type. And it's going
      10:17:22
      to be an array of values in our
      10:17:23
      particular case because we know that
      10:17:25
      these are going to match up with this O
      10:17:26
      value type. Then inside of here, we're
      10:17:28
      going to be using a popover. So we can
      10:17:30
      say popover just like this. Inside this
      10:17:32
      popover, we need a popover trigger
      10:17:34
      trigger. So popover trigger
      10:17:38
      as a child is what we're going to do for
      10:17:39
      that one. And then we're going to render
      10:17:40
      a button inside of here. Make sure I get
      10:17:43
      the correct button imported. We're going
      10:17:44
      to have this button be disabled
      10:17:47
      if we're in the disabled state. There we
      10:17:49
      go.
      10:17:52
      does not look like it wants to pull in
      10:17:53
      that property because I forgot to put it
      10:17:55
      in up here. So, we can say disabled. We
      10:17:58
      can have our options and our title.
      10:18:01
      Those are our different props that we
      10:18:02
      have up here. There we go. So, now we
      10:18:03
      have our disabled state. Our variant for
      10:18:06
      this one is going to be outline and we
      10:18:08
      want it to be rather small. So, we're
      10:18:09
      going to give it a size of small. Then,
      10:18:11
      we're going to check our selected
      10:18:12
      values. We're going to see if the size
      10:18:14
      is greater than zero. And if the size is
      10:18:16
      greater than zero, we're going to render
      10:18:18
      out essentially what that size is. and
      10:18:19
      we're going to put that inside of a
      10:18:21
      badge component. And we're going to make
      10:18:22
      sure that the variant on this is
      10:18:24
      secondary and the size is small. And
      10:18:27
      that'll just say our selected values do
      10:18:29
      size. So this will just tell us how many
      10:18:30
      things we currently have selected in our
      10:18:32
      list. Then finally, we're going to put
      10:18:34
      the title as well as a chevron with the
      10:18:36
      down icon.
      10:18:39
      There we go. Just so we can essentially
      10:18:41
      denote that this is a selectable item on
      10:18:43
      our page. Now, you can see we have those
      10:18:44
      two chevrons pointing down. Now, what I
      10:18:46
      want to do is I want to fill out the
      10:18:47
      rest of our types for this. So, we're
      10:18:49
      going to pass in our title. This is
      10:18:50
      going to be for stage. We're going to
      10:18:52
      pass in our disabled state, which comes
      10:18:54
      just directly from our prop for
      10:18:55
      disabled. There we go. And then we can
      10:18:57
      also finally get our options. And the
      10:18:59
      options here is going to be our
      10:19:00
      application stages. We want to sort
      10:19:02
      those. So, we're going to say two sorted
      10:19:04
      using that sort application stages
      10:19:06
      function. And then we're going to do a
      10:19:08
      quick map on these for each stage. And
      10:19:10
      we essentially want to render out the
      10:19:12
      exact code of label which is going to be
      10:19:14
      our stage details with our stage.
      10:19:18
      Just like that. We also want to render
      10:19:20
      out our value which is stage and our key
      10:19:23
      which is going to be our stage. There we
      10:19:24
      go. So that entire section is done.
      10:19:26
      Right now we don't have anything showing
      10:19:27
      but at least we have the drop- down
      10:19:29
      portion looking like it's there. Next up
      10:19:31
      I'm going to copy this. I'm going to
      10:19:32
      paste this down into here. This is going
      10:19:34
      to be our rating. This is going to have
      10:19:36
      a title of rating. This is going to be
      10:19:38
      our rating options. We want to map
      10:19:41
      through those, but we don't need to sort
      10:19:42
      them. So, we're going to map through
      10:19:43
      each rating. Each rating is going to be
      10:19:45
      rendered out as rating icons. And we'll
      10:19:47
      just come in here with our rating icons.
      10:19:50
      Our value here, and our value is going
      10:19:52
      to be I. And then our key right here is
      10:19:54
      going to be our rating. And to get the
      10:19:55
      index, we just need to make sure we come
      10:19:56
      in here like that. And actually, we need
      10:19:58
      to swap this. Our value should be the
      10:20:00
      rating. And our key should be the index.
      10:20:02
      Just like that. That should work
      10:20:03
      properly now. So now inside of our
      10:20:04
      filter, we can actually render out that
      10:20:06
      content inside of a popover content. So
      10:20:08
      we can say popover content just like
      10:20:10
      that. Class name on this is going to be
      10:20:12
      a width of 200 pixels because we don't
      10:20:13
      want it to be too large. We're going to
      10:20:15
      get rid of all the padding and we're
      10:20:17
      going to make sure our alignment on this
      10:20:18
      is going to be at the start. Then we're
      10:20:21
      going to use a command. And this is
      10:20:22
      something that we need to make sure we
      10:20:23
      get from shad CN. So let's just come in
      10:20:25
      here. Shad CN add the command component
      10:20:28
      which is kind of like a drop-own
      10:20:29
      component of sorts that we can work
      10:20:30
      with. We want to force install that. And
      10:20:32
      now we can use that command inside of
      10:20:34
      here. Let's just give it a second. There
      10:20:36
      we go. And we want to make sure we
      10:20:37
      install that from the shad CN portion.
      10:20:39
      We then want to create a command list.
      10:20:43
      There we go. And inside this command
      10:20:44
      list, we want to render what happens
      10:20:46
      when it's empty. So we're going to say
      10:20:47
      command empty is going to be no results
      10:20:50
      found. This shouldn't happen unless
      10:20:53
      they're searching for something in
      10:20:54
      particular. Then we're going to have a
      10:20:56
      command group just like this.
      10:20:59
      And inside this command group is where
      10:21:01
      we actually loop through all the
      10:21:02
      different option values we have. So for
      10:21:04
      each option I want to render out what
      10:21:05
      that option is. So first here we're
      10:21:07
      going to figure out is this a selected
      10:21:09
      option by just saying selected values
      10:21:11
      has option value. Then we can return our
      10:21:15
      command item.
      10:21:17
      It should have a key which we specified
      10:21:19
      on our option. So we can get our options
      10:21:21
      key. Then we can come in here and we can
      10:21:23
      say on select we want to do something in
      10:21:25
      specific. So we'll come in here on
      10:21:27
      select.
      10:21:30
      What I want to do is if it is already
      10:21:32
      selected then I want to delete it from
      10:21:34
      my selected values. So I can say
      10:21:37
      selected values.delete
      10:21:39
      option value. Otherwise I want to add it
      10:21:42
      to my list. So I can say selected values
      10:21:44
      add option value. There we go. Then I
      10:21:48
      can say my filter values is going to be
      10:21:50
      getting the selected values. So I can
      10:21:51
      say selected values just like that. And
      10:21:54
      I could say I want to set my filter
      10:21:55
      values on my column. So I can say column
      10:21:58
      set filter values equal to my filter
      10:22:01
      values. Whoops. Filter values.length
      10:22:05
      greater than zero then we use our filter
      10:22:08
      values. Otherwise we return undefined.
      10:22:10
      So this entire section code essentially
      10:22:12
      is just saving this inside of our
      10:22:14
      selected values. And then what we're
      10:22:15
      doing is we're saying hey if our
      10:22:16
      selected values has no values in it then
      10:22:19
      return undefined otherwise return
      10:22:20
      whatever those selected values are. Then
      10:22:22
      inside this command item, we can
      10:22:23
      actually render out our content. So
      10:22:25
      we'll come in here with a class name for
      10:22:26
      this particular section using CN. And we
      10:22:29
      want to have some default styles. Flex,
      10:22:31
      we'll do a size of four. We'll center
      10:22:33
      these items.
      10:22:36
      There we go. Justify them in the center
      10:22:38
      as well. Rounded is going to be four
      10:22:40
      pixels.
      10:22:43
      And then finally, we're going to add a
      10:22:44
      border on this. Then we can come in here
      10:22:46
      where if it's selected, we want to add
      10:22:48
      some specific styles. For example, we
      10:22:49
      want a primary background. border is
      10:22:52
      going to be primary, text is going to be
      10:22:54
      primary, foreground, and if it's not
      10:22:56
      selected, we want to add some other
      10:22:58
      styles instead. So, for example, border
      10:23:00
      is going to be input.
      10:23:02
      And then all we need to do is make sure
      10:23:03
      we close this off. Just like that. And
      10:23:05
      inside this div, we can use the check
      10:23:07
      icon. And this is going to have some
      10:23:09
      more class names. Text primary
      10:23:11
      foreground.
      10:23:14
      There we go. And we also want to give it
      10:23:16
      a size of 3.5.
      10:23:19
      Close that off. And that's everything
      10:23:21
      inside that portion of our div. Now
      10:23:22
      instead of a span, we can put our option
      10:23:24
      label. So essentially we have a checkbox
      10:23:26
      next to our actual label and then we can
      10:23:28
      render out what our each individual
      10:23:30
      facets are. So what this is doing is
      10:23:32
      saying okay we know that we have a value
      10:23:33
      of like applied interested and so on.
      10:23:36
      And this facet allows us to get how many
      10:23:38
      different items in our table match that
      10:23:39
      particular value. So we can say
      10:23:41
      facets.get
      10:23:44
      option value. This is going to determine
      10:23:46
      if we have something for that particular
      10:23:48
      value. If we do, then I want to render
      10:23:50
      that out. So, we're going to just put a
      10:23:51
      span that's going to put that exact
      10:23:53
      content inside of it. We don't even need
      10:23:55
      the question mark on there. There we go.
      10:23:58
      So, we're going to render that out. And
      10:23:59
      I'm going to add a bunch of class names.
      10:24:00
      For example, text muted foreground.
      10:24:03
      Margin on the left is auto to push it
      10:24:04
      all the way to the right. Flex size for
      10:24:07
      items in the center.
      10:24:10
      Justify the content in the center. Font
      10:24:12
      is going to be a mono font. And we want
      10:24:14
      it to be extra small text. Now that
      10:24:16
      takes care of all of our command related
      10:24:18
      stuff. All we need is an option to be
      10:24:19
      able to clear out our filter. So we can
      10:24:21
      come in here, selected values size. If
      10:24:24
      it is greater than zero, then I want to
      10:24:25
      add just an option to clear out our
      10:24:27
      filter. So we'll come down here. We'll
      10:24:29
      say that we're going to have a command
      10:24:31
      separator to separate these two
      10:24:32
      different items from each other. Then
      10:24:34
      we're going to have another command
      10:24:36
      group. And inside this command group,
      10:24:38
      we're going to have one final command
      10:24:39
      item.
      10:24:42
      There we go. on select. What this is
      10:24:44
      going to do if I make sure I spell that
      10:24:46
      properly
      10:24:48
      is it's going to take our column. It's
      10:24:50
      going to get the filter.
      10:24:56
      There we go. Actually, it's going to set
      10:24:58
      the filter set the filter value to
      10:24:59
      undefined just to clear out everything
      10:25:01
      that is currently inside of there. And
      10:25:03
      then what we want to do is just add some
      10:25:04
      class names to style this. So we'll say
      10:25:06
      that we want to justify in the center
      10:25:09
      and the text is going to go in the
      10:25:10
      center. close off that command item and
      10:25:12
      it'll just say clear. So that's a lot of
      10:25:15
      content to essentially just create these
      10:25:16
      dropdowns. But now if we look at our
      10:25:18
      code, you can see when I open this up,
      10:25:19
      you can see I get this nice little check
      10:25:20
      mark dropdown that I can select all the
      10:25:22
      values that I want. I also get this
      10:25:24
      little box that tells me exactly how
      10:25:25
      many I have selected. Now I do notice
      10:25:27
      there's a problem with our badges. I
      10:25:28
      don't think it's taking into account our
      10:25:29
      size. So I'm going to look at our badge.
      10:25:31
      I'm going to make sure we're taking into
      10:25:32
      account our size for the badge as well.
      10:25:34
      And it looks like I don't think we are.
      10:25:37
      I want to make sure we have our size
      10:25:38
      being taken into account here.
      10:25:41
      Just like that. And then we want to use
      10:25:43
      that size down here.
      10:25:46
      There we go. And now you can see that
      10:25:47
      our badge has shrunk in size just like
      10:25:49
      we want. And you can see right here that
      10:25:50
      this item that says that there's one of
      10:25:52
      each of these for applied and
      10:25:53
      interested. If I were to change one of
      10:25:55
      these users to a different type, for
      10:25:56
      example, I change this guy to
      10:25:57
      interested. Now you can see that there
      10:25:58
      are two people that are in the
      10:25:59
      interested category and zero over here.
      10:26:01
      So now that we have that done, we can
      10:26:02
      actually filter these things. is we just
      10:26:04
      kind of need to finish hooking
      10:26:05
      everything together inside of our
      10:26:06
      application table and so on. For
      10:26:07
      example, we need to create our disabled
      10:26:09
      toolbar, which is going to be quite
      10:26:10
      simple to create. We'll say disabled
      10:26:12
      toolbar. This disabled toolbar is going
      10:26:15
      to take in almost the exact same props
      10:26:16
      as our toolbar. It's just not going to
      10:26:18
      have a disabled prop. And what it's
      10:26:20
      going to do is it's just going to return
      10:26:22
      our normal toolbar,
      10:26:25
      but it's going to pass in our table, and
      10:26:28
      it's going to say that this is a
      10:26:29
      disabled version. Just like that. So now
      10:26:31
      if we give that a save, we have our
      10:26:32
      disabled toolbar rendering properly. Now
      10:26:34
      to see what that looks like, we can
      10:26:35
      actually go back into our page where we
      10:26:37
      are rendering this application. So we
      10:26:39
      can go into our employer job listings.
      10:26:41
      We can go specifically for our job
      10:26:42
      listing ID and you can see where we're
      10:26:45
      rendering out our application. Let's try
      10:26:47
      to find that skeleton table. We're just
      10:26:49
      going to take our skeleton table and put
      10:26:50
      it right here. Comment out this and this
      10:26:52
      will show us our skeleton table. It
      10:26:53
      looks just like this, which is exactly
      10:26:55
      what we want. These are disabled and
      10:26:56
      that is great. So now let's go ahead and
      10:26:58
      add in some default states for
      10:27:00
      everything. So what we can do is go back
      10:27:02
      into our application table and what I
      10:27:03
      want to do is I want to implement my
      10:27:05
      initial filters. Now in our case we
      10:27:08
      essentially want to filter on stage
      10:27:09
      where we get rid of the denied people.
      10:27:11
      So what we want to do is we want to take
      10:27:12
      in our ID is stage that just matches
      10:27:15
      what we called our column. Our value
      10:27:17
      here is going to be our application
      10:27:18
      stages. We want to filter out anyone
      10:27:20
      that's denied. So we're going to take
      10:27:21
      the stage not equal to denied. So
      10:27:23
      essentially we only select the options
      10:27:25
      that are not denied. Now, if we give
      10:27:27
      this a refresh, we should see by default
      10:27:29
      we have four different stages selected.
      10:27:31
      And one of those right here is denied.
      10:27:33
      That's the only one that's not selected.
      10:27:34
      And you also see we have the clear
      10:27:36
      option down here if we want to clear out
      10:27:37
      this entire filter. Now, if I were to
      10:27:39
      select applied, for example, you can see
      10:27:40
      that there are two rows that are
      10:27:42
      currently hidden. Now, I should probably
      10:27:43
      add some text onto the bottom of that
      10:27:44
      that says that these are hidden rows.
      10:27:46
      So, I'll say two rows hidden. So, that
      10:27:47
      way they know that there are two rows
      10:27:49
      currently being hidden from them. So,
      10:27:50
      now they can easily see what's showing,
      10:27:52
      what's not showing. If we want to clear
      10:27:53
      the filter, we can clear that back out.
      10:27:54
      And now we have our rows showing up.
      10:27:55
      Now, to make sure we're done with our
      10:27:56
      application, we're just going to go a
      10:27:58
      quick search for to-do. So, we'll say
      10:28:00
      to-do, just like this. And you can see
      10:28:01
      here that we have our AI generation. We
      10:28:03
      did do that already. So, we can remove
      10:28:05
      that to-do. And same thing here, the
      10:28:06
      skeleton application table, we finished
      10:28:08
      that. So, we can remove that to-do. And
      10:28:09
      that should be everything in our
      10:28:10
      application completely done. Now, one
      10:28:12
      minor problem that I noticed when going
      10:28:13
      through our code is that inside of our
      10:28:15
      middleware, we actually failed to put
      10:28:17
      one route in there, and that is our AI
      10:28:19
      search route. We want to make sure that
      10:28:20
      our AI search route is publicly
      10:28:22
      available because that incentivizes
      10:28:24
      people to actually create accounts with
      10:28:25
      us. Also, another thing that we don't
      10:28:26
      need that I was looking through the code
      10:28:28
      noticed is inside of our layout section,
      10:28:29
      we have this dark class we added for
      10:28:31
      testing purposes. We can remove that.
      10:28:32
      Another minor problem I noticed with
      10:28:34
      some of our CSS styling is I forgot to
      10:28:36
      put the dash in a couple of my max
      10:28:38
      height calculations.
      10:28:40
      Looks like this is another one that I
      10:28:42
      forgot it at. So, just make sure that
      10:28:43
      inside of those two files that we have
      10:28:45
      that that's going to be the action cell
      10:28:47
      as well as inside of our apply button
      10:28:49
      component. Another minor mistake I
      10:28:51
      noticed is I typed in this is an AI
      10:28:52
      generated summary of our resume. It
      10:28:55
      should say your resume. Not a huge deal
      10:28:56
      though. Another very minor mistake is in
      10:28:58
      my job listing page for the employer
      10:29:00
      portion. I typed max auto instead of MX
      10:29:03
      auto. So, another small styling mistake.
      10:29:05
      Another minor issue in this data faceted
      10:29:07
      filter. I accidentally put my command
      10:29:09
      separator as like a parent component,
      10:29:11
      which is definitely not what I should
      10:29:12
      have done. So that should hopefully fix
      10:29:14
      some of the issues with that scroll bar
      10:29:15
      that we had. So now you can see that
      10:29:16
      this looks much better when we have
      10:29:17
      this. No weird scrolling issues like
      10:29:19
      before. Now, if you enjoyed this video
      10:29:21
      and want to see other massive
      10:29:23
      projectbased videos, I'm going to link
      10:29:24
      some right over here. And also, if you
      10:29:26
      want me to continue to be able to make
      10:29:28
      videos like this, I highly recommend
      10:29:29
      checking out the sponsors. They're going
      10:29:30
      to be linked in the description. Their
      10:29:32
      support single-handedly is what allows
      10:29:34
      me to spend a month making a single
      10:29:36
      large project for a YouTube video for
      10:29:38
      you to watch entirely for free. So
      10:29:39
      again, I highly recommend you check out
      10:29:41
      Injust and Clerk. They'll be linked down
      10:29:42
      in the description below. With that
      10:29:44
      said, thank you very much for watching
      10:29:45
      and have a good
    </chapter>
  </chapters>
</transcript>
