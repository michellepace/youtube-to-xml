# PR Strategy: YouTube Transcript to XML Integration

## Executive Summary

This integration merges the experimental URL-based transcript fetcher into the main application architecture. The strategy follows TDD principles, delivers incremental value with each PR, and maintains 100% backward compatibility while enabling new functionality.

## Target Architecture

```text
models.py (shared data structures)
├── TranscriptDocument (unified container)
├── VideoMetadata (title, published, duration, url)
├── TranscriptLine (timestamp, text)
└── Chapter (title, times, transcript_lines)

Parsers (produce TranscriptDocument objects)
├── file_parser.py (refactor to use TranscriptLine objects)
└── url_parser.py (new, extracted from scripts/url_to_transcript.py)

Presentation
├── xml_builder.py (accepts TranscriptDocument)
└── cli.py (handles both file and URL workflows)
```

### Shared Models

1. **`models.py`**: Unified data structures
   ```python
   @dataclass(frozen=True)
   class VideoMetadata:
       video_title: str = ""
       video_published: str = ""  # YYYYMMDD raw format or empty
       video_duration: int = 0    # seconds (0 for file method)
       video_url: str = ""
       # Note: chapters_data field is NOT needed - chapter detection logic
       # stays internal to URL parser implementation

   @dataclass(frozen=True)
   class TranscriptLine:
       timestamp: float  # seconds
       text: str

   @dataclass(frozen=True)
   class Chapter:
       title: str
       start_time: float
       end_time: float
       transcript_lines: list[TranscriptLine]

   @dataclass(frozen=True)
   class TranscriptDocument:
       metadata: VideoMetadata
       chapters: list[Chapter]
   ```

2. **`time_utils.py`**: All temporal utilities (already complete)
   - `timestamp_to_seconds()` - converts "M:SS" to float seconds
   - `seconds_to_timestamp()` - converts float seconds to "M:SS"
   - `format_video_published()` - converts YYYYMMDD to YYYY-MM-DD
   - `format_video_duration()` - converts seconds to "2h 15m 3s"

3. **`xml_builder.py`**: Enhanced with metadata support
   - Accepts `TranscriptDocument` objects
   - Calls `format_video_duration()` to convert seconds → "2h 43m 47s" for XML
   - Calls `format_video_published()` for date formatting if needed
   - Maintains 100% backward compatibility

### Key Terminology

- **TranscriptLine**: A timestamp-text pair representing words spoken at a specific time (e.g., "0:02" → "Hello world")
- **Chapter**: A titled section containing multiple transcript lines
- **TranscriptDocument**: Complete container with video metadata + all chapters

## Critical Integration Challenges

### 1. Data Model Incompatibility
- **Issue**: File parser uses `transcript_lines: list[str]` (raw strings with embedded timestamps)
- **URL script uses**: `transcript_lines: list[TranscriptLine]` (structured objects)
- **Impact**: Prevents code reuse between parsers and xml_builder

### 2. Duplicate XML Generation
- **Issue**: URL script contains its own XML creation logic
- **Impact**: Violates DRY principle, maintenance burden, potential inconsistencies

### 3. Missing Shared Models
- **Issue**: Both implementations define their own incompatible `Chapter` class
- **Impact**: Cannot share xml_builder or other components

### 4. No VideoMetadata in File Workflow
- **Issue**: File parser has no concept of metadata (hardcoded empty strings in XML)
- **Impact**: Limits extensibility and consistency

## Required XML Output Format

The integration must preserve this exact XML structure for backward compatibility:

```xml
<?xml version='1.0' encoding='utf-8'?>
<transcript video_title="" video_published="" video_duration="" video_url="">
  <chapters>
    <chapter title="Introduction to Cows" start_time="0:02">
      0:02
      Welcome to this talk about erm.. er
      2:30
      Let's start with the fundamentals
    </chapter>
  </chapters>
</transcript>
```

**Note**: File method produces empty metadata attributes. URL method populates them with actual values.

## Recommended PRs in Logical Order

### PR 1: `feat/shared-models-foundation`

**PR Contents:**
- Create `src/youtube_to_xml/models.py` with shared data structures:
  - `VideoMetadata` dataclass with defaults for file workflow
  - `TranscriptLine` dataclass for structured timestamp/text pairs
  - `Chapter` dataclass using `list[TranscriptLine]` (structured objects)
  - `TranscriptDocument` container holding metadata and chapters
- Add comprehensive tests for new models in `tests/test_models.py`

**Value:** Establishes foundational data structures for entire application. No dead code - models immediately used by tests.

**Risk:** [Small] - Pure addition of new module with tests, no changes to existing functionality

**Dependencies:** None - can be merged immediately

---

### PR 2: `refactor/url-script-to-use-models`

**PR Contents:**
- Update `scripts/url_to_transcript.py` to:
  - Import shared models from `youtube_to_xml.models`
  - Remove duplicate `VideoMetadata`, `TranscriptLine`, `Chapter` definitions
  - Change VideoMetadata.video_duration from formatted string to raw int seconds
  - Keep chapters_data as internal implementation detail (not in shared model)
  - Refactor to return `TranscriptDocument` objects
  - **Keep existing XML generation code temporarily** (`create_xml_document`, `format_xml_output`)
- Update script tests to verify functionality preserved

**Value:** URL script now uses shared models. Sets foundation for eliminating duplicate code.

**Risk:** [Small] - URL script already uses TranscriptLine objects, minimal structural changes needed

**Dependencies:** PR 1 (shared models)

**Note:** Cannot use xml_builder yet because it still expects file_parser.Chapter objects with `transcript_lines: list[str]`, not the TranscriptLine objects that URL script uses. This will be resolved in PR 3.

---

### PR 3: `refactor/enhance-xml-builder-with-dual-support`

**PR Contents:**
- Update `xml_builder.py` to:
  - Add new function: `transcript_to_xml(document: TranscriptDocument) -> str`
  - Keep existing function: `chapters_to_xml(chapters: list[Chapter]) -> str` for backward compatibility
  - New function extracts metadata and chapters from TranscriptDocument
  - Call `time_utils` formatting functions for metadata
  - Handle empty metadata gracefully (file workflow compatibility)
  - Import both `models.TranscriptDocument` and keep `file_parser.Chapter` import temporarily
- Add tests for new TranscriptDocument handling
- Add tests for metadata formatting edge cases
- Ensure existing tests for `chapters_to_xml()` still pass

**Value:** XML builder now supports both old and new interfaces, enabling gradual migration.

**Risk:** [Small] - Additive change with backward compatibility maintained

**Dependencies:** PR 1 (models), PR 2 (URL script using models)

**Note:** Dual support is needed to avoid breaking file workflow while enabling URL script migration. This temporary technical debt allows incremental migration without a risky "big bang" change. The old `chapters_to_xml()` function will be removed after PR 5 completes the migration.

---

### PR 4: `refactor/url-script-use-xml-builder`

**PR Contents:**
- Update `scripts/url_to_transcript.py` to:
  - Import `xml_builder` module
  - Replace local XML generation (`create_xml_document`, `format_xml_output`) with call to `xml_builder.transcript_to_xml()`
  - Remove the now-unused XML generation functions
- Update script tests to verify identical XML output

**Value:** Eliminates ~100 lines of duplicate XML generation code from URL script.

**Risk:** [Small] - Simple function replacement with well-tested alternative

**Dependencies:** PR 3 (xml_builder with dual support)

**Note:** This must come AFTER PR 3 because it depends on xml_builder having the new `transcript_to_xml()` function that accepts TranscriptDocument objects.

---

### PR 5: `refactor/file-parser-to-structured-lines`

**PR Contents:**
- Update `file_parser.py` to:
  - Import `Chapter` and `TranscriptLine` from models
  - Convert string-based transcript lines to `TranscriptLine` objects during parsing
  - Parse timestamps into float seconds for TranscriptLine
  - Return `TranscriptDocument` with empty metadata and structured chapters
- Update `cli.py` to use new file parser signature
- Update all file parser tests to work with TranscriptDocument
- Ensure end-to-end tests pass with no XML output changes

**Value:** File parser now produces TranscriptDocument with structured TranscriptLine objects. Enables unified processing.

**Risk:** [High] - Core parser refactor from strings to objects. This is the most complex PR as it changes the fundamental data structure throughout the file processing pipeline.

**Dependencies:** PRs 1-4 (needs models, dual-support xml_builder, and URL script already migrated)

---

### PR 6: `feat/create-url-parser-module`

**PR Contents:**
- Create `src/youtube_to_xml/url_parser.py`:
  - Extract transcript fetching logic from `scripts/url_to_transcript.py`
  - Implement `fetch_transcript_document(url) -> TranscriptDocument`
  - Use shared models (already refactored in PR 2)
  - Handle all YouTube/yt-dlp exceptions with proper error mapping
- Add comprehensive tests in `tests/test_url_parser.py`
- Integration tests for various YouTube URL formats

**Value:** Creates reusable URL parser module, ready for CLI integration.

**Risk:** [Small] - Logic extraction from already-refactored script

**Dependencies:** PRs 1-5 (needs complete model infrastructure)

---

### PR 7: `feat/unified-cli-with-auto-detection`

**PR Contents:**
- Update `cli.py` to:
  - Auto-detect input type (file path vs URL)
  - Import and use `url_parser.fetch_transcript_document()` for URLs
  - Import and use enhanced `file_parser` for files
  - Both paths return `TranscriptDocument` → `xml_builder`
- Update CLI help text to show both input methods
- Add end-to-end tests for URL input via main CLI
- Update documentation with unified usage examples

**Value:** Single entry point handles both files and URLs transparently. Full integration achieved.

**Risk:** [Small] - CLI orchestration change with clear separation of concerns

**Dependencies:** PRs 1-6 (needs complete infrastructure)

---

### PR 8: `chore/cleanup-deprecated-script`

**PR Contents:**
- Delete `scripts/url_to_transcript.py` (functionality now in url_parser module)
- Update `url_to_transcript_wrapper.py` to import from new location
- Remove script entry from `pyproject.toml` if no longer needed
- Update any documentation references
- Verify all tests still pass

**Value:** Removes 400+ lines of duplicate code, single source of truth for URL processing.

**Risk:** [Small] - Deletion of deprecated code after successful integration

**Dependencies:** PR 7 (unified CLI must be working)

## Success Metrics

1. **All existing tests pass** after each PR
2. **No breaking changes** to file-based workflow
3. **Zero code duplication** between parsers
4. **Single XML generation path** for both input methods
5. **100% test coverage** for new code
6. **Identical XML output** for equivalent inputs

---

## PR Implementation Summary

**Foundation & Refactoring**
- PR 1: Shared models foundation (TranscriptDocument, VideoMetadata, Chapter, TranscriptLine)
- PR 2: URL script uses shared models *(keeps own XML temporarily)*
- PR 3: XML builder dual support *(old + new interfaces)*
- PR 4: URL script switches to xml_builder *(removes duplicate XML code)*
- PR 5: File parser migration to structured lines *(High Risk: string→object conversion)*

**Integration & Cleanup**
- PR 6: URL parser module extraction
- PR 7: Unified CLI with auto-detection
- PR 8: Cleanup deprecated script

## Risk Mitigation

- Each PR includes comprehensive tests before implementation (TDD)
- PRs are ordered to minimize dependencies and conflicts
- Backward compatibility verified at each step
- Small, focused PRs enable quick reviews and rollbacks if needed
- Integration tests ensure end-to-end functionality preserved