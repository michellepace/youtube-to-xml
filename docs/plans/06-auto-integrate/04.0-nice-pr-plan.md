# MASTER PR Strategy Plan: YouTube Transcript to XML Integration

## Executive Summary: Goal

This integration merges the experimental URL-based transcript fetcher into the main application architecture. The strategy follows TDD principles, delivers incremental value with each PR, and maintains 100% backward compatibility through a dual-path approach that enables safe verification before legacy removal.

## Target Architecture

```text
models.py (shared data structures)
├── TranscriptDocument (unified container)
├── VideoMetadata (title, published, duration, url)
├── TranscriptLine (timestamp, text)
└── Chapter (title, times, transcript_lines)

Parsers (produce TranscriptDocument objects)
├── file_parser.py (refactor to use TranscriptLine objects)
└── url_parser.py (new, moved from scripts/url_to_transcript.py)

Presentation
├── xml_builder.py (accepts TranscriptDocument)
└── cli.py (handles both file and URL workflows)
```

### Data Flow Architecture

**Key insight:** The CLI orchestrates the complete flow - it doesn't just call one component, but chains them together: Parser → TranscriptDocument → XML Builder → File

```text
        ┌─────────┐
        │   CLI   │ (orchestrator)
        └────┬────┘
             │ reads input
             ▼
        ┌─────────┐
        │ Parser  │ (file_parser.py or url_parser.py)
        └────┬────┘
             │ produces
             ▼
    ┌───────────────────┐
    │TranscriptDocument │ (shared model from models.py)
    └────────┬──────────┘
             │ consumed by
             ▼
        ┌─────────────┐
        │ XML Builder │ (xml_builder.py)
        └─────┬───────┘
              │ generates
              ▼
        ┌──────────┐
        │ XML File │ (output)
        └──────────┘
```

*Note: See key insight above diagram.*

### Shared Models

1. **`models.py`**: Unified data structures
   ```python
   @dataclass(frozen=True)
   class VideoMetadata:
       video_title: str = ""
       video_published: str = ""  # YYYYMMDD raw format or empty
       video_duration: int = 0    # seconds as integer (0 for file method)
       video_url: str = ""
       # Note: chapters_data field is NOT needed - chapter detection logic
       # stays internal to URL parser implementation

   @dataclass(frozen=True)
   class TranscriptLine:
       timestamp: float  # seconds
       text: str

   @dataclass(frozen=True)
   class Chapter:
       title: str
       start_time: float
       end_time: float
       transcript_lines: list[TranscriptLine]

   @dataclass(frozen=True)
   class TranscriptDocument:
       metadata: VideoMetadata
       chapters: list[Chapter]
   ```

2. **`time_utils.py`**: All temporal utilities (already complete)
   - `timestamp_to_seconds()` - converts "M:SS" to float seconds
   - `seconds_to_timestamp()` - converts float seconds to "M:SS"
   - `format_video_published()` - converts YYYYMMDD to YYYY-MM-DD
   - `format_video_duration()` - converts seconds to "2h 15m 3s"

3. **`xml_builder.py`**: Enhanced with metadata support
   - Accepts `TranscriptDocument` objects
   - Calls `format_video_duration()` to convert seconds → "2h 43m 47s" for XML
   - Calls `format_video_published()` for date formatting if needed
   - Maintains 100% backward compatibility

### Key Terminology

- **TranscriptLine**: A timestamp-text pair representing words spoken at a specific time (e.g., "0:02" → "Hello world")
- **Chapter**: A titled section containing multiple transcript lines
- **TranscriptDocument**: Complete container with video metadata + all chapters

## Critical Integration Challenges

### 1. Data Model Incompatibility
- **Issue**: File parser uses `transcript_lines: list[str]` (raw strings with embedded timestamps)
- **URL script uses**: `transcript_lines: list[TranscriptLine]` (structured objects)
- **Impact**: Prevents code reuse between parsers and xml_builder

### 2. Duplicate XML Generation
- **Issue**: URL script contains its own XML creation logic
- **Impact**: Violates DRY principle, maintenance burden, potential inconsistencies

### 3. Missing Shared Models
- **Issue**: Both implementations define their own incompatible `Chapter` class
- **Impact**: Cannot share xml_builder or other components

### 4. No VideoMetadata in File Workflow
- **Issue**: File parser has no concept of metadata (hardcoded empty strings in XML)
- **Impact**: Limits extensibility and consistency

## Required XML Output Format

The integration must preserve this exact XML structure for backward compatibility:

```xml
<?xml version='1.0' encoding='utf-8'?>
<transcript video_title="" video_published="" video_duration="" video_url="">
  <chapters>
    <chapter title="Introduction to Cows" start_time="0:02">
      0:02
      Welcome to this talk about erm.. er
      2:30
      Let's start with the fundamentals
    </chapter>
  </chapters>
</transcript>
```

**Note**: File method produces empty metadata attributes. URL method populates them with actual values.

## File-First PR Strategy (Recommended)

### PR 1: `feat/shared-models-foundation` - ✅ COMPLETE

**PR Contents:**
- Create `src/youtube_to_xml/models.py` with shared data structures
- Add comprehensive tests for new models in `tests/test_models.py`

**Value:** Establishes foundational data structures. No dead code - models immediately used by tests.

**Risk:** [Small] - Pure addition, no changes to existing functionality

**Dependencies:** None

---

### PR 2: `refactor/xml-builder-dual-interface` - ✅ COMPLETE

**PR Contents:**
- Update `xml_builder.py` to:
  - Import shared models from `youtube_to_xml.models`
  - Add new function: `transcript_to_xml(document: TranscriptDocument) -> str`
  - Keep existing: `chapters_to_xml(chapters: list[file_parser.Chapter]) -> str`
  - New function handles metadata formatting via time_utils
  - Format TranscriptLine objects properly (timestamp + text pairs)
- Add pragmatic coverage tests for new interface
- Ensure existing tests still pass

**Value:** XML builder ready to handle TranscriptDocument objects. File workflow unchanged.

**Risk:** [Small] - Additive change, backward compatibility maintained

**Dependencies:** PR 1 (models)

**Key Insight:** This PR comes early because it creates the target interface that both parsers will use, establishing the contract before any parser changes.

---

### PR 3: `refactor/file-parser-structured-output` - ✅ COMPLETE

**PR Contents:**
- Update `file_parser.py` to:
  - Import models (Chapter, TranscriptLine, TranscriptDocument, VideoMetadata)
  - Add new function: `parse_transcript_file(raw: str) -> TranscriptDocument`
  - Keep existing: `parse_transcript_file(raw: str) -> list[file_parser.Chapter]`
  - New function converts string lines to TranscriptLine objects during parsing
  - Returns TranscriptDocument with empty VideoMetadata
  - Parser validation guarantees ≥1 chapter or raises FileInvalidFormatError - no fallback needed
- Add tests for new function
- Ensure existing function and tests unchanged

**Value:** File parser can now produce TranscriptDocument objects while maintaining backward compatibility.

**Risk:** [Medium] - Complex string-to-object conversion logic, but isolated in new function

**Dependencies:** PRs 1-2

---

### PR 4: `feat/cli-dual-interface-with-legacy-flag` - ✅ COMPLETE

**PR Contents:**
- Add `--legacy` flag to CLI argument parser:
  ```python
  parser.add_argument(
      "--legacy",
      action="store_true",
      help="Use legacy file parser (for compatibility verification)"
  )
  ```
- Update `cli.py` imports to include both functions:
  ```python
  from youtube_to_xml.file_parser import parse_transcript_file
  from youtube_to_xml.xml_builder import chapters_to_xml, transcript_to_xml
  ```
- Implement dual-path logic (lines 78-89):
  ```python
  if args.legacy:
      chapters = parse_transcript_file(raw_transcript_text)
      xml_output = chapters_to_xml(chapters)
      logger.info("[%s] Used legacy parser path", execution_id)
  else:
      document = parse_transcript_file(raw_transcript_text)
      xml_output = transcript_to_xml(document)
      logger.info("[%s] Used new parser path", execution_id)
  ```
- Add tests to `tests/cli.py` for new default path (using TDD: run to fail first)
- Run `uv run ruff check --fix` > fix problems > run `uv run ruff format`
- Run entire test module to confirm all new tests fail and existing pass
- Implement code in CLI to make the new tests pass
- Add tests to `tests/test_end_to_end.py` that alternate and mirror existing applicable legacy tests - be smart and using the same fixtures and if needed, add flag handling to the existing helper function and calls
- Run `uv run ruff check --fix` > fix problems > run `uv run ruff format`
- Run all of `pytest`
- Last check: write a temporary script that compares the output of  `--legacy` vs default outputs using all the .txt files in `example_transcripts/`. Create a summary report on matches and deviations.

**Value:** True backward compatibility with safe migration path. Users can verify identical outputs and fall back if needed. **Enables confident removal in PR 5** because both paths are proven equivalent.

**Risk:** [Very Small] - Additive change only, existing behavior preserved

**Dependencies:** PRs 1-3

---

### PR 5: `refactor/remove-legacy-flag-and-deprecated-interfaces` - ✅ COMPLETE

**PR Contents:**
- Remove `--legacy` flag from CLI argument parser
- Remove imports and dual-path logic from `cli.py`:
  ```python
  # REMOVE: from youtube_to_xml.file_parser import parse_transcript_file
  # REMOVE: from youtube_to_xml.xml_builder import chapters_to_xml
  # REMOVE: if/else legacy logic
  ```
- Remove deprecated functions:
  - `file_parser.parse_transcript_file()`
  - `xml_builder.chapters_to_xml()`
  - Legacy `file_parser.Chapter` class
- Remove imports of legacy Chapter from xml_builder
- Remove legacy-specific tests added in PR 4
- Update any remaining references in documentation

**Value:** Clean codebase with single source of truth. **Migration confidence** established by PR 4's verification phase.

**Risk:** [Small] - Removing verified-equivalent code paths

**Dependencies:** PR 4

---

### PR 6: `refactor/url-script-use-shared-models` - ✅ COMPLETE

#### PR Contents

Update `scripts/url_to_transcript.py` to:
1. Import shared models from `youtube_to_xml.models`
2. Remove duplicate VideoMetadata, TranscriptLine, Chapter definitions
3. Convert VideoMetadata.video_duration from string to int:
   - Currently: `video_duration: str` (formatted "2h 15m 3s")
   - Change to: `video_duration: int` (raw seconds)
   - Note: formatting now happens in xml_builder via `format_video_duration()`
4. Import and use `xml_builder.transcript_to_xml()`
5. Remove local XML generation functions

#### PR Test Driven Development

- **Current context:** `scripts/url_to_transcript.py` lacks unit tests and was validated through end-to-end tests (`tests/test_end_to_end.py`) and API exception tests (`tests/test_exceptions_ytdlp.py`).
- **TDD approach:** Before each code change in "PR Contents" above, write a focussed unit test that verifies the specific behaviour being modified in `tests/test_url_to_transcript.py` → run for fail → implement code → pass.
- **Test design:** Each test verifies one behaviour with a clear assertion, and tests should be independent and non-overlapping to ensure immediate identification of broken functionality.
- **TDD Example**: Before removing duplicate models (step 2), write a test in `tests/test_url_to_transcript.py` that expects the script to import `VideoMetadata` from `youtube_to_xml.models` → run for fail (script currently uses local VideoMetadata class) → implement the import and remove local class → run for pass)


#### Summary

**Value:** URL script uses shared infrastructure, eliminating ~150 lines of duplicate code

**Risk:** [Small] - URL script already uses compatible structures

**Dependencies:** PRs 1-2 (models and xml_builder with new interface)

---

### PR 7: `refactor/extract-url-parser-module` - ✅ COMPLETE

**PR Contents:**
- Create `src/youtube_to_xml/url_parser.py` as pure parser module (like `file_parser.py`):
  - Extract 3 core functions from `scripts/url_to_transcript.py`:
    - `fetch_video_metadata_and_transcript()`
    - `extract_transcript_lines_from_json3()`
    - `assign_transcript_lines_to_chapters()`
  - Add main interface: `parse_youtube_url(url: str) -> TranscriptDocument`
  - Move all TypedDict definitions and yt-dlp integration logic
- Update `scripts/url_to_transcript.py` to become thin CLI wrapper:
  - Import `url_parser.parse_youtube_url()`
  - **Refactor** `convert_youtube_to_xml()` to use `parse_youtube_url()` (not removed)
  - Keep 4 CLI functions: `main()`, `convert_and_save_youtube_xml()`, `sanitise_title_for_filename()`, `convert_youtube_to_xml()`
- Update test imports in `tests/test_url_to_transcript.py`:
  - Change imports from `scripts.url_to_transcript` to `youtube_to_xml.url_parser`
  - Expand from 3 to 5 test classes with 11 test methods total
  - Test module contracts and shared model usage
- Keep `url_to_transcript_wrapper.py` unchanged (imports from script)

**Implementation Note:** `convert_youtube_to_xml()` was **refactored but not removed** from the script. This creates better architectural consistency with `file_parser.py` patterns - the module provides pure parsing while the script maintains CLI wrapper functions.

#### TDD Implementation

**Test-driven approach:**

1. **Write test for main interface behavior**:
   ```python
   def test_url_parser_has_main_interface():
       """Test that parse_youtube_url exists and has correct signature."""
       from youtube_to_xml.url_parser import parse_youtube_url
       # Verify it accepts URL string and returns TranscriptDocument type
   ```

2. **Create module with interface stub** → make test pass

3. **Extract functions incrementally** with existing test verification

4. **Update script to use new module** and verify integration tests pass

5. **Update test imports** and verify all 23 URL-related tests pass

**Value:** Reusable URL parsing module following established architecture patterns

**Risk:** [Medium] - Import path changes could break tests if not handled carefully. Mitigate by verifying imports after each function extraction.

**Dependencies:** PR 6

---

### PR 8: `feat/unified-cli-auto-detection`

**PR Contents:**
- Update `cli.py` to support both file and URL inputs:
  - Auto-detect input type (file path vs URL) using robust YouTube detection
  - Import `url_parser.parse_youtube_url` for URL inputs
  - Both paths: input → parse_transcript_document/parse_youtube_url → transcript_to_xml → save file
  - Update argument help text: `"YouTube transcript file OR YouTube URL"`
  - Add URL-specific error handling with user-friendly messages
- Add comprehensive end-to-end tests for URL input in `tests/test_end_to_end.py`
- Add deprecation warning to `url_to_transcript_wrapper.py`:
  ```python
  print("Note: This command is deprecated. Use 'youtube-to-xml <url>' instead.", file=sys.stderr)
  ```
- Update `README.md` to document unified CLI with both input types

#### URL Detection Approach

- Add simple function to detect YouTube URLs:
  ```python
  def is_youtube_url(input_string: str) -> bool:
      """Detect if input is a YouTube URL."""
      youtube_patterns = ["youtube.com", "youtu.be"]
      return any(pattern in input_string.lower() for pattern in youtube_patterns)
  ```
- Route to appropriate parser based on detection
- Handle URL-specific exceptions with user-friendly messages

#### TDD Implementation

**TEST-DRIVEN APPROACH:**

**Test design:** Each test verifies one behaviour with a clear assertion, and tests should be independent and non-overlapping to ensure immediate identification of broken functionality.

1. **Write URL detection tests** that verify YouTube URLs are identified correctly
2. **Write CLI routing tests** that verify URLs are processed by url_parser
3. **Write integration tests** that verify end-to-end URL processing
4. **Add deprecation warning** to experimental command wrapper
5. **Verify backward compatibility** - all existing file tests continue to pass

**Value:** Single entry point for both input types, maintains experimental command during transition

**Risk:** [Small] - Simple routing logic, preserves all existing functionality

**Dependencies:** PR 7

---

### PR 9: `cleanup/remove-experimental-command`

**PR Contents:**
- Remove `scripts/url_to_transcript.py` (functionality integrated)
- Remove `src/youtube_to_xml/url_to_transcript_wrapper.py` (no longer needed)
- Remove `url-to-transcript` entry point from `pyproject.toml`
- **Migrate all 23 URL-related tests** to use unified CLI:
  - `tests/test_end_to_end.py` (5 tests): Update from `url-to-transcript` to `youtube-to-xml`
  - `tests/test_exceptions_ytdlp.py` (11 tests): Update command to `youtube-to-xml`
  - `tests/test_url_to_transcript.py` (7 tests): Rename to `test_url_parser.py`, update imports
- Update `README.md`:
  - Remove experimental command references
  - Finalize unified CLI documentation with examples:
    ```bash
    # File input (existing)
    youtube-to-xml transcript.txt

    # URL input (new)
    youtube-to-xml https://youtube.com/watch?v=abc123
    youtube-to-xml https://youtu.be/xyz789
    ```

#### Test Migration Approach

1. **Create parallel tests** to verify unified CLI works before removing old command
2. **Migrate all test commands** from `url-to-transcript` to `youtube-to-xml`
3. **Rename test file** from `test_url_to_transcript.py` to `test_url_parser.py`
4. **Delete experimental files** after verifying all 23 tests pass
5. **Update documentation** to reflect single unified CLI

**Value:** Clean codebase with single source of truth, complete integration achieved

**Risk:** [Small] - Cleanup after proven integration, comprehensive test migration

**Dependencies:** PR 8

## PR Implementation Summary

**Foundation & File Migration**
- ✅ PR 1: **Shared models foundation**: Create `models.py` with TranscriptDocument, VideoMetadata, Chapter, TranscriptLine
- ✅ PR 2: **XML builder dual interface**: Add new transcript_to_xml function + keep legacy chapters_to_xml
- ✅ PR 3: **File parser dual output**: Add new parse_transcript_document function + keep legacy function
- ✅ PR 4: **CLI dual-path with legacy flag**: Supports both legacy and new interfaces with --legacy flag for verification
- ✅ PR 5: **Remove legacy flag and deprecated interfaces**: Clean removal after equivalence verified in PR 4

**URL Integration & Unification**
- ✅ PR 6: **URL script adopts shared models**: Uses xml_builder.transcript_to_xml, removes duplicate XML code
- ✅ PR 7: **Extract url_parser module**: Create pure parser with `parse_youtube_url()`, expand to 11 test methods
- PR 8: **Unified CLI with simple URL detection**: Single entry point with deprecation warnings
- PR 9: **Remove experimental command**: Migrate all 23 tests, cleanup after integration proven

## Success Metrics

- [ ] **PRs are developed with TDD** - write tests before implementation, fail-first approach
- [ ] **Pragmatic test coverage** for all new functions and models
- [ ] **All existing tests pass** after each PR without modification
- [ ] **No breaking changes** to file-based workflow
- [ ] **Identical XML output** for equivalent file/URL inputs verified by end-to-end tests
- [x] **Single XML generation path** through file_parser.parse_transcript_file and xml_builder.transcript_to_xml after PR 5
- [ ] **Single CLI entry point** handles both files and URLs transparently after PR 8
- [ ] **Zero code duplication** between file and URL parsers after PR 9
- [ ] **Complete documentation** reflects unified CLI functionality after PR 9
- [ ] **Clean module architecture** with pure parsers and CLI orchestration after PR 9
- [ ] **All 23 URL tests successfully migrated** to unified CLI after PR 9